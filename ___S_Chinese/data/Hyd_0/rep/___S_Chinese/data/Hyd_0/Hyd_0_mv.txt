//HYD_MoveTable <- {};
local t = {};

// BMvTbl.SetTutoMvFlag( 1 ); // 詐欺飛び
// BMvTbl.SetTutoMvFlag( 2 ); // ガード仕込み
// BMvTbl.SetTutoMvFlag( 5 ); // ミッションのバティスタに近づいた（COMから操作）
// BMvTbl.SetTutoMvFlag( 6 ); // 投げ抜け不能投げで掴まれた（相手から操作）
// BMvTbl.SetTutoMvFlag( 3 ); // 3+Bを相手の技の空振りに差し込んだ
// BMvTbl.SetTutoMvFlag( 4 ); // 2+Cをバクステの硬直にあてた
// BMvTbl.SetTutoMvFlag( 7 ); // VO中に623EXを使った

// BMvTbl.SetTutoMvFlag( 8 ); // 投げ抜け仕込みしゃがみA
// BMvTbl.SetTutoMvFlag( 9 ); // 投げ抜け仕込み通常技対空
// BMvTbl.SetTutoMvFlag( 10 ); // 投げ抜け仕込みバックステップ
// BMvTbl.SetTutoMvFlag( 11 ); // 投げ抜け仕込みジャンプ攻撃
// BMvTbl.SetTutoMvFlag( 12 ); // 投げ抜け仕込みヴェールオフ
// BMvTbl.SetTutoMvFlag( 13 ); // 236EXに対して暗転返しをしたっぽい


t.Mv_Throw_F <-
{
	function Init() // 
	{
		// _dp("\n Mv_Throw_F_Init()");
		
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Throw_F);
		BMvTbl.ClearHitStatus(); // ヒット情報のクリア
		Battle_Std.ThrowTech.SetThrowMvFlag(); //投げ属性Mvを設定
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_InActive );
		
//		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //再生済みフラグ
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
		
		if( BMvTbl.GetCmdNumber()==def_CN_Throw_F && Battle_Std.GS_CheckFlag( def_PP_GS_SlideDashThrow ) ) // スライド投げ
		{
			_dp("\n ★★スライドダッシュ投げ★★");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Throw_F + def_MC1_GenFlag == スライド投げ
		}
	}
	function HitInterrupt()
	{
		local neutral_tech = 0;
		
		local p_mvs = BMvTbl.GetMvStatus();
		
		//この時点で相手はダメージ状態…ではない（つかみ命令入ってない）
		//のけぞりは当然入ってくる
		if( Battle_Std.CheckDamageTiming() )
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			
			local isBMCapture = false;
			if( enemy.IsDone )
			{
			
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local hs = BtlMvStd.GetBoundStatus();
					isBMCapture = ((hs.isCapture&(1<<1))!=0); //Bound or Muteki Capture
					//print("\nhs.isCapture"+hs.isCapture+" isBMCapture:"+isBMCapture);		
					
					local e_mvs = BMvTbl.GetMvStatus();
					local e_mvn = BMvTbl.GetMvName();
					
				BMvCore.PopCharaData(); // 
				
				Battle_Std.DrawDebugAttackInfo("c "+e_mvs.MvCount+" pc "+p_mvs.MvCount+" n "+e_mvn );
				
				if( e_mvs.MvCount == p_mvs.MvCount && e_mvn == "Mv_Throw_F" )
				{
					Battle_Std.DrawDebugAttackInfo("neutral tech" );
					
					Battle_Std.SetThrowHitFinalize(1024);
					neutral_tech = 1;
				}
				
			}
			if(	!neutral_tech )
			{
				if( isBMCapture ) //BM掴みかどうか
				{
					// _dm("Boundか投げ無敵中をつかんだので補正をかけます");

					//コンボ補正あり
					BMvEff.ComboView_Set( { val=def_HOSEI_BoundMutekiCapture, type=1 } ); // 乗算
					// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_BoundMutekiCapture,1,0,0,0, 0,0,0,0,0, 0,0 ]} );

					// Battle_Std.DrawDebugAttackInfo("! Gouin Nage");	
					Battle_Std.SetThrowHitFinalize(512); // ヒット分岐ファイナライズ		
				}
				else
				{
					Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
				}
				// 相手にフラグを与える
				if( enemy.push() )
				{
					// print("\n 状態セット:"+_AsFlag_DamageEx);
					// BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=64, flag=0 } ); // 特殊やられ
					
					enemy.pop();
				}
			}
		}
	}
	function FrameUpdate()//
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		if( s.MvCount>=4 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			Battle_Std.InitVector();
			
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
			
			//投げスカりのGRD減少
			// これは相手がやられ中でも減らす。なんとなく。
			Battle_Std.GRD_AddValue({ val=def_GRD_ThrowMiss, pressure=0, boundplus=0,target=0 });
		}
	}
	function Finalize() // 
	{
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //カウンタ初期化
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"],[1024,"Mv_Throw_F_NeutralTech"] ); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
	}
}

//-----------------------------------------------------------------------------
// フォースファンクション
//-----------------------------------------------------------------------------
local setSousaiBonus = function()
{
	// GRD上昇
	// ヒット扱いということでキャンセル可能に？
	// 多段とかもあるし？飛び道具取るだけだから難易度は低いので増加も少なめ
	Battle_Std.GRD_AddValue( { val=2500, boundplus=1 } ); // GRD増加
	
	_dp("\n 相殺成功でキャンセル可能にした");
	BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=254, flag=_ClearFlag_ChangeMv } );
}

//相手に削りダメージを与える
//vpdamageが＋なら、VP時はそちらを採用する
local addKezuriDamage = function( damage=100, vpdamage = -1 )
{
	local dmg_val = ( vpdamage > 0 && BMvEff.GRD_GetJudgeResult() > 0 )? vpdamage : damage;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		_dpn("削り加算:"+dmg_val);
		Battle_Std.SetKezurareDamage( dmg_val ); // 削られダメージ適用
		
		enemy.pop();
	}
}

t.Mv_Atk_StdBandC <-
{
	function Init_After()
	{
		Battle_Std.SetVorpalPattern( "V_B+C" );
		
		// 181108 弾相殺追加
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // 相殺が発生する
		
		// 181108 CS可能ならCVO可能に（iFF用）
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnableCVO_OnlyCS );
		
		BMvTbl.SetLP(0,0); // 飛び道具消したかどうか
	}
	function FrameUpdate_After() : (setSousaiBonus)
	{
		Battle_Std.JumpFrameID_NotHoldAllButton({ mask=(1<<1)|(1<<2), checkid=[100,200], jumpid=[101,101], endid=250 }); //ボタンホールドしてなかったらIDジャンプ
		
		// 181108 弾相殺追加
		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
		if( BMvTbl.GetLP(0)==0 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) )
		{
			BMvTbl.SetLP(0,1); // 消した
			
			setSousaiBonus(); // GRD増加、空振り必殺キャンセル可能に
		}	
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			// ヒットスロウをかける
			BMvEff.Slowmotion_Set( { time=10, power=6666 } );
			BMvEff.SetCamera_Quake( { type=2, time=20, } );
		}
		
		if( Battle_Std.CheckGuardTiming() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
			
			local mvs = BMvTbl.GetMvStatus();
			local mvs_FrameID = mvs.FrameID;
			
			//VP時のみ削り追加
			if( mvs_FrameID == 500 || mvs_FrameID == 400 )
			{
				//IC時にさらに追加
				local dmg_val = (mvs_FrameID == 500)? 550 : 150;
				
				addKezuriDamage( dmg_val );
			}
		}
	}
}

//-----------------------------------------------------------------------------
// イベント
//-----------------------------------------------------------------------------

local call_TutorialCheckerObject = function()
{
	if( BMvTbl.GetMvStageStatus().IsTrainingBattle() != 2 ) return; // チュートリアルの時だけ処理する
	
	BMvEff.CreateObject( { mvname="Mv_Null_TutoChecker" } );
}

/*

t.Mv_Obj_CheckStartupFrameAlternate_Debug <-
{
	function clear_lp()
	{
		BMvTbl.SetLP(0,-1); //startup
		BMvTbl.SetLP(1,0); //active
		BMvTbl.SetLP(2,-1); //recovery
		BMvTbl.SetLP(3,-1); //p mvcnt
		BMvTbl.SetLP(4,0); //isobj
		BMvTbl.SetLP(5,0); //obj mvcount
		
		
		BMvTbl.SetLP(6,0); //reset
	}
	function draw_info(pre_string = "")
	{				
		local startup = BMvTbl.GetLP(0) + 1;
		local active = BMvTbl.GetLP(1);
		local recovery = BMvTbl.GetLP(2) - 1;
		local total = BMvTbl.GetLP(3);
		
		if(BMvTbl.GetLP(4)==0) startup += 1;
		
		local out = pre_string + format("%d %d %d (%d)",startup,active,recovery,total,0);
		
		//out += " isobj? "+BMvTbl.GetLP(4);
		
		//out += " "+Battle_Std.GetPlayerMvName();
		
		if( active > 0 ) Battle_Std.DrawDebugAttackInfo(out);
	}
	function Init()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local mvs = BMvTbl.GetMvStatus();
		local re_occ = 0;
		
		if( mvs.CallCount==1 )
		{
			local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc   } );
			local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourObj   } );
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local p_mvs = BMvTbl.GetMvStatus();
				local atk_rect = BMvEff.IsAttackRect();
				local oc = BMvEff.GetMyObjectCount();
				
				local p_stoptime = BMvEff.IsMyStopTime();
				
				local p_move = ( BCMDTbl.CheckCancel( _SkillType_None ) > 0 );
				
				player.pop();
				
				//Battle_Std.DrawDebugAttackInfo("frame "+p_mvs.MvCount+" atkrect "+atk_rect+" myframe "+mvs.MvCount);
							
				if( !p_stoptime && BMvTbl.GetLP(1)==0 ) BMvTbl.AddLP(0,1); //startup minus stoptime
				
				//Battle_Std.DrawDebugAttackInfo("start "+BMvTbl.GetLP(0)+" act "+BMvTbl.GetLP(1)+" mv "+p_move );
				
				if( !p_stoptime ) BMvTbl.AddLP(3,1); //total mvcount minus stoptime
				
				if( e_pc.push() )
				{
					local pc_mvs = BMvTbl.GetMvStatus();
					
					e_pc.pop();
					
					//Battle_Std.DrawDebugAttackInfo("pushtime "+p_mvs.MvCount+" mycount "+BMvTbl.GetLP(0));
					
					if( BMvTbl.GetLP(2) > 0 ) 
					{
						re_occ = 1;
						
						local startup = BMvTbl.GetLP(0) + 1;
						local recovery = BMvTbl.GetLP(2) + 1;
						local total = BMvTbl.GetLP(3);
						
						BMvTbl.AddLP(2,2); //correct incorrect recovery
						
						draw_info("reocc pc " );
						//Battle_Std.DrawDebugAttackInfo("reocc "+startup+" "+active+" "+recovery+" "+total);
						
						
						clear_lp();
						
						//Battle_Std.DrawDebugAttackInfo("reoccfo "+recovery);
						
						BMvTbl.SetLP(0,startup+recovery+1);
						BMvTbl.SetLP(3,0);
						
						if(!p_stoptime) BMvTbl.AddLP(1,1);

					}
					else
					{
						if(!p_stoptime) BMvTbl.AddLP(1,1); //active frames
					}
					
											
					BMvTbl.SetLP(4,0); //is not obj

					//Battle_Std.DrawDebugAttackInfo("pl push frame "+p_mvs.MvCount);
				}
				else if( BMvTbl.GetLP(1) > 0 && !e_obj.isdone() )
				{
					BMvTbl.AddLP(2,1); //recovery frames
				}
				
				if( e_obj.push() )
				{
					if(!p_move )
					{
						local obj_mvs = BMvTbl.GetMvStatus();
						local obj_stoptime = BMvEff.IsMyStopTime();
						local obj_hs = BMvTbl.GetMvHitStatus();
						
						//BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop } );
						
						e_obj.pop();
								
						
						
						local o_cnt = BMvTbl.GetLP(5);
						
						BMvTbl.SetLP(5,obj_mvs.MvCount);
						
						local o_cnt_c = obj_mvs.MvCount;
						
						//Battle_Std.DrawDebugAttackInfo("hs "+obj_hs.Count+" cc "+obj_mvs.MvCount);

						//if( BMvTbl.GetLP(1)==0 ) BMvTbl.AddLP(0,-1); //correct wrong startup for nonplayer obj
						
						if( BMvTbl.GetLP(2) > 0 ) 
						{
							re_occ = 1;
							
							local startup = BMvTbl.GetLP(0) + 1;
							local recovery = BMvTbl.GetLP(2) + 1;
							local total = BMvTbl.GetLP(3);
							
							BMvTbl.AddLP(2,2); //correct incorrect recovery
							
							draw_info("reocc obj ");
							
							//Battle_Std.DrawDebugAttackInfo("obj reocc "+startup+" "+active+" "+recovery+" "+total);
							
							clear_lp();
							BMvTbl.SetLP(0,startup+recovery+1);
							BMvTbl.SetLP(3,0);
							
							if( !p_stoptime && o_cnt != o_cnt_c ) BMvTbl.AddLP(1,1);

						}
						else
						{
							if(!p_stoptime && o_cnt != o_cnt_c ) BMvTbl.AddLP(1,1); //active frames
						}
						
						BMvTbl.SetLP(4,1); //isobj
					}
					else if( BMvTbl.GetLP(1) > 0 && !e_pc.isdone() )
					{
						e_obj.pop();
						//BMvTbl.AddLP(2,1); //recovery frames
					}
					else
					{
						e_obj.pop();
					}
				}

				
				if( BMvTbl.GetLP(6)==1 )
				{
					//draw_info();
					//clear_lp();
				}
				
				//Battle_Std.DrawDebugAttackInfo("oc "+p_mvs.MvCount);
				
				//if( ( p_move || re_occ ) )
				
				if( BMvTbl.GetLP(6) )
				{
					//BMvTbl.SetLP(6,1);
					
					//if(BMvTbl.GetLP(0) > 0 ) Battle_Std.DrawDebugAttackInfo("d "+p_move+" cnt "+mvs.MvCount+" pmvcnt "+BMvTbl.GetLP(3)+" 2 "+p_mvs.MvCount );
					//BMvTbl.AddLP(0,1);
					
					if( 1 )
					{
						//BMvTbl.AddLP(3,p_mvs.MvCount);
						if( !re_occ ) draw_info();
					
						if( re_occ )
						{
						}
						else
						{
							clear_lp();
						}
					}
				}
			}
		}
		else
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local p_mvs = BMvTbl.GetMvStatus();
				local p_move = ( BCMDTbl.CheckCancel( _SkillType_None ) > 0 );
				
				player.pop();
				
				if( p_move ) BMvTbl.SetLP(6,1);
				else
				{
					BMvTbl.SetLP(6,0);
				}
				
				//Battle_Std.DrawDebugAttackInfo("ocdz "+p_mvs.MvCount);
			}
		}
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.CallCount==0 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Obj_CheckStartupFrameAlternate_Debug" );
	}	
}
*/

local recover_init = function()
{
	Battle_Std.GRD_AddValue({ val=def_GRD_Recover }); //受身で増加	
	
	if( Battle_Std.RoundisEnd() == false ) // 決着ついた後はボイスを無くす
	{
		Battle_Std.TypeSE_Play({ type="受け身" });
	}
	
	BMvEff.CreateObject( { mvname="Mv_RecoverInitObject_Mask" } ); //121015追加
	
	Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	
	if( _isDebugModeExe )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_RecoverLateCombo", datatype=1, start_pat=999 } );	
		}
		BMvCore.PopCharaData(); //
	}
}

/*
t.Mv_Bound <- 
{
	function FrameUpdate_After()
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( bs.GetVecCount() > 0 )
		{
			if( BCMDTbl.CheckPosState( _PosState_Air ) )
			{
				if( enemy.push() )
				{
					local cpval = BMvTbl.ComboPoint_Calc({});

					enemy.pop();
					
					local nowvec = BMvTbl.GetVector( { flags=_Vector_Bound } );
					if(nowvec.y < 0)
					{
						local use_val = (100 - cpval)*0.04;
						
						nowvec.y += use_val;
						
						Battle_Std.DrawDebugAttackInfo( "cnt "+bs.GetVecCount()+" D "+cpval+" usev "+use_val+" nvy "+nowvec.y );
						
						BMvTbl.SetVector( { x=nowvec.x, y=nowvec.y, addx=nowvec.addx, addy=nowvec.addy, flags=_Vector_Bound } );
					}
				}
			}
		}
	}
}


t.Mv_Recover <- 
{
	function Init() : (recover_init) // 
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		BMvTbl.SetMuki( _Direction_Auto ); //見た目を変更（ベクトル入れる前に変更してもＯＫになった）
		
		local check_rst = rst.Type; //判定に使う受身ステータス
		//rst.Type 受け身入力時のレバー方向　※相手依存になった
		//0:ニュートラル
		//1:前
		//2:後ろ
		//3:下
		
		//寝ている状態からの復帰もここ
		//Y座標が0なら多分そうなので下受身はできないようにだけしておく
		
		local pos_factor = -75*128;
		
		local pos = BMvTbl.GetPosition(0);
		if( pos.y >= pos_factor ) //ダウン受け身の時
		{
			check_rst = 10;
			
			BMvTbl.SetPosition( { y=0 } );
		}
		else // 空中受身の時
		{
			if( check_rst==3 ) check_rst=0; //下受け身を廃止・ニュートラル受け身に書き換える
		}
		if( Def_Rule_AirRecover_ClearAirJumpCount ) // 受け身時に二段ジャンプの回数をリセットする
		{
			BMvTbl.AddAirJumpCount( -10 ); // 0回以下にはならないので多めに引く
		}
		BMvTbl.SetPattern("DUkemi_0");
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る		
		
		BMvTbl.SetFinalize(check_rst);
	}
}
*/

t.Mv_Startup <-
{
	function Init_After() : (call_TutorialCheckerObject)
	{
		call_TutorialCheckerObject();
	}
}

local phaseshift = function(delayfr = 0)
{
	local mvs = BMvTbl.GetMvStatus();
	BMvTbl.SetLP(0,mvs.MvCount);
	BMvTbl.AddLP(1,1);
	
	BMvTbl.AddLP(0,delayfr);
	
	//Battle_Std.DrawDebugAttackInfo("phase "+BMvTbl.GetLP(1)+" delayfr "+delayfr);
		//Battle_Std.DrawDebugAttackInfo("delayfr "+delayfr+" mvcnt "+mvs.MvCount+" d "+BMvTbl.GetLP(0)+" p "+BMvTbl.GetLP(1));
}

t.Mv_Obj_StandbySetObj <-
{
	function Init_After()
	{
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_RenderShadow } );
		
		BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoGround } );
		BMvTbl.SetLP(0,0); //mvcnt
		BMvTbl.SetLP(1,-2); //phase
		
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei ,mode=_ExistMode_Set } );
	}
	function FrameUpdate_After() : (phaseshift)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 500:
				Battle_Std.CreateObjectEX( { x=-204, y=-200, datatype=1, pat=308, flags=_Position_ToolShift });
				Battle_Std.CreateObjectEX( { x=-204, y=-200, datatype=0, pat="Grp_Hit_HydSlashC", flags=_Position_ToolShift });
				
				BMvEff.SetCamera_Quake( { time=15, type=0, clear=0, } );
				
				break;
		}
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isFrameUpdate )
		{
			local param_val = BMvTbl.GetFrameParam( 3 );
			if( param_val >> 0 )
			{
				if(param_val > 127)
				{
					param_val = param_val - 256;
				}
				
				BMvTbl.SetPosition( { x=param_val, flags=_Position_ToolShift|_Position_ChangeMuki|_Position_Add } );
			}
		}
		
		local phase = BMvTbl.GetLP(1);
		
		local plo_pos = 0;
		local plo = BMvCore.GetParentCharaData();
		if( plo.push() )
		{
			plo_pos = BMvTbl.GetPosition();
			plo.pop();
		}
		
		if( mvs.CallCount==0 )
		{
			if( BMvTbl.GetLP(0) == mvs.MvCount )
			{
				switch( phase )
				{
					case -2:			
						phaseshift(45);

						break;
					case -1:
								
						BSound.SE_Play( { type=_SeType_Player, num=590 } );
						
						phaseshift(30);
						break;
					case 0:
						BMvTbl.SetPattern("StandbySet_Phase1");
						
						phaseshift(35);
						break;
					case 1:
						//BMvTbl.SetPattern("6B");
						
						if( plo.push() )
						{
							//BMvTbl.SetMuki(_Direction_Reverse);
							plo.pop();
						}
						
						BMvTbl.SetPattern("StandbySet_Phase2");
						
						BMvTbl.SetMuki(_Direction_Reverse);
						
						phaseshift(40);
						break;
					case 2:
						BMvTbl.SetPattern(403);
						BMvTbl.Frame_Proc( 2, _ValSet );
						
						BMvTbl.SetVector( { x=7050, addx=-340, flags=_Vector_Normal } );
						
						phaseshift(8);
						break;
					case 3:
						
						Battle_Std.CreateObjectEX( { x=-204, y=-200, datatype=1, pat=308, flags=_Position_ToolShift });
						Battle_Std.CreateObjectEX( { x=-220, y=-160, datatype=0, pat="Grp_Hit_HydSlashD", flags=_Position_ToolShift });
						
						BMvEff.SetCamera_Quake( { time=15, type=0, clear=0, } );
						
						phaseshift(3);
						break;
					case 4:
						BMvTbl.SetMuki(_Direction_Reverse);
						BMvTbl.JumpFrameID(256);

						
						/*
						BMvTbl.SetPattern("StandbySet_Phase4");
						
						phaseshift(21);
						*/
						
						phaseshift(6);
						break;
					case 5:
						Battle_Std.InitVector();
						phaseshift(13);
						/*
						BMvTbl.SetPattern(17);
						
						phaseshift(30);
						
						Battle_Std.InitVector();
						*/
						break;
					case 6:
						BMvTbl.SetPattern("StandbySet_Phase5");
						/*
						BMvTbl.Frame_Proc( 16, _ValSet );
						
						phaseshift(4);
						
						Battle_Std.InitVector();
						*/
						
						break;
					case 6:
						BMvTbl.SetPattern(68);
						phaseshift(4);
						break;
					case 7:
						BMvTbl.JumpFrameID(30);
						BMvTbl.SetVector( { x=8500, y=-2500, addx=-80, addy=150, flags=_Vector_Normal } );
						
						phaseshift(5);
						break;
					case 8:
						BMvEff.Slowmotion_Set( { time=20, power=6666 } );
						phaseshift(4);
						break;
					case 9:
						BMvTbl.SetVector( { x=3000, y=0, addx=-80, addy=150, flags=_Vector_Normal } );
						BMvTbl.JumpFrameID(100);
						
						phaseshift(31);
						//BMvTbl.SetVector( { x=3000, y=-3000, addx=-50, addy=150, flags=_Vector_Normal } );
						break;
					case 10:
						BMvTbl.SetPattern(15);
						BMvTbl.SetMuki(_Direction_Reverse);
						
						BMvTbl.SetPosition( { x=plo_pos.x } );
						
						phaseshift(0);
						break;
					case 11:
						BMvTbl.SetPattern("StandbySet_Phase5");
						
						//BMvTbl.SetPosition( { x=-100, flags=_Position_Add | _Position_ChangeMuki | _Position_ToolShift } );
						
						phaseshift(50);
						//BMvTbl.SetMuki(_Direction_Reverse);
						break;
					case 12:
						BMvTbl.SetFinalize(0);
						
						break;
						
				}
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetRoundStart();
		
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			BMvTbl.SetPattern(0);
			
			BMvTbl.SetFinalize(0);

			oya.pop();
		}
				
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_StandbySet <-
{
	function Init_After()
	{
		BMvEff.CreateObject( { x=-2000, y=0, mvname="Mv_Obj_StandbySetObj", flags=_Position_ToolShift } );
		//BMvTbl.SetPosition( { x=-4000*128 } );
		BMvTbl.SetPattern("StandbySet");
		
		local pos = BMvTbl.GetPosition();
		
		BMvTbl.SetLP(0,pos.x);
		
				
		//if( Battle_Std.TypeSE_Play({ type="Taunt_Init" }) );
	}
	function Update_After()
	{
		BMvTbl.SetPosition( { x=BMvTbl.GetLP(0) } );
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral"); //デフォ,[code,mv]...
	}
}

t.Mv_Standby <-
{
	function Init_After() : (call_TutorialCheckerObject)
	{
		call_TutorialCheckerObject();
		
		local e_chr = Battle_Std.GetEnemyCharaNo();
		
		if( e_chr == Def_ChrNo_Set )
		{
			BMvTbl.SetFinalize(256);
		}
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 900:
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_950ef", flags=_Position_ToolShift } );
			break;
		}
	}
	function LastUpdate()
	{
		
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_StandbySet"]); //デフォ,[code,mv]...
	}
}

t.Mv_Null_TutoChecker <-
{
	function Init_After()
	{
		// _dp("\n 開始");
	}
	function FrameUpdate_After()
	{
		//現状は投げ抜けチェッカーとしてしか機能しない！
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local mvname = BMvTbl.GetMvName();
			local thmv = (mvname == "Mv_Bound_0023")? 1 : 0;
			
			// まず投げが成立していることが条件・・・は投げ抜けMvチェックするようになったので不要、かつこれだとヒットしないこともあった
			local grap = BMvTbl.CheckCommandString( { command = [ "A+B+C+D", "71+AD", "4+A+BD", "3+A+C+D", "v+AD" ], lastdelay=1 } ); // ガバガバ判定なので注意(ADのところがガバい)
			
			local vomv = (mvname == "Mv_Liberate")? 1 : 0;
			if( grap == 1 && vomv )
			{
				thmv = 1; // VOに仕込めていても成功にする
			}
			
			/*
			if( thmv || grap )
			{
				_dp1p("\n thmv:"+thmv+" grap:"+grap );
			}
			*/
			if( thmv && grap )
			{
				// _dp("\n grap:"+grap );
				
				switch( grap )
				{
				case 1:
					BMvTbl.SetTutoMvFlag( 12 ); // 投げ抜け仕込みヴェールオフ
					break;
				case 2:
					BMvTbl.SetTutoMvFlag( 11 ); // 投げ抜け仕込みジャンプ攻撃
					break;
				case 3:
					BMvTbl.SetTutoMvFlag( 10 ); // 投げ抜け仕込みバックステップ
					break;
				case 4:
					BMvTbl.SetTutoMvFlag( 9 ); // 投げ抜け仕込み通常技対空
					break;
				case 5:
					BMvTbl.SetTutoMvFlag( 8 ); // 投げ抜け仕込みしゃがみA
					break;
				
				}
				
			}
			
			player.pop();
		}
	}
}

// 登場時のインスレーター出現エフェクト
// ハイドの特殊判定の座標にくっつく
t.Mv_Obj_950ef <-
{
	function Init_After() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange } );
	}
	function FrameUpdate_After() // 
	{			
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local oya_UpdateFrameID = Battle_Std.GetUpdateFrameID();
			
			local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=0 } );
			player.pop();
			
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				local use_Xpos = (BMvTbl.GetMuki() == 1)? rc.sx : rc.ex; // 右向きならsx、左向きならex
				BMvTbl.SetPosition( { x=use_Xpos, y=rc.sy } );
			}
			if( oya_UpdateFrameID == 600 ) // 親が終了のところまで進んだ
			{
				BMvTbl.JumpFrameID( 600 ); // 消滅アニメへ
			}
		}
	}
}

//-----------------------------------------------------------------------------
// 共通動作
//-----------------------------------------------------------------------------

local check_Tuto_Guard = function()
{
	if( BMvTbl.GetMvStageStatus().IsTrainingBattle() != 2 ) return; // チュートリアルの時だけ処理する
	
	if( BMvTbl.CheckStickHold( (1<<4) | (1<<1) ) )
	{
		// _dp("\n ガード仕込み");
		BMvTbl.SetTutoMvFlag( 2 ); // フラグたて
	}
}

t.Mv_DashWait_F <-
{
	function FrameUpdate_After() : (check_Tuto_Guard)
	{
		check_Tuto_Guard(); // ガードを入れるとフラグがたつ
	}
}

t.Mv_Dash_F <- 
{
	function FrameUpdate_After() : (check_Tuto_Guard)
	{
		check_Tuto_Guard(); // ガードを入れるとフラグがたつ
	}	
}

t.Mv_DashStop_F <- 
{
	function FrameUpdate_After() : (check_Tuto_Guard)
	{
		check_Tuto_Guard(); // ガードを入れるとフラグがたつ
	}	
}

t.Mv_Dash_B <- // バクステ
{
	function Init_After() // 
	{
	}
}

//-----------------------------------------------------------------------------
// 通常投げ
//-----------------------------------------------------------------------------

t.Mv_Throw_F_Hit <-
{
	function Init_After()
	{
		Battle_Std.SetThrowEnemyMuteki( 254 ); // 投げ中の相手に無敵時間を設定
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 900:
			BMvEff.ThrowParam( { pat=326, x=50, y=0 } );
			BMvEff.ThrowRelease( { type="前転倒", airrecover=0, flags=0 } );
			break;
		case 1000: // ここで攻撃
			Battle_Std.SetThrowEnemyMuteki( 0 ); // 投げ中の相手に無敵時間を設定
			break;
		}
	}
	function Update_After()
	{
		// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 2 )
		{
			local change_mv = BMvTbl.ChangeMv_GetMvName();
			if( change_mv == "Mv_Throw_F_TechMissWait" )
			{
				// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local mvname = BMvTbl.GetMvName();
					if( mvname == "Mv_Bound" )
					{
						// チュートリアルの時だけ処理する
						// _dm("\n 投げ抜けできない:"+BMvTbl.GetTutoMvFlag( 6 ) );
						BMvTbl.SetTutoMvFlag( 6 ); // 投げ抜け不能投げで掴まれた（相手から操作）
					}
					enemy.pop();
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------
// 通常攻撃
//-----------------------------------------------------------------------------

// 相手の特定のMvの重なり判定に攻撃が重なっているとフラグが立つ関数
local check_Tuto_Sagi = function( param={} )
{
	if( BMvTbl.GetMvStageStatus().IsTrainingBattle() != 2 ) return; // チュートリアルの時だけ処理する
	
	// チュートリアル用の仕込み
	// 詐欺飛びチェック
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == param.frameID )
	{
		// ためJCや22の攻撃部分
		// 攻撃判定が相手の重なりに重なっている…？
		local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Kasanari , 0, -1 ], flags=_HC_EnemyPc } );
		if( enemy.push() )
		{
			local emvs = BMvTbl.GetMvStatus();
			local emvname = BMvTbl.GetMvName();
			
			enemy.pop();
			
			if( emvs.CharaNo == param.chr && emvname == param.mvname )
			{
				//_dp("\n 詐欺飛びできてるよ！！");
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					BMvTbl.SetTutoMvFlag( 1 ); // フラグたて
					
					player.pop();
				}
			}
		}
	}
}

t.Mv_Taunt <- //se doesnt work in the custom for some reason
{
	function Init_After()
	{
		BMvTbl.SetPattern("Taunt");
		//BMvTbl.SetMoveableFlag( { move=0, time=1024, flag=_ClearFlag_ChangeMv } );
		
		if( Battle_Std.TypeSE_Play({ type="Taunt_Init" }) ) //play assigned taunt se if available
		{
			
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="挑発" });
		}
		
		BMvTbl.SetMuki(_Direction_Auto);
		
		//BMvTbl.SetAsFlag( { as_flags=_AsFlag_ExCancel, time=1024, flag=_ClearFlag_ChangeMv } );
	}

}

t.Mv_Atk_StdA <-
{
	/*
	function Init_After()
	{
		
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る

		if( enemy.push() )
		{
			BMvTbl.SetNextMoveTable( "Mv_Standby" );
			BMvTbl.SetFinalize(0);
			enemy.pop();
		}
		
		BMvTbl.SetFinalize(0);
		
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Standby" );
	}
	*/
}

t.Mv_Atk_StdB <-
{
	function FrameUpdate_After() : (check_Tuto_Sagi)
	{
		check_Tuto_Sagi( { frameID=100, chr=Def_ChrNo_Hyd, mvname="Mv_Bound" } ); // 一致でフラグ1がたつ	
	}
}

t.Mv_Atk_StdC <-
{
	function FrameUpdate_After()
	{
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=101, endid=150 }); //ボタンホールドしてなかったらIDジャンプ		
	}
}

t.Mv_Atk_CroA <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs|Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵と小足無敵にスカる
	}
}

t.Mv_Atk_CroB <-
{
}

t.AttackImpact <- function( info )
{
	Battle_Std.AttackImpact_StdFunc(info);
	/*
	if(info.counterhit)
	{
		//Battle_Std.AttackImpact_StdFunc(info);
		BMvEff.Slowmotion_Set( { time=10, power=6666 } );
		
		//BMvEff.SetStopTime( { time=10, stopme=1 } );
		
		local pos = BMvEff.GetAttackHitPos();
		
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local g_pos = (pos.x - center_pos.x)/8;

		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.050, x=center_pos.x+g_pos, y=pos.y+( (200*128)*1.5 ), time=[5,10,10], type_in=3, type_out=2 } );
		
		BMvTbl.SetCommandLongDelay(1);
	}
	*/

}

t.Mv_Atk_CroC <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
	}
	function HitInterrupt_After()
	{
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 2 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local emv = BMvTbl.GetMvName();
					enemy.pop();
					
					if( emv == "Mv_Dash_B" )
					{
						_dp("\n バクステにさした");
						BMvTbl.SetTutoMvFlag( 4 ); // 2+Cをバクステの硬直にあてた
					}
				}
			}
		}
	}
}

t.Mv_Atk_AirA <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		local hitnum = BMvTbl.CalcHitValue(0);  // ヒット数出現の残り取得
		if( hitnum>0 && hitnum != 2 ) // 初段以外
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}


t.Mv_Atk_AirB <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_AirC <-
{
	function FrameUpdate_After() : (check_Tuto_Sagi)
	{
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=101, endid=150 }); //ボタンホールドしてなかったらIDジャンプ
		
		check_Tuto_Sagi( { frameID=200, chr=Def_ChrNo_Hyd, mvname="Mv_Skill_41236EX" } ); // 一致でフラグ1がたつ
	}
}

t.Mv_Atk_DashStdC <- 
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50: //ここから収束
			local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
			Battle_Std.InitVector(); // ベクトル初期化
			BMvTbl.SetVector( { x=nowvec.x, addx=(-nowvec.x/20), flags=_Vector_Div } ); //20Fで収束ベクトルを登録			
			break;
		case 100:  //分岐
			if( BMvTbl.CheckFurimuki() )
			{
				if (BMvTbl.JumpFrameID(256) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
				BMvTbl.SetMuki(_Direction_Reverse);
			}
			break;
		}
		
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckHitTiming() )
		{
			if( BMvTbl.CheckFurimuki() )
			{
				if (BMvTbl.JumpFrameID(512) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
				BMvTbl.SetMuki(_Direction_Reverse);
			}		
		}
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 100, 200 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_Atk_Air6C <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_Air2C <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=101, endid=150 });
		
		local hitnum = BMvTbl.CalcHitValue(0);  // ヒット数出現の残り取得
		if( hitnum>0 && hitnum != 2 ) // 初段以外
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}

t.Mv_Atk_Std6B <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_Cro3B <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
	}
	function HitInterrupt_After()
	{
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 2 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local mvname = BMvTbl.GetMvName();
					local mvs = BMvTbl.GetMvStatus();
					
					// _dp("\n mvname:"+mvname+" cnt:"+mvs.MvCount );
					
					enemy.pop();
					
					if( mvname == "Mv_Skill_214_AddC" && mvs.MvCount >= 47 )
					{
						//214Cの追加のMvかどうか見る
						BMvTbl.SetTutoMvFlag( 3 ); // 3+Bを相手の技の空振りに差し込んだ
					}
				}
			}
		}
	}
}

t.Mv_Atk_Cro3C <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 8, _HitCheckFlag_Head ); // Param1 & 8 の時、_HitCheckFlag_Head 頭無敵
	}
}


//-----------------------------------------------------------------------------
// 214攻撃
//-----------------------------------------------------------------------------

// 181022 足元無敵追加
t.Mv_Skill_214A <- 
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
}
t.Mv_Skill_214B <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
}

t.Mv_Skill_214_JAdd1 <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
	}
}

t.Mv_Skill_214_JAdd2 <-
{
	function FrameUpdate_After()
	{
	}
}


t.Mv_Skill_214EX <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_SetMutekiDamage );
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_214EX_JHit"]); //デフォ,[code,mv]...
	}
}


t.Mv_Skill_214EX_JHit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_SetMutekiDamage );
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
		}
	}
}


//-----------------------------------------------------------------------------
// 236攻撃
//-----------------------------------------------------------------------------

local maketmpl_SkillFireBall = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
		enable_add = 0,
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236A",
		pat = "236Tama", vec = { x = 2300 }, ball=6, }
		break;
	case "B":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "236Tama", vec = { x = 4000 }, ball=6, }
		break;
	case "C":
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "236Tama", vec = { x = 5000 }, ball=6, }
		break;
	case "EX":
		mvparam.ball_st = { x=125, y=-184, pat="236TamaEX", mv="Mv_FireBall_236EX", vec={ x=4000 }, ball=6 };
		break;
	}

	ret_tmpl.Init_After <- function() : (mvparam)
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 0 ); //爆破フラグリセット
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		if( mvparam.enable_add )
		{
			Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			Battle_Std.CreateFireBall( mvparam.ball_st );
			break;
		}
	}	
	
	return ret_tmpl;
}

t.Mv_Skill_236A <- maketmpl_SkillFireBall( { type="A" } );
t.Mv_Skill_236B <- maketmpl_SkillFireBall( { type="B" } );
t.Mv_Skill_236EX <- maketmpl_SkillFireBall( { type="EX" } );

t.Mv_Skill_236_236A <- //爆破モーション
{
	function Init_After()
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 1 ); //爆破フラグセット	
		
		// 爆破も親から呼ぶようにする
		// モーションが出たら絶対に爆破が出る
		local eff = BMvEff.CreateObject( { mvname="Mv_SousaiObj_236Bakuha", start_pat="236TamaBakuha" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
			BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
			eff.pop();
		}
	}	
}

t.Mv_Skill_236_236B <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local muki = BMvTbl.GetMuki();
			local error_margin = (5*128);
			
			local pos = BMvTbl.GetPosition().x*muki;
			local epos = Battle_Std.GetEnemyPosition().x*muki;
			
			//Battle_Std.DrawDebugAttackInfo("pos  "+pos/128+" error margin "+error_margin/128+" epos "+epos/128+" muki "+muki);
			
			if( (pos + error_margin) > epos)
			{
				//Battle_Std.DrawDebugAttackInfo("cross ");
				
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					local move_pow = (-25*128);
					
					BMvTbl.SetPosition( { x=Battle_Std.GetEnemyPosition().x } );
					
					BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add | _Position_ChangeMuki } );
				}
			}
		}
	}
}; //追撃モーション

t.Mv_Skill_236_236EX <-
{
	function Init_After()
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 1 ); //爆破フラグセット	
		
		// 爆破も親から呼ぶようにする
		local eff = BMvEff.CreateObject( { start_pat="236TamaBakuhaEXPre" } );
		if( eff.push() )
		{
			BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
			eff.pop();
		}
	}	
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local eff = Battle_Std.CreateFireBall( { mv="Mv_FireBall_236BakuhaEX", pat="236TamaBakuhaEX" } );
			if( eff.push() )
			{
				BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
				eff.pop();
			}
			break;
		}
	}
}; //追撃モーション

t.Mv_Obj_236_BakuhaPos <-
{
	function FrameUpdate_After()
	{
		local pos = BMvTbl.GetPosition();
		BMvTbl.SetPP( def_PP_Hyd_236BakuhaPosX, pos.x );
		BMvTbl.SetPP( def_PP_Hyd_236BakuhaPosY, pos.y );
		
		//操作親のMvを見て変化
		if( BMvTbl.GetPP( def_PP_Hyd_236Bakuha ) == 1 )
		{
			BMvTbl.SetFinalize(0);
			BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 2 );//処理済み（0にすると弾がヒットストップ中で消えないことあり）
		}
		
		//操作親の飛び道具スロットが初期化されていた＝次の弾がうてるなら消える
		// 親が動けない間に消えると、
		// ヒットストップ中にコマンド成功→スロット初期化されてる→ヒットストップ終了→やっぱ出ない、があるので
		// PPに座標を入れるだけにして、爆破呼び出しは操作親からに変更
		local ball = BMvTbl.TobiParam_Func( { slot=6, type=_ValGet } );
		switch( ball )
		{
		case 0: //たまがうてるから消える
			//爆破の時も０になるよ
			BMvTbl.SetFinalize(0);
			break;
		case 1: //追加まち
			break;
		}
		
	}
}

local timestopmove_236236ex = function()
{
	local p = BMvCore.GetPlayerCharaData();
	if(p.push())
	{
		local mvname = BMvTbl.GetMvName();
		p.pop();
		
		//Battle_Std.DrawDebugAttackInfo("d "+mvname);
		
		if(mvname == "Mv_Skill_236_236EX")
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );	
			//BMvTbl.SetFinalize(0);
		}		
	}
}

t.Mv_Obj_340Dust <-
{
	function FrameUpdate_After() : (timestopmove_236236ex)
	{
		timestopmove_236236ex();
	}
}

t.Mv_FireBall_236A <-
{
	function Init_After()
	{
		//弾にくっついていく爆破予告
		local eff = BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_236_BakuhaPos", flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_NoGround } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { y=0 } );
			
			eff.pop();
		}
	}
	function Update_After() : (timestopmove_236236ex)
	{
		timestopmove_236236ex();
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if ( mvs.MvCount%1 == 0 && mvs.CallCount == 0 )
		{
			local pos = BMvEff.Random_PointRad( { radx=30, rady=30 } );
			Battle_Std.CreateObjectEX( { x=pos.x, y=pos.y, pat="340Dust", FrameID=[1,2,3], flags=_Position_ToolShift, mvname="Mv_Obj_340Dust" } );
		}
		//操作親のPPを見て変化
		if( BMvTbl.GetPP( def_PP_Hyd_236Bakuha ) > 0 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 3 )// ミッション中
		{
			local posst = Battle_Std.GetPointStatus_NearEnemy();
			local distance = posst.pos_x*BMvTbl.GetMuki();
			
			if( distance < 0 && distance >= -10000 ) // 距離10000以内で後ろにいる
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					if( BMvTbl.GetHitCheckFlag(0)&_HitCheckFlag_FireBall )
					{
						// print("\n 飛び道具抜けた")
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_TutoBallMuteki ); // 飛び道具無敵で通り抜けた
					}
					enemy.pop();
				}
			}
		}
	}
}

t.Mv_FireBall_236A_Hit <- //飛び道具ヒット部分
{
	function Init_After() : (timestopmove_236236ex) // 初回処理
	{
		BMvTbl.SetPattern("236TamaHit");
	}
	function FrameUpdate_After() : (timestopmove_236236ex)
	{
		timestopmove_236236ex();
	}
	function LastUpdate_After()
	{
		//BMvTbl.TobiParam_Func( { slot=6, type=_ValSet, val=-1 } ); //precaution
	}
}

t.Mv_FireBall_236A_Sousai <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.SetPattern("236TamaHit");
		
		BMvTbl.TobiParam_Func( { slot=6, type=_ValSet, val=1 } ); //ball is still in use
	}
	function FrameUpdate_After() : (timestopmove_236236ex)
	{
		timestopmove_236236ex();
		
		local mvs = BMvTbl.GetMvStatus();

		if( mvs.MvCount > 2 && mvs.CallCount==0 ) 
		{
			BMvTbl.TobiParam_Func( { slot=6, type=_ValSet, val=-1 } ); //clear ball usage
		}
		else if(mvs.MvCount < 2)
		{
			BMvTbl.TobiParam_Func( { slot=6, type=_ValSet, val=1 } );
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=6, type=_ValSet, val=-1 } ); //precaution
	}
}

t.Mv_FireBall_236A_Blocked <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.SetPattern("236TamaHit");
	}
	function FrameUpdate_After() : (timestopmove_236236ex)
	{
		timestopmove_236236ex();
	}
	function LastUpdate_After()
	{
	}
}

t.Mv_FireBall_236B <- t.Mv_FireBall_236A;
t.Mv_FireBall_236B_Hit <- t.Mv_FireBall_236A_Hit;
t.Mv_FireBall_236B_Sousai <- t.Mv_FireBall_236A_Sousai;
t.Mv_FireBall_236B_Blocked <- t.Mv_FireBall_236A_Blocked;

t.Mv_SousaiObj_236Bakuha <-
{
	function Init()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺が発生する
		
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_FireBall, time=255, flag=_ClearFlag_ChangeMv } ); // 弾無敵にスカる
		
		// 相手がやられで、ある程度近くにいたら出現位置ずらす
		// 見た目の都合で前方のみのサーチ
		if( Battle_Std.CheckEnemyisDamage() )
		{
			BtlOb.SetPos_MoveForwardFartherX_Enemy( { farther_x=50*128, addlimit_x=50*128, } );//これより遠いと近づく, 加算限界X
		}
	}
	function FrameUpdate()
	{
		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_FireBall_236BakuhaEX <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
}

t.Mv_FireBall_236BakuhaEX_Sousai <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID(900);
	}
}

t.Mv_FireBall_236BakuhaEX_Blocked <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID(900);
	}
}



t.Mv_FireBall_236EX <-
{
	function Init_After()
	{
		BMvTbl.TobiParam_Func( { slot=7, val=1, type=_ValAdd } ); //EXのときは７も
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if ( mvs.MvCount%1 == 0 && mvs.CallCount == 0 )
		{
			local pos = BMvEff.Random_PointRad( { radx=30, rady=30 } );
			Battle_Std.CreateObjectEX( { x=pos.x, y=pos.y, pat="340EXDust", FrameID=[1,2,3], flags=_Position_ToolShift } );
		}
	}	
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetVector( { x=3000, flags=_Vector_Normal } );
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=7, type=_ValClear  } ); //EXのときは７も		
	}
}

t.Mv_FireBall_236EX_Sousai <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID( 512 );
	}
};


//-----------------------------------------------------------------------------
// 0202攻撃
//-----------------------------------------------------------------------------

t.Mv_Obj_0202CreatorA <-
{
	function Init_After()
	{
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop } );
		local eff = BMvEff.CreateObject( { datatype=1, start_pat=414, flags=_Position_ToolShift } );
		if(eff.push())
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlag_EraseParentDelete } );
			eff.pop();
		}
		
		BMvTbl.SetLP(2,0);
	}
	function FrameUpdate_After()
	{	
		if( Battle_Std.CheckPlayerisDamage() && BMvTbl.GetLP(2)==0 ) BMvTbl.SetFinalize();
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				//if( BMvTbl.GetLP(0) != 1 ) BMvEff.CreateObject( { datatype=1, start_pat=414, flags=_Position_ToolShift } );
				
				local eff = BMvEff.CreateObject( { x=0, y=0, start_pat="0202Tama", mvname="Mv_FireBall_0202A" } );		
				if( eff.push() )
				{
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定		
					
					eff.pop();
				}
				
				BMvTbl.SetLP(2,1);
			break;
		}
	}
}

t.Mv_Obj_0202CreatorB <-
{
	function Init_After()
	{
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop } );
		BMvEff.CreateObject( { datatype=1, start_pat=414, flags=_Position_ToolShift } );
	}
	function FrameUpdate_After()
	{	
		if( Battle_Std.CheckPlayerisDamage() ) BMvTbl.SetFinalize();
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				local eff = BMvEff.CreateObject( { x=0, y=0, start_pat="0202Tama", mvname="Mv_FireBall_0202B" } );		
				if( eff.push() )
				{
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定		
					
					eff.pop();
				}
			break;
		}
	}
}

t.Mv_FireBall_0202A <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern } );
	}
	function FrameUpdate_After() : (check_Tuto_Sagi)
	{
		check_Tuto_Sagi( { frameID=100, chr=Def_ChrNo_Hyd, mvname="Mv_Skill_623B" } ); // 一致でフラグ1がたつ
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 30, 60 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202A_Hit <- {};
t.Mv_FireBall_0202A_Sousai <- {};

t.Mv_FireBall_0202B <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern } );
	}
	function FrameUpdate_After() : (check_Tuto_Sagi)
	{
		check_Tuto_Sagi( { frameID=100, chr=Def_ChrNo_Hyd, mvname="Mv_Skill_623B" } ); // 一致でフラグ1がたつ
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 50, 100 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202B_Hit <- t.Mv_FireBall_0202A_Hit
t.Mv_FireBall_0202B_Sousai <- t.Mv_FireBall_0202A_Sousai;

local maketmpl_SkillThrustGroundWave = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_xpos = 450,
		ball_mv = "Mv_FireBall_0202A",
		creator_ball_mv = "Mv_Obj_0202CreatorA",
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.ball_xpos = 450;
		mvparam.ball_mv = "Mv_FireBall_0202A";
		break;
	case "B":
		mvparam.ball_xpos = 700;
		mvparam.ball_mv = "Mv_FireBall_0202B";
		mvparam.creator_ball_mv = "Mv_Obj_0202CreatorB";
		break;
	case "C":
		mvparam.ball_xpos = 850;
		mvparam.ball_mv = "Mv_FireBall_0202B";
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		BMvTbl.SetLP(0,0); // 初段がヒットしたかどうか
		BMvTbl.SetLP(1,0);
	}
	
	ret_tmpl.Update_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				local is_hit = BMvTbl.GetLP(0);
				
				local create_posx = mvparam.ball_xpos*128;
			
				local pos = BMvTbl.GetPosition(0);
				local muki = BMvTbl.GetMuki();
				local set_posx = pos.x + ( create_posx*muki );
				
				if( muki == 1 )
				{
					if( set_posx >= def_POS_GamenHajiX )
					{
						create_posx -=(set_posx-def_POS_GamenHajiX)
					}
				}
				else
				{
					if( set_posx <= -def_POS_GamenHajiX )
					{
						create_posx +=(def_POS_GamenHajiX+set_posx)
					}
				}
				if( BMvTbl.GetLP(0)==1 )
				{
					local edis = Battle_Std.GetEnemyDistance();
					if( create_posx > edis )
					{
						//生成予定先座標
						create_posx -= (create_posx-edis)*50/100;//少し吸い寄せ
					}
				}
			
				if( is_hit == 0 && BMvTbl.GetLP(1)==0 )
				{
					local eff = BMvEff.CreateObject( { x=create_posx, y=0, start_pat="0202Creator", mvname=mvparam.creator_ball_mv } );		
					if( eff.push() )
					{
						BMvTbl.SetLP(0,is_hit);
						//BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
						//Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定		
						
						eff.pop();
					}
					
					BMvTbl.SetLP(1,1);
				}
			
			break;
		}
	}
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// 軸移動
			Battle_Std.AddToolShift_NoSurinuke( 100, (1<<1) );
			break;

		case 110:
			local create_posx = mvparam.ball_xpos*128;
			
			local pos = BMvTbl.GetPosition(0);
			local muki = BMvTbl.GetMuki();
			local set_posx = pos.x + ( create_posx*muki );
			
			if( muki == 1 )
			{
				if( set_posx >= def_POS_GamenHajiX )
				{
					create_posx -=(set_posx-def_POS_GamenHajiX)
				}
			}
			else
			{
				if( set_posx <= -def_POS_GamenHajiX )
				{
					create_posx +=(def_POS_GamenHajiX+set_posx)
				}
			}
			if( BMvTbl.GetLP(0)==1 )
			{
				local edis = Battle_Std.GetEnemyDistance();
				if( create_posx > edis )
				{
					//生成予定先座標
					create_posx -= (create_posx-edis)*50/100;//少し吸い寄せ
				}
			}
			
			local is_hit = BMvTbl.GetLP(0);
			
			/*
			local is_hit = BMvTbl.GetLP(0);
			
			local eff = BMvEff.CreateObject( { x=create_posx, y=0, start_pat="0202Creator", mvname=mvparam.ball_mv } );		
			if( eff.push() )
			{
				BMvTbl.SetLP(0,is_hit);
				//BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
				//Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定		
				
				eff.pop();
				
				Battle_Std.DrawDebugAttackInfo("fu objc");
			}
			*/
			
			if( is_hit && BMvTbl.GetLP(1)==0 )
			{
				//生成後に座標を変更すると、判定ツールでよんでいるエフェクトの座標が追尾してくれないので
				//生成予定の座標を変更するように変更
				local eff = BMvEff.CreateObject( { x=create_posx, y=0, start_pat="0202Tama", mvname=mvparam.ball_mv } );		
				if( eff.push() )
				{
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定	

					BMvEff.CreateObject( { datatype=1, start_pat=414, flags=_Position_ToolShift } );				
					
					eff.pop();
				}
			}
			
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetLP(0,1); // 初段がヒット
		}
	}
	
	return ret_tmpl;
}

t.Mv_Skill_0202A <- maketmpl_SkillThrustGroundWave( { type="A" } );
t.Mv_Skill_0202B <- maketmpl_SkillThrustGroundWave( { type="B" } );

t.Mv_Skill_0202EX <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			Battle_Std.AddToolShift_NoSurinuke( 100, (1<<1) );
			break;
		case 100:
			BMvEff.CreateObject( { x=150, y=0, mvname="Mv_Obj_0202EXMover", flags=_Position_ToolShift } );
			break;
		}
	}
}

t.Mv_Obj_0202EXMover <-
{
	function Init_After()
	{
		BMvTbl.SetLP(1,0); // 子がヒットしたかどうかの受け皿
	}
	function FrameUpdate_After()
	{
		// _dp("\n BMvTbl.GetLP(1):"+BMvTbl.GetLP(1) );
		local pat = 0;
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10: //小
			pat = "0202EXTama1";
			break;
		case 20: //中
			pat = "0202EXTama2";
			break;
		case 30: //大
			pat = "0202EXTama3";
			break;
		}
		if( pat!=0 )
		{
			local eff = BMvEff.CreateObject( { x=0, y=0, start_pat=pat, mvname="Mv_FireBall_0202EX" } );
		}
		
		if( Battle_Std.CheckFrontStageDistance( -150 ) )
		{
			local vec = BMvTbl.GetVector( 0 );
			BMvTbl.SetMuki( _Direction_Reverse );
			BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal } );
		}		
	}
}

t.Mv_FireBall_0202EX <-
{
	function Init_After()
	{
		local hosei_kaketa = 0;
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			hosei_kaketa = BMvTbl.GetLP(1);
			
			oya.pop();
		}
		
		if( hosei_kaketa )
		{
			// 各種補正は最初の１ヒットのみ、をすでにかけた
			BMvTbl.SetNoHoseiFlag( {  val=0x80, time=254, flag=_ClearFlag_ChangePattern } );		
		}
		else
		{
			// 各種補正は最初の１ヒットのみ
			BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern } );
		}
		
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } ); // ヒット時親LPに値を入れるので親の引継ぎなし
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 10, 20 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202EX_Hit <-
{
	function Init_After()
	{
		local oya = BMvCore.GetParentCharaData();
		if( oya.push() )
		{
			// _dp("\n 親にヒットしたのを伝える")
			BMvTbl.AddLP(1,1); // ヒットしたよ
			oya.pop();
		}
	}
}
t.Mv_FireBall_0202EX_Sousai <- {};



//-----------------------------------------------------------------------------
// J236攻撃
//-----------------------------------------------------------------------------

local maketmpl_SkillAirFireBall = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236A", pat = "J236Tama", };
		break;
	case "B":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236B", pat = "J236Tama", };
		break;
	case "C":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236B", pat = "J236Tama", };
		break;
	case "EX":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236EX", pat = "J236EXTama", };
		break;
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			Battle_Std.CreateFireBall( mvparam.ball_st );
			break;
		}
	}	
	
	return ret_tmpl;
}

t.Mv_Skill_J236A <- maketmpl_SkillAirFireBall( { type="A" } );
t.Mv_Skill_J236B <- maketmpl_SkillAirFireBall( { type="B" } );
t.Mv_Skill_J236EX <- maketmpl_SkillAirFireBall( { type="EX" } );

t.Mv_FireBall_J236A <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
}


t.Mv_FireBall_J236A_Sousai <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.JumpFrameID( 256 )
	}
}

t.Mv_FireBall_J236B <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236B_Sousai <- t.Mv_FireBall_J236A_Sousai;
t.Mv_FireBall_J236EX <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX_Sousai <- t.Mv_FireBall_J236A_Sousai;

//-----------------------------------------------------------------------------
// 623攻撃
//-----------------------------------------------------------------------------

t.Mv_Skill_623A <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [64]=Def_HitCheckFlag_AirDive } );
	}
};

t.Mv_Skill_623B <-
{
	function Init_After()
	{
		// 181108 カス当たりしづらいように吸い込み追加
		BMvTbl.SetLP(0,0);
	}
	function HitInterrupt_After()
	{
		// １回目のヒットだけ引き寄せる処理
		if( BMvTbl.GetLP(0)==0 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, distance=500*128, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
		Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
	}
};

t.Mv_Skill_623EX <- {
	function Init_After()
	{
		// 181108 カス当たりしづらいように吸い込み追加
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{	
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 2 ) // チュートリアル中
		{
			if ( BMvEff.Liberate_Get()!=_SpGaugeMode_Normal ) // VO中かどうか
			{
				BMvTbl.SetTutoMvFlag( 7 ); // VO中に623EXを使った
			}
		}
	}
	function HitInterrupt_After()
	{
		// １回目のヒットだけ引き寄せる処理
		if( BMvTbl.GetLP(0)==0 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, distance=500*128, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ
				
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
	}
};

t.Mv_Skill_623_JAddA <-
{
	function Init_After()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		local kyori = Battle_Std.GetEnemyDistance()/128;
		

		if( kyori >= 0 )
		{
			//kyori <= 200 && 
			
			local vec = BMvTbl.GetVector();
			vec.x = kyori*2;
			
			//vec.addy = -kyori/64;
			vec.addx = kyori;
			vec.y -= kyori;
			
			//vec.y = vec.y + (-kyori)
			//vec.addy = vec.addy + (kyori/8)
			
			
			BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=vec.y, addy=vec.addy, flags=_Vector_Normal } );
			//BMvTbl.SetVector_MaxX( 1500 );
		}
		
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 150:
			local kyori = Battle_Std.GetEnemyDistance()/128;

			if( kyori >= 0 )
			{
				//kyori <= 200 && 
				
				local vec = BMvTbl.GetVector();
				vec.x = kyori*8;
				vec.addx = -kyori/6;
				
				vec.addy = 230;
				
				vec.y = vec.y + (-kyori)
				vec.addy = vec.addy + (kyori/4)
				
				
				BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=vec.y, addy=vec.addy, flags=_Vector_Normal } );
				BMvTbl.SetVector_MaxX( 2000 );
			}
			break;
		}
	}
}

//-----------------------------------------------------------------------------
// 41236EX攻撃
//-----------------------------------------------------------------------------

t.Mv_Skill_41236EX <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);//初段引き寄せ
		
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 2 ) // チュートリアルの時だけ処理する
		{
			//相手が236EXを出していて、MvCountがいくつ居ないなら暗転返し、という作りにする
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local e_mvname = BMvTbl.GetMvName();
				local e_mvs = BMvTbl.GetMvStatus();
				
				enemy.pop();
				
				//_dp("\n e:"+e_mvname+" s:"+e_mvs.MvCount );
				
				if( e_mvname == "Mv_Skill_236EX" && e_mvs.MvCount < 25 )
				{
					BMvTbl.SetTutoMvFlag( 13 ); // 236EXに対して暗転返しをしたっぽい
				}
			}
		}
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 30:
			BMvEff.CreateObject({ x=153*128, start_pat="41236EX_Tama", mvname="Mv_Obj_41236EX_Tama",});
			break;
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local mvs = BMvTbl.GetMvStatus();
			local frame_id = mvs.FrameID;
			
			if( frame_id == 20 || frame_id == 30 )
			{
				BMvTbl.SetFinalize( 256 );
				
				//相手との距離が近かったらベクトル収束させる
				local kyori = Battle_Std.GetEnemyDistance()/128;
				// _dp("\n kyori:"+kyori );
				if( kyori <= 200 && kyori >= 0 )
				{
					// 120〜320 : 普通にヒット　かなり遅くする
					// 320〜    : 牽制とかにヒット　500ぐらいまではあるな
					
					// 200以内収束させる感じで
					local conv_par = (kyori / 2) * 85 / 100;
					if( conv_par < 30 ) conv_par = 10;
					if( conv_par > 100 ) conv_par = 100;

					local vec = BMvTbl.GetVector();

					// _dp("\n conv_par:"+conv_par+" x:"+vec.x );
					vec.x = vec.x * conv_par / 100;
					// _dp(" -> "+vec.x );
					
					BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Normal } );
					
				}
			}

			// １回目のヒットだけ引き寄せる処理
			if( BMvTbl.GetLP(0)==0 )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ

				BMvTbl.SetLP(0,1);
			}
		}
	}
	function Finalize_After()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_41236EX_Hit"]); //デフォ,[code,mv]...				
	}
}

t.Mv_Skill_41236EX_Hit <-
{
	flags = def_TmplFlags_ChangeStatusOnly //状態の移行のみ行う
	function Init_After()
	{
		Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_CSAntenGaesiSkill ); // 前のMVからフラグの引き継ぐ
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 30:
			BMvEff.CreateObject({ x=153*128, start_pat="41236EX_Tama", mvname="Mv_Obj_41236EX_Tama",});
			break;
		case 50:
			BMvTbl.JumpFrameID(200);
			break;
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
	}	
}

t.Mv_Obj_41236EX_Tama <-
{
	function Init_After()
	{
		BMvTbl.SetPosition({ y=0 }); // 地面から
	}
}
//-----------------------------------------------------------------------------
// 41236SP攻撃
//-----------------------------------------------------------------------------


t.Mv_Obj_41236EX_GarekiS <- 
{
	function Init_After() // 初回処理
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround  } );		

		BMvTbl.SetAngle( { angle_float=BMvEff.Random_F() } ); //てきとう
		local vx = (BMvEff.Random_Limit(2000)-1000)*3;
		local ry = BMvEff.Random_Limit(2000);
		local vy = -6500-ry;
		local frame = 40+BMvEff.Random_Limit(30);
		BMvTbl.SetVector( { x=vx, y=vy, addx=0, addy=-vy/frame, flags=_Vector_Div } );
	}
}

t.Mv_Skill_41236SP <- //インス技
{
	function Init_After() // 初回処理
	{
	}
	function FrameUpdate_After() // フレーム更新処理
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		switch( s.FrameID )
		{
		case 5: //つきさすところ
			if( s.isFrameUpdate )
			{
				BSound.SE_Play( { type=_SeType_Player, num=3 } ); //IFW
				local eff = BMvEff.CreateObject( { x=24, y=6, mvname="Mv_Obj_IW_AtkRect", flags=_Position_ToolShift } ); //判定とか
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround } );
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } );
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定
					
					eff.pop();
				}
			}
			break;
		case 10: //ループ中
			if( s.CallCount==0 )
			{
				if ( s.MvCount<90 && s.MvCount%1 == 1 ) //だいたい1Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-500, sy=-100, ex=500, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
				else if ( s.MvCount<100 && s.MvCount%2 == 1 ) //だいたい2Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-400, sy=-100, ex=400, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
				else if ( s.MvCount<110 && s.MvCount%3 == 1 ) //だいたい3Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-300, sy=-100, ex=300, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
			}
			break;
		case 50: //終了
			if( s.isFrameUpdate ) Battle_Std.FinalizeWorthSkill(); //終了
			break;
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming_FrameID( 5 ) )//剣さすところがヒット
		{
			BMvEff.SetCamera_Quake( { time=30, type=0, clear=0, } ); //揺らし
			BMvEff.Slowmotion_Set( { time=30, power=5000 } ); //スロー
		}
	}
	function LastUpdate() // 移行後の切り替え時に呼ばれる
	{
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
	}
	

}
//	

t.Mv_Obj_IW_AtkRect <-
{
	function Init_After()
	{
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
	}
}

//-----------------------------------------------------------------------------
// 63214SP
//-----------------------------------------------------------------------------


t.Mv_Obj_AIW_AtkLase <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
	}
}

t.Mv_Skill_63214SP_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function StepPhase( setphase=-1 )
	{
		if( setphase== -1)
		{
			BMvTbl.AddLP(0, 1);
			BMvTbl.SetLP(1, 0);		
		}
		else
		{
			BMvTbl.SetLP(0, setphase);
			BMvTbl.SetLP(1, 0);			
		}
	}
	
	function Init_After()
	{
		BMvTbl.SetVector( { x=-2560, addx=400 } );
		BMvTbl.SetVector_MaxX( 1 );
		
		BMvEff.SetCamera_Clipping( 0 );
		
		BMvEff.ThrowChara_SetCamera( 1 );
		
		local exp_obj = BMvEff.CreateObject( { start_pat="391ef_a100", y=-250, flags=_Position_ToolShift } );
		if(exp_obj.push())
		{
			BMvTbl.SetPosition( { x=Battle_Std.GetEnemyPosition().x } );
			exp_obj.pop();
		}
		
		
		//Battle_Std.IWEXIST_CallOnePunch(); // 相手をMvBoundにする
	
		//BSound.SE_Play( { type=_SeType_Player, num=610 } );
		
		//Battle_Std.InitIWExistSkill();
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動

		//BMvEff.ThrowParam( { pattern=304, x=600, y=0, } ); //敵の座標を設定

		local p = BMvCore.GetCaptureCharaData();
		local posst = BMvEff.GetPointStatus( { target=p } );
		if( p.push() )
		{
			Battle_Std.InitVector(); //とりあえず…
			BMvTbl.SetPattern(320);
			//BMvTbl.SetPosition( { y=200, flags=_Position_ToolShift } );
			
			local x_min = 400;
			if( posst.distance_x/128 < x_min ) BMvTbl.SetPosition( { x=( (posst.distance_x/128) - x_min ), flags=_Position_ToolShift|_Position_ChangeMuki|_Position_Add } );
			
			p.pop();	
		}
		
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない	
		
		//多分ここまではワンセットなのでは
		BMvTbl.SetPP(def_PP_Temp,0); //状態管理に使おう
		
		BMvTbl.SetLP(0,0); //フェイズ番号
		BMvTbl.SetLP(1,0); //フェイズカウンタ
		BMvTbl.SetLP(8,0); //音声タイミング
		
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local g_pos = (pos.x - center_pos.x)/8;

		//BMvEff.SetCamera_Focus( { charapos=0, zoom=1, x=center_pos.x, y=center_pos.y, time=[5,100,10], type_in=3, type_out=2 } );
		BMvEff.CameraShift_Set( { x=pos.distance_x*80/100, flags=_Position_ChangeMuki } );
	}
	function FrameUpdate_After()
	{
		local StepPhase = function(bros)
		{
			
		}
		
		//音声は別扱い
		//BMvTbl.SetLP(8,0); //音声タイミング
		local sound_time = BMvTbl.GetLP(8);
		BMvTbl.AddLP(8,1);
		if( sound_time==0 )
		{
			//BSound.SE_Play( { type=_SeType_Player, num=610 } );
		}
		else if( sound_time==120-60+15 )
		{
			BSound.SE_Play( { type=_SeType_Player, num=651 } );	
			BMvEff.ThrowChara_SetCamera( 0 );			
		}		
	
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0); //状態
		local phasecnt = BMvTbl.GetLP(1); //カウンタ取得
		BMvTbl.AddLP(1,1); //1F進める	
			
		switch( Battle_Std.GetUpdateFrameID( s ) )
		{
		case 50: //かまえループ開始
			Battle_Std.DrawBladeEffect( { x=-24, y=-236, pat="391ef_a", } );
			break;
		case 100: //きりはじめ
			//ハイド付近にカメラを固定
			//BSound.SE_Play( { type=_SeType_Player, num=624 } ); //ため
			
			StepPhase(100); //切った後にする 
			break;
		case 120: //剣をチャージ開始
			BMvEff.SetCamera_Quake( { time=120, type=2, clear=0, } ); //揺らし
			break;
		case 150: //きった
			BMvEff.SetCamera_Quake( { time=180, type=2, clear=0, } ); //揺らし
			
			//BSound.SE_Play( { type=_SeType_Player, num=624 } ); //ため
			Battle_Std.CreateObjectEX( { x=80, y=0, pat="391ef_b", mvname="Mv_IWEXIST_Eff_391ef_b", flags=_Position_ToolShift,
				objectflags=_ObjFlags_EraseParentPatChange, //パターン変更で
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );
			
			Battle_Std.CreateObjectEX( { x=80, y=0, mvname="Mv_Call_LightEff", flags=_Position_ToolShift,
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );

			StepPhase(150); //すすめる
			
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p );
					BMvTbl.SetVector( { x=-256, y=-64 } );
				BMvCore.PopCharaData();		
			}
			
			BMvEff.ThrowParam( { pattern=320, x=750, y=-150, } );
			
			BMvEff.ThrowChara_SetCamera( 1 );	

			
			break;
		case 250: //とどめ判定
			//Battle_Std.IWExistSkill_FinishEffect(); //KOと同じような揺れやスローを呼ぶ

			BSound.SE_Play( { type=_SeType_Player, num=626 } ); //ﾊｧﾊｧ
		
			StepPhase(250); //すすめる
			BMvEff.FadeProc_Set({type=0, time=[30,300,0] color=0x8D0017});
			
			BMvTbl.SetLP(0, 250);
			BMvTbl.SetLP(1, 0);
			
			break;
		case 300: //ホアイトアウト
			break;
		}
		
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}	
	function LastUpdate_After()
	{
		BMvEff.SetCamera_Clipping( 1 );
		
		BMvEff.FadeProc_SetRenderFlag(1); // 0:カットインBG描画なし
		
		BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
		BMvEff.FadeProc_Set({type=0, time=[0,1,30] color=0x8D0017})
	
		//つかみ開放
		//BMvEff.SetCamera_Focus( { zoom=1.0, time=[0,0,30] } ); //カメラ固定
		//BMvEff.ThrowParam( { x=100, y=-1224, } );
		BMvEff.ThrowRelease( { type="腹吹き飛び壁貼り付き", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		Battle_Std.FinalizeIWExistSkill();
	}	
}


t.Mv_Skill_63214SP <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				BMvEff.CreateObject( { mvname="Mv_Obj_AIW_AtkLase", x=-24, y=-236, flags=_Position_ToolShift } );
				
				break;
		}
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		local code = BMvTbl.GetFinalizeCode();
		if( code!=256 )
		{
			BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		}
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_63214SP_Hit"]); //デフォ,[code,mv]...
	}	
	function LastUpdate() //カットイン消去を上書き
	{
		if( BMvTbl.FromFinalize()==0 )
		{
			BMvEff.CutInProc_Erase(); //カットインがあったら消去する		
		}
	}
}

//-----------------------------------------------------------------------------
// インフィニットワースＥＸＳ
//-----------------------------------------------------------------------------

t.Mv_Skill_IWEXIST <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]); //デフォ,[code,mv]...
	}	
}

t.Mv_Skill_IWEXIST_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function StepPhase( setphase=-1 )
	{
		if( setphase== -1)
		{
			BMvTbl.AddLP(0, 1);
			BMvTbl.SetLP(1, 0);		
		}
		else
		{
			BMvTbl.SetLP(0, setphase);
			BMvTbl.SetLP(1, 0);			
		}
	}
	
	function Init_After()
	{
		//Battle_Std.IWEXIST_CallOnePunch(); // 相手をMvBoundにする
	
		BSound.SE_Play( { type=_SeType_Player, num=610 } );
		
		Battle_Std.InitIWExistSkill();
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動

		BMvEff.ThrowParam( { pattern=304, x=600, y=0, } ); //敵の座標を設定

		local p = BMvCore.GetCaptureCharaData();
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //	
				//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
				Battle_Std.InitVector(); //とりあえず…
			BMvCore.PopCharaData(); //	
		}
		
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない
		
		Battle_Std.CreateObjectEX( { datatype=0, x=0, y=0, mvname="Mv_IWEXIST_Camera", flags=_Position_ToolShift,
		objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
		objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
		initfunc = function()
		{
			BMvEff.SetExist( { level = _Exist_NoHantei } );
		}
		} );		
		
		//多分ここまではワンセットなのでは
		BMvTbl.SetPP(def_PP_Temp,0); //状態管理に使おう
		
		BMvTbl.SetLP(0,0); //フェイズ番号
		BMvTbl.SetLP(1,0); //フェイズカウンタ
		BMvTbl.SetLP(8,0); //音声タイミング
	}
	function FrameUpdate_After()
	{
		//音声は別扱い
		//BMvTbl.SetLP(8,0); //音声タイミング
		local sound_time = BMvTbl.GetLP(8);
		BMvTbl.AddLP(8,1);
		if( sound_time==0 )
		{
			//BSound.SE_Play( { type=_SeType_Player, num=610 } );
		}
		else if( sound_time==0 )
		{
			BSound.SE_Play( { type=_SeType_Player, num=651 } );		
		}		
	
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0); //状態
		local phasecnt = BMvTbl.GetLP(1); //カウンタ取得
		BMvTbl.AddLP(1,1); //1F進める		
		
		switch( mode )
		{
		case 0: //初期待機
			if( phasecnt>40 ) StepPhase();
			break;
		case 1: //タマを飛ばす
			if( phasecnt==0 )
			{
				//たまを飛ばす
				BMvEff.ThrowParam( { pattern=320, x=600, y=0, } );
				Battle_Std.DrawBladeEffect( { x=600, y=-250, pat="391ef_a100", } );
				
				// local p = BMvCore.GetCaptureCharaData();
				// if( p.IsDone )
				// {
					// BMvCore.PushCharaData( p ); //	
						// BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } ); //消していたのを戻す
					// BMvCore.PopCharaData(); //					
				// }			
			}
			break;
		case 150: //きった後
			if( phasecnt>200 ) StepPhase();
			break;
		case 151: //きった後
			if( phasecnt>300 ) StepPhase();
			break;
		}
		
		switch( Battle_Std.GetUpdateFrameID( s ) )
		{
		case 50: //かまえループ開始
			Battle_Std.DrawBladeEffect( { x=-24, y=-236, pat="391ef_a", } );
			break;
		case 100: //きりはじめ
			//ハイド付近にカメラを固定
			//BSound.SE_Play( { type=_SeType_Player, num=624 } ); //ため
			
			StepPhase(100); //切った後にする 
			break;
		case 120: //剣をチャージ開始
			BMvEff.SetCamera_Quake( { time=120, type=2, clear=0, } ); //揺らし
			break;
		case 150: //きった
			BMvEff.SetCamera_Quake( { time=255, type=2, clear=0, } ); //揺らし
			
			//BSound.SE_Play( { type=_SeType_Player, num=624 } ); //ため
			Battle_Std.CreateObjectEX( { x=80, y=0, pat="391ef_b", mvname="Mv_IWEXIST_Eff_391ef_b", flags=_Position_ToolShift,
				objectflags=_ObjFlags_EraseParentPatChange, //パターン変更で
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );
			
			Battle_Std.CreateObjectEX( { x=80, y=0, mvname="Mv_Call_LightEff", flags=_Position_ToolShift,
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );

			StepPhase(150); //すすめる
			
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p );
					BMvTbl.SetVector( { x=-256, y=-64 } );
				BMvCore.PopCharaData();		
			}
			
			BMvEff.ThrowParam( { pattern=320, x=750, y=-150, } );

			
			break;
		case 250: //とどめ判定
			Battle_Std.IWExistSkill_FinishEffect(); //KOと同じような揺れやスローを呼ぶ

			BSound.SE_Play( { type=_SeType_Player, num=626 } ); //ﾊｧﾊｧ
		
			StepPhase(250); //すすめる
			BMvEff.FadeProc_Set({type=0, time=[30,300,0] color=0x8D0017})
			break;
		case 300: //ホアイトアウト
			break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}	
	function LastUpdate_After()
	{
		BMvEff.FadeProc_SetRenderFlag(1); // 0:カットインBG描画なし
		
		BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
		BMvEff.FadeProc_Set({type=0, time=[0,1,30] color=0x8D0017})
	
		//つかみ開放
		//BMvEff.SetCamera_Focus( { zoom=1.0, time=[0,0,30] } ); //カメラ固定
		BMvEff.ThrowParam( { x=100, y=-1224, } );
		BMvEff.ThrowRelease( { type="斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		Battle_Std.FinalizeIWExistSkill();
	}	
}

t.Mv_Skill_IWEXIST_End <- {};
	

//演出中はこいつにカメラが固定される
t.Mv_IWEXIST_Camera <-
{
	function Init()
	{
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[60,999,60] } );
		//LP0
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //

			//PP変化の瞬間のみ見る
			if( mode!= BMvTbl.GetLP(0) )
			{
				BMvTbl.SetLP(0,mode);
				_dm("モード変更:"+mode);
				
				switch( mode )
				{
				case 0: //
					break;
				case 100: //構え開始
					//カメラ拡大
					BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[60,999,60] } );
					break;
				case 150: //きるところ
					break;
				}
			}
			
			//モード中常時やること
			switch( mode )
			{
			case 150: //
				//相手の方に移動開始
				local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
				if( enemy.IsDone ) // 有効かどうか一応チェック
				{
					local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
					//local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
					//print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
					
					local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = posst.distance/60 } );
					BMvTbl.SetVector( { x=v.x, y=v.y, flags=_Vector_DivKeep|_VecFlag_NoMuki } );							
				}
				break;
			case 151: //
				//相手の方に移動開始
				local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
				if( enemy.IsDone ) // 有効かどうか一応チェック
				{
					local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
					//local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
					//print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
					
					local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = posst.distance/200 } );
					local pow = 150;
					BMvTbl.SetVector( { x=v.x*pow/100, y=v.y, flags=_Vector_DivKeep|_VecFlag_NoMuki } );							
				}
				break;
			case 152: //
				Battle_Std.InitVector(); //ベクトル初期化
				break;
			case 300: //
				BMvTbl.SetFinalize(0); //さよなら
				break;
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );
		BMvEff.ResetViewCamera();
	}
}

t.Mv_IWEXIST_Eff_391ef_b <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			//赤いのが出始めたらうんたん
			switch( Battle_Std.GetUpdateFrameID() )
			{
			case 100:
				local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
				BMvCore.PushCharaData( p ); //	
					BMvEff.SetCharaColor( { color=0x222222, intime=20, time=255, type=4} );
				BMvCore.PopCharaData(); //
				
				BMvEff.CreateObject( { mvname="Mv_IWEXIST_Eff_391ef_AtkRect" } ); //判定			
				break;
			}
			
			if( mode>= 300 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCharaColor( { color=0x222222, time=0, type=0} );	
	}
}

t.Mv_IWEXIST_Eff_391ef_AtkRect <-
{
	function Init()
	{
		BMvTbl.SetPattern("391ef_AtkRect");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			if( mode>= 250 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Call_LightEff <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvEff.SetExist( { level = _Exist_NoHantei } ); // 全ての判定チェックなし
	}
	function FrameUpdate()
	{
		//赤いのが出始めたらうんたん
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount%30==0 && s.MvCount!=BMvTbl.GetLP(0) )
		{
			BMvTbl.SetLP(0,s.MvCount); //処理したフレームを記憶
			
			Battle_Std.CreateObjectEX({ x=0, y=0, pat="IWE_Light", FrameID=[0,10,20],
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround,
			});		
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}






HYD_MoveTable <- Battle_Std.MakeMoveTable( t, HYD_CommandTable, Def_ChrNo_Hyd );
__dofile__("./data/Hyd_0/Hyd_0_selist.txt"); //ＳＥ定義

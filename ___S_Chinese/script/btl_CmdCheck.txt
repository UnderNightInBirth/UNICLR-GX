print( "\n>>> [btl_CmdCheck]" );

/*
■コマンドチェック説明
SkillType : コマンドチェックの分類(出したい技の種類ではないので注意)

Special（デフォ） : 必殺Cと技のヒット情報が一致時に出せる
ExSpecial : Specialの条件 or Exのフラグがある場合に出せる(フラグがあると「いつでも」出せる)
Normal : 通常Cと技のヒット情報が一致時に出せる
None : 行動可能時のみ出せる

AddCommand : なんでも


●色々な制限

BallLimit : 飛び道具カウンタが指定以上で失敗
BallCount : 飛び道具カウンタが指定と不一致で失敗
BallOver  : 飛び道具カウンタが指定未満で失敗

HeightLimit : 高さ制限（正の値）

MvCheck.SkillFail : 特定のMvだったら失敗（必殺技用）
MvCheck.Fail : 特定のMvだったら失敗
MvCheck.Only : 特定のMvじゃないと失敗

HitStatus : ヒット情報が不一致なら失敗

FrameIDCheck.Fail : 特定のFrameIDだったら失敗 
FrameIDCheck.Only : 特定のFrameID以外なら失敗 
ParamFlagCheck.Only : 特定のParamとのビットフラグが無かったら失敗
*/

//コマンドチェックかませ関数
function Battle_Std::CmdCheck( t )
{
	// ※この処理通過時のみに変更
	
	//行動可能状態から通常技を出すと発生します
	//同時押しチェック生成フラグがあっても発生します
	//同時押しのズラし押しに対応するためのMvを出すかどうかのフラグ

	local flag_useComboGauge = 0;// ゲージ消費予約フラグ 0:ゲージ消費ない技 1:nゲージ消費技　2:VO中のみとか
	local flag_useReverseBeat = 0;// リバースビートで通過した技　1
	local flag_changeDoujiEnd = 0; // 同時押しで別の行動に強引に移ろうとしたら1
	
	local check_CancelNone = BCMDTbl.CheckCancel( _SkillType_None ); // よく使うので記憶
	
	//やられorガード中はもうここでさよならしてしまう（重たいところだし？）
	//昔は"SkillType"指定が無いものなら一応通れてしまっていたようだ
	local bound_status = BtlMvStd.GetBoundStatus();
	local CmdTbl_SkillType = ("SkillType" in t)? t.SkillType : "Special"; // 無指定だと必殺技レベル
	if( bound_status.isDone ) // やられorガード
	{
		if( CmdTbl_SkillType != "GuardCancel" && CmdTbl_SkillType != "BoundCancel" )
		{
			return 0; // GuardCancel指定じゃなかったら失敗
		}
		if( bound_status.isCapture ) return 0; // 投げられ中は絶対に失敗(投げバグ防止)
	}
	//デバッグ用に色んな技を作るテストを手助けする仕様
	if( Def_Dbg_AllMoveAddCommand && CmdTbl_SkillType.find("Special") != null )
	{
		CmdTbl_SkillType = "AddCommand";
	}

	if ( "Cost" in t )	// ゲージ関係の発動条件
	{
		if ( "ComboGauge" in t.Cost ) //ゲージ制限指定あり
		{
			if( t.Cost.ComboGauge == "OverLiberate")
			{
				if( ( BMvEff.Liberate_Get() != _SpGaugeMode_Liberate ) && ( BCMDTbl.GetComboGauge() < 20000 ) ) return 0;
				flag_useComboGauge = 2; // コンボゲージを消費する技（成立後以降のチェックで使う）
			}
			else if( t.Cost.ComboGauge == "Liberate")
			{
				if( BMvEff.Liberate_Get() != _SpGaugeMode_Liberate ) return 0;		
				flag_useComboGauge = 2; // コンボゲージを消費する技（成立後以降のチェックで使う）
			}
			else
			{
				if( BCMDTbl.GetComboGauge() < t.Cost.ComboGauge ) return 0;
				flag_useComboGauge = 1; // コンボゲージを消費する技（成立後以降のチェックで使う）
			}
		}	
	}

	local limit_type = 0; // 0:通常 1:連打キャンセル
	// キャンセルタイプによる制限
	// Normal  : 通常技、特殊技、投げ
	// Special : 必殺
	// EX      : EX VO
	// SP      : IW IWE
	// 同時押しの時は下には戻れないようにする
	
	local isExSpecial = 0; // EX必殺技を出そうとしてるコマンド系なら1でその場合一部MvCodeで弾いてる
	
	
	switch ( CmdTbl_SkillType )
	{
	case "Special": // 必殺技
		if( !BCMDTbl.CheckCancel( _SkillType_Special ) ) return 0;
		break;
	case "AddCommand":	//追加コマンド・無条件
		break;
	case "ExSpecial":	//EX
		isExSpecial = 1; // EX必殺技を出そうとしている
		if( !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) return 0;
		break;
	case "ExSpecialDouji":	//EX
	case "CVO":
		isExSpecial = 1; // EX必殺技を出そうとしている
		if( !check_CancelNone && !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) )
		{
			// 行動不能＆EXキャンセル不可の時（同時押しとか用に↓の処理がある）
			
			// 条件CVOの時は判定ツールに「チェインシフト可」がついていて、かつdef_MC2_EnableCVO_OnlyCSがあるとOKにする
			local cvo_OnlyCs = 0;
			if( CmdTbl_SkillType == "CVO" )
			{
				if( BCMDTbl.CheckCancel( _SkillType_ChainShift ) && Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_EnableCVO_OnlyCS ) )
				{
					// _dp("\n 成功にする");
					// CVOだけ出せる条件に一致したので、同時押しチェックは行わない
					cvo_OnlyCs = 1;
				}
			}
			
			//CVOだけ出せる特殊な状況、ではない場合
			if( !cvo_OnlyCs )
			{
				// 同時押し用の処理
				local info0 = BCMDTbl.GetCmdInfoEx(0);
				local info1 = BCMDTbl.GetCmdInfoEx(1);
				
				if( info0.GetFrame() == 1 && info1.GetFrame() == 1 )
				{
					// 1つ前の行動が1F、2つ前の行動が1Fとなっている時（B>B+C>A+B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか。これは2つ前ではなく、1つ前のをチェック
					if( !( Battle_Std.CheckDoujiButton( info0 ) && Battle_Std.CheckDoujiButton( info1 ) && info1.GetCancel( _SkillType_ExSpecial ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_SPAction) ) ) return 0;
				}
				else if( info0.GetFrame() <= 2 )
				{
					// 1つ前の行動が2F以内なら同時押しOK（B(2F)>B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか
					if( !( Battle_Std.CheckDoujiButton( info0 ) && info0.GetCancel( _SkillType_ExSpecial ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_SPAction) ) ) return 0;
				}
				else
				{
					// 同時押し猶予切れ
					return 0;
				}
				// 強引に出すの通過
				flag_changeDoujiEnd = 1;
			}
		}
		break;
	case "SpSpecial":	//SP
		isExSpecial = 1; // EX必殺技以上を出そうとしている
		// if( !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) return 0;
		
		// 新処理
		local combo_vo = ( BMvEff.Liberate_GetType() == _LiberateType_Combo ); // クロスキャストヴェール状態のみ
		local gauge_status = BMvEff.Liberate_Get();
		local ex_timing = ( gauge_status == _SpGaugeMode_Normal )? BCMDTbl.CheckCancel( _SkillType_ExSpecial ) : ( BCMDTbl.CheckCancel( _SkillType_ExSpecial ) || (BCMDTbl.CheckCancel( _SkillType_ChainShift ) && Battle_Std.CheckEnemyisDamage() && combo_vo ) );
		
		// _dp("\n gauge_status:"+gauge_status+" combo_vo:"+combo_vo+" BCMDTbl.CheckCancel( _SkillType_ExSpecial ):"+BCMDTbl.CheckCancel( _SkillType_ExSpecial ) );
		if( !ex_timing ) return 0;
		break;
	case "SpSpecialDouji":	//SP
		isExSpecial = 1; // EX必殺技以上を出そうとしている
		// print("\n SpSpecialDouji チェック開始");

		local combo_vo = ( BMvEff.Liberate_GetType() == _LiberateType_Combo ); // クロスキャストヴェール状態のみ
		local gauge_status = BMvEff.Liberate_Get();
		local ex_timing = ( gauge_status == _SpGaugeMode_Normal )? BCMDTbl.CheckCancel( _SkillType_ExSpecial ) : ( BCMDTbl.CheckCancel( _SkillType_ExSpecial ) || (BCMDTbl.CheckCancel( _SkillType_ChainShift ) && Battle_Std.CheckEnemyisDamage() && combo_vo ) );
		
		// print( check_CancelNone+" , "+ex_timing );
		if( !check_CancelNone && !ex_timing ) // 行動不能＋EX技を出せる状況ではない
		{
			// print("\n 行動不能＆ＥＸタイミングではない");
			local info0 = BCMDTbl.GetCmdInfoEx(0);
			local info1 = BCMDTbl.GetCmdInfoEx(1);
			
			if( gauge_status == _SpGaugeMode_Normal )
			{
				// _dp("-> 通常");
				
				// print("\n "+Battle_Std.CheckDoujiButton( info0 )+", "+info0.GetCancel( _SkillType_ExSpecial )+", "+Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) );
				
				if( info0.GetFrame() == 1 && info1.GetFrame() == 1 )
				{
					// 1つ前の行動が1F、2つ前の行動が1Fとなっている時（B>B+C>A+B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか。これは2つ前ではなく、1つ前のをチェック
					if( !( Battle_Std.CheckDoujiButton( info0 ) && Battle_Std.CheckDoujiButton( info1 ) && info1.GetCancel( _SkillType_ExSpecial ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) ) ) return 0;
				}
				else if( info0.GetFrame() <= 2 )
				{
					// 1つ前の行動が2F以内なら同時押しOK（B(2F)>B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか
					if( !( Battle_Std.CheckDoujiButton( info0 ) && info0.GetCancel( _SkillType_ExSpecial ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) ) ) return 0;
				}
				else
				{
					// 同時押し猶予切れ
					return 0;
				}
				// 強引に出すの通過
				flag_changeDoujiEnd = 1;
			}
			else
			{
				// _dp("-> VO中");
			
				// VO中はCSのみ可能なタイミングで、相手がやられ中なら出せる
				
				
				if( info0.GetFrame() == 1 && info1.GetFrame() == 1 )
				{
					// 1つ前の行動が1F、2つ前の行動が1Fとなっている時（B>B+C>A+B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか。これは2つ前ではなく、1つ前のをチェック
					if( !( Battle_Std.CheckDoujiButton( info0 ) && Battle_Std.CheckDoujiButton( info1 ) && ( info0.GetCancel( _SkillType_ExSpecial ) || (info0.GetCancel( _SkillType_ChainShift ) && Battle_Std.CheckEnemyisDamage() && combo_vo ) ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) ) ) return 0;
				}
				else if( info0.GetFrame() <= 2 )
				{
					// 1つ前の行動が2F以内なら同時押しOK（B(2F)>B+C）
					//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
					//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか
					if( !( Battle_Std.CheckDoujiButton( info0 ) && ( info0.GetCancel( _SkillType_ExSpecial ) || (info0.GetCancel( _SkillType_ChainShift ) && Battle_Std.CheckEnemyisDamage() && combo_vo) ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) ) ) return 0;
				}
				else
				{
					return 0;
				}
				// 強引に出すの通過
				flag_changeDoujiEnd = 1;
			}
		}
		else
		{
			// 行動可能から、もしくは普通に出せる条件から出した
			// _dp("-> 行動可能orキャンセル条件");
		}
		break;				
	case "None":	//無し(キャンセルから出せない技) 行動可能時のみ出せる
		if( !check_CancelNone ) return 0;
		break;
	case "NoneDouji": //無し・同時押しチェック
		if( !check_CancelNone ) // 行動不能
		{
			local info0 = BCMDTbl.GetCmdInfoEx(0);
			local info1 = BCMDTbl.GetCmdInfoEx(1);
			
			if( info0.GetFrame() == 1 && info1.GetFrame() == 1 )
			{
				// 1つ前の行動が1F、2つ前の行動が1Fとなっている時（B>B+C>A+B+C）
				//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
				//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか。これは2つ前ではなく、1つ前のをチェック
				if( !( Battle_Std.CheckDoujiButton( info0 ) && Battle_Std.CheckDoujiButton( info1 ) && info1.GetCancel( _SkillType_None ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_Skill|def_MC_EXAction|def_MC_SPAction) ) ) return 0;
			}
			else if( info0.GetFrame() <= 2 )
			{
				// 1つ前の行動が2F以内なら同時押しOK（B(2F)>B+C）
				//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
				//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか
				if( !( Battle_Std.CheckDoujiButton( info0 ) && info0.GetCancel( _SkillType_None ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_Skill|def_MC_EXAction|def_MC_SPAction) ) ) return 0;
			}
			else
			{
				// 同時押し猶予切れ
				return 0;
			}
			// 強引に出すの通過
			flag_changeDoujiEnd = 1;
		}
		break;
	case "SpecialDouji": //必殺技・同時押しチェック
		// print("\n check_CancelNone:"+check_CancelNone+" 必殺:"+BCMDTbl.CheckCancel( _SkillType_Special ) );
		if( !check_CancelNone && !BCMDTbl.CheckCancel( _SkillType_Special ) )
		{
			local info0 = BCMDTbl.GetCmdInfoEx(0);
			local info1 = BCMDTbl.GetCmdInfoEx(1);

			if( info0.GetFrame() == 1 && info1.GetFrame() == 1 )
			{
				// 1つ前の行動が1F、2つ前の行動が1Fとなっている時（B>B+C>A+B+C）
				//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
				//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか。これは2つ前ではなく、1つ前のをチェック
				if( !( Battle_Std.CheckDoujiButton( info0 ) && Battle_Std.CheckDoujiButton( info1 ) && info1.GetCancel( _SkillType_Special ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_EXAction|def_MC_SPAction) ) ) return 0;
			}
			else if( info0.GetFrame() <= 2 )
			{
				// 1つ前の行動が2F以内なら同時押しOK（B(2F)>B+C）
				//Battle_Std.CheckDoujiButton:A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメとかそういうののチェック
				//def_MC1_CmdLvDZ_OK:その行動が同時押しで別の行動に移るのを許されているかどうか
				if( !( Battle_Std.CheckDoujiButton( info0 ) && info0.GetCancel( _SkillType_Special ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) && !Battle_Std.MoveCode.CheckFlag(def_MC_EXAction|def_MC_SPAction) ) ) return 0;
			}
			else
			{
				// 同時押し猶予切れ
				return 0;
			}
			// 強引に出すの通過
			flag_changeDoujiEnd = 1;
		}
		break;				
	case "NormalRapid":	//連打できる通常技
		if( !BCMDTbl.CheckCancel( _SkillType_Normal ) ) return 0;
		limit_type = 1; // 連打キャンセルタイプ
		break;
	case "Normal":	//通常技
		if( !BCMDTbl.CheckCancel( _SkillType_Normal ) ) return 0; //通常技レベルでキャンセルできない状態
		break;
	case "SpecialJump": //必殺技（上要素あり）
		//必殺技は同技ではキャンセルできないように？
		//ジャンプ移行フレームのみ受け付ける
		if( Battle_Std.IsMatchMvNameArray( ["Mv_JumpWait_F","Mv_JumpWait_N","Mv_JumpWait_B"] ) )
		{
		}
		else
		{
			if( !BCMDTbl.CheckCancel( _SkillType_Special ) ) return 0;
		}
		break;
	case "ExSpecialJump":	//EX
		isExSpecial = 1; // EX必殺技を出そうとしている
		// ↓の方でこれと同じ処理あります
		if( Battle_Std.IsMatchMvNameArray( ["Mv_JumpWait_F","Mv_JumpWait_N","Mv_JumpWait_B"] ) )
		{
		}
		else
		{
			if( !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) return 0;
		}
		break;
	case "GuardCancel": //ガードキャンセル
		if( !( BMvTbl.GetMvName()=="Mv_Guard" && bound_status.isBound == 2 ) ) return 0; //失敗
		break;			
	case "BoundCancel":
		if( !bound_status.isBound ) return 0; // やられorガードでないと失敗
		// 自分が死んでいたら出せない
		local rs = BMvTbl.GetMvRoundStatus();
		if( rs.isMyKo )
		{
			// ※Blastは死んでいたら出せないようにはなっているがそれ以外もあるので入れておく
			// _dp("\n 死んでるので出せない");
			return 0;
		}
		break;
	}
	
	// EXキャンセルのときはヒット情報がないと失敗
	if( isExSpecial && Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NoWhiffEXCancel ) )
	{
		//MEMO:Battle_Std.CheckExSpecialCancel()で同じような処理をやっているが厳密には違うので（同時押しとか）このままにする
		local hs = BMvTbl.GetMvHitStatus();
		// _dpn("チェック:"+hs.Type );
		if( !(hs.Type & _HitType_Hit) )
		{
			return 0;
		}
	}	
	
	// コンボリミットは通常技とかの制限ではなくて全体の制限にする
	if( "ComboLimit" in t )
	{
		if( t.ComboLimit )
		{
			local limit_combo = BCMDTbl.CheckComboLimit( t.ComboLimit );
			if( limit_type == 1 ) // 連打タイプ
			{
				if( limit_combo == 1 ) return 0; // 制限を受けている
			}
			else
			{
				if( limit_combo == 255 || limit_combo == 1 ) return 0;
			}
			if( limit_combo == 1 ) return 0; // 制限を受けている
		}
		local nowcombolv = BCMDTbl.GetComboLimitLevel();
		if( t.ComboLimit < nowcombolv )
		{
			flag_useReverseBeat = 1; // リバースビートから出そうとしてる技
		}
	}		
	
	// 細かい制限
	if ( "BallLimit" in t ) // 飛び道具制限
	{
		foreach(i, v in t.BallLimit)
		{
			//print("\n番号："+i+" 数："+v+" チェック:"+BMvTbl.TobiParam_Func({ slot=i, type=_ValGet }) );
			if ( BMvTbl.TobiParam_Func({ slot=i, type=_ValGet }) >= v) //指定未満じゃないと出ない
			{
				return 0; //飛び道具カウンタ以下じゃないとだめ			
			}
		}
	}
	if ( "BallCount" in t ) // 飛び道具制限
	{
		foreach(i, v in t.BallCount)
		{
			//print("番号："+i+" 数："+v);
			if ( BMvTbl.TobiParam_Func({ slot=i, type=_ValGet }) != v) return 0; //飛び道具カウンタと同じじゃないとだめ						
		}
	}
	if ( "BallOver" in t ) // 飛び道具制限
	{
		foreach(i, v in t.BallOver)
		{
			if ( BMvTbl.TobiParam_Func({ slot=i, type=_ValGet }) < v) return 0; //飛び道具カウンタ以上じゃないとだめ		
		}
	}	
	if ( "DashLimit" in t ) //ダッシュ制限
	{
		if (BCMDTbl.CheckDash(0,0) >= t.DashLimit) return 0;
	}
	if ( "HeightLimit" in t ) //高度制限
	{
		//_dm("はいった？ t.HeightLimit:"+t.HeightLimit+" 結果："+BCMDTbl.CheckDash(t.HeightLimit,0));
		//if ( !BCMDTbl.CheckDash(t.HeightLimit,0) ) return 0;
		local pos = BMvTbl.GetPosition(0); //座標を取得（操作親でなくていい？）
		if( pos.y > -t.HeightLimit ) return 0; //HeightLimitは高さ（プラス）なのでちょっと変換
	}
	if ( "AirJumpLimit" in t ) //多段ジャンプチェック レバーニュートラルが検出されるまで再ジャンプ可能状態にならない
	{
		if ( !BCMDTbl.CheckAirJump(t.AirJumpLimit) ) return 0;//ジャンプカウントがt.AirJumpLimit以上だと0
	}	
	
	
	//特定のMvの時ははじく
	if ( "MvCheck" in t )
	{
		if ( "SkillFail" in t.MvCheck )	//特定のMvだったらはじく（必殺技用）
		{
			//行動可能かチェック
			//※もともと行動不能のmvでアニメ後半が行動可能になっているものは同技でキャンセルできるようにする

			//怖いので地上のmvのみ
			if( !check_CancelNone )
			{
				//行動不能
				if( Battle_Std.IsMatchMvNameArray( t.MvCheck.SkillFail ) ) return 0;
			}
			else
			{
				//地上キャンセル
				if( !BCMDTbl.CheckPosState( _PosState_Ground ) )
				{
					//地上ではない
					if( Battle_Std.IsMatchMvNameArray( t.MvCheck.SkillFail ) ) return 0;				
				}
				else
				{
					//地上だ
					//行動可能で地上状態
					//同技のチェックを行わない
				}
			}
		}
		
		if ( "Fail" in t.MvCheck )	//特定のMvだったらはじく
		{
			if( Battle_Std.IsMatchMvNameArray( t.MvCheck.Fail ) ) return 0;
		}
		if ( "Only" in t.MvCheck )	//特定のMvから以外だとはじく
		{
			if( !Battle_Std.IsMatchMvNameArray( t.MvCheck.Only ) ) return 0;
		}	
	}

	//ヒット状態を見てはじく
	//BMvTbl.ClearHitStatus()をやってないのでキャンセルで出した技から追加入力がすぐ受け付けちゃう
	if( "HitStatus" in t)
	{
		local s = BMvTbl.GetMvHitStatus();
		//_dm( " hs:"+s.Type+" _HitType_Damage:"+_HitType_Damage+" _HitType_Guard:"+_HitType_Guard );
		//_dm("HitStatis"+(s.Type ==_HitType_Damage || s.Type ==_HitType_Guard ));
		switch ( t.HitStatus )
		{
		case "Hit":
			if( !(s.Type & _HitType_Hit ) ) return 0;
			break;
		case "Damage":
			if( !(s.Type & _HitType_Damage) ) return 0;
			break;
		case "Guard":
			if( !(s.Type & _HitType_Guard) ) return 0;
			break;
		}	
	}

	//IDを見てはじく
	if( "FrameIDCheck" in t)
	{
		//_dm("ID:"+Battle_Std.GetPlayerFrameID() );
		if ( "Fail" in t.FrameIDCheck )	//特定のFrameIDだったらはじく
		{
			local p_frameid = Battle_Std.GetPlayerFrameID();
			if( type( t.FrameIDCheck.Fail ) == "array" )
			{
				foreach( i, v in t.FrameIDCheck.Fail )
				{
					if( p_frameid == v ) return 0;
				}			
			}
			else
			{
				if( p_frameid == t.FrameIDCheck.Fail ) return 0;
			}
		}
		if ( "Only" in t.FrameIDCheck )	//特定のFrameIDから以外だとはじく
		{	
			local p_frameid = Battle_Std.GetPlayerFrameID();
			if( type( t.FrameIDCheck.Only ) == "array" )
			{
				local hit = 0;
				foreach( i, v in t.FrameIDCheck.Only )
				{
					if( p_frameid == v )
					{
						hit = 1;
						break;
					}				
				}
				if( !hit ) return 0; // 何も無かったら失敗
			}
			else
			{
				if( p_frameid != t.FrameIDCheck.Only ) return 0;		
			}
		}
	}
	
	//Paramとのビットフラグチェック
	//ParamFlagCheck = { Only = { [2]=16 } } とかかくとParam2&16 で成功になる
	//ParamFlagCheck = { Only = { [2]=16, [3]=8 } } とかかくとParam2&16 || Param3&8 で成功になる(orなので注意)
	if( "ParamFlagCheck" in t )
	{
		if( "Only" in t.ParamFlagCheck )
		{
			local isFlagFind = 0;
			foreach( slot, val in t.ParamFlagCheck.Only )
			{
				if( Battle_Std.CheckParamFlags( slot, val ) )
				{
					isFlagFind = 1;
					break;
				}
			}
			if( !isFlagFind ) return 0;
		}
	}
	
	// 特殊な弾き
	if( !Def_Rule_EnableReverceBeat )
	{
		if( flag_useReverseBeat ) return 0;
	}

	//ここから先は出せるの確定してからの処理　---------------------------------
	//CmdCheck通過で更新されるステータス
	//_dp("\n def_PP_CmdStatus初期化");
	BMvTbl.SetPP(def_PP_CmdStatus,0); //初期化
	if( BCMDTbl.CheckCancel( _SkillType_Normal )==255 )
	{
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_MoveAble ); //行動可能だった
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_ExCancelOK ); //EX技を出せる状態だった
	}
	else
	{
		// ↑の方でこれと同じ処理あります
		local cmd_excancel = 0;
		if( BCMDTbl.CheckMoveName( ["Mv_JumpWait_F","Mv_JumpWait_N","Mv_JumpWait_B","Mv_HighJumpWait_F"] ) )
		{
			// cmd_excancel = 1; // ※UNIなんでね
		}
		else
		{
			if( BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) cmd_excancel = 1;
		}
		if( cmd_excancel )
		{
			// _dp("\n SP技出せるところから");
			if( Battle_Std.CancelCheck_EXSpecialSkill() )
			{
				// _dp("\n EX技出せるところから");
				BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_ExCancelOK ); //EX技を出せる状態だった
			}
		}	
	}
	
	// ゲージ消費予約処理
	if( !flag_useComboGauge ) // ゲージ消費しない技
	{
	}
	else if( flag_useComboGauge == 2 ) // VO中のみ
	{
		BMvEff.Liberate_End(); //
		BCMDTbl.SetSpUseBufferTmp( { value=20000 } ); //ゲージ消費予約
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_UseGauge ); //ゲージ消費技予約
	}
	else // １ゲージ消費とか
	{
		BCMDTbl.SetSpUseBufferTmp( { value=t.Cost.ComboGauge } ); //ゲージ消費予約
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_UseGauge ); //ゲージ消費技予約
	}
	
	// リバースビートのアナウンス？
	if( flag_useReverseBeat ) // リバースビートから出そうとした技
	{
		//_dp("\n useReverseBeat予約");
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)|def_PP_CS_ReverseBeat ); //リバースビートから出そうとした
	}
	
	// 同時押しの猶予で強引に切り替わった場合
	if( flag_changeDoujiEnd )
	{
		// _dp("\n flag_changeDoujiEnd予約");
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_DoujiEndYoyaku );
	}

	return 1; //ここまでくれば出せる技
}

print("\n btl_CmdCheck.....OK");
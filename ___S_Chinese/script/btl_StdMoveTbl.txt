btl_debPrint2( "\n>>> [btl_StdMoveTbl]" );


//すごい長い関数
//_ChrNo:キャラ番号を指定する

function Battle_Std::GetStdMoveTable( _ChrNo=0, ) {

// ----------------------------------------------------------------------------
//キャラクター別のmvを作るとき用の関数
// ----------------------------------------------------------------------------
_dp1p("\n[btl_ChrParamFunc]");
local CHRMAX = 100; //キャラ番号最大値
local chrparam = {};

chrparam.Param <- {}; //キャラ別の細かいフレームとかのテーブル
chrparam.Get <- function( tbl={} ) //chrparam.Paramから作成中のキャラ番号の値を取ってくる
{
	local checktype = tbl.type;
	local checkchrnum = tbl.chrnum;
	
	if( checktype in Param )
	{
		local ret = Param[checktype][checkchrnum];
		btl_debPrint_CharacterMake("【定義】chrparam:"+checktype+" chr:"+checkchrnum+" -> "+ret);
		return ret;
	}
	else
	{
		btl_debError_CharacterMake("【警告】chrparamで未定義:"+checktype+" chr:"+checkchrnum);
		return 0;
	}
}
	
{	//ダッシュのタメの硬直フレーム
	//この時間が経過するとDashWaitからDash_FのMvへ移行する
	//パターンは変化しないので注意
	local type = "ダッシュでかかり硬直Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4);
	chrparam.Param[type][Def_ChrNo_Hyd] = 4;
	chrparam.Param[type][Def_ChrNo_Lin] = 3;
	chrparam.Param[type][Def_ChrNo_EXLin] = 3;
	chrparam.Param[type][Def_ChrNo_Wal] = 8;
	chrparam.Param[type][Def_ChrNo_Car] = 7;
	chrparam.Param[type][Def_ChrNo_Ori] = 5;
	chrparam.Param[type][Def_ChrNo_Gor] = 6;
	chrparam.Param[type][Def_ChrNo_Mer] = 4;
	chrparam.Param[type][Def_ChrNo_Vat] = 4;
	chrparam.Param[type][Def_ChrNo_Set] = 6;
	chrparam.Param[type][Def_ChrNo_Yuz] = 6;
	chrparam.Param[type][Def_ChrNo_Hil] = 6;
	chrparam.Param[type][Def_ChrNo_Elt] = 3;
	chrparam.Param[type][Def_ChrNo_Nan] = 3;
	chrparam.Param[type][Def_ChrNo_Bya] = 4;
	chrparam.Param[type][Def_ChrNo_Aka] = 5;
	chrparam.Param[type][Def_ChrNo_Cha] = 4;
	chrparam.Param[type][Def_ChrNo_Wag] = 5;
	chrparam.Param[type][Def_ChrNo_Enk] = 4;
	chrparam.Param[type][Def_ChrNo_Lnd] = 4;
	chrparam.Param[type][Def_ChrNo_Mik] = 5;
	chrparam.Param[type][Def_ChrNo_Pho] = 5;
}

{	// ダッシュ停止不能Ｆ
	//ダッシュのタメを抜けてから、とまれるようになるまでの時間）
	//行動可能になってからどれだけの間停止に移行できないか
	//FrameID100があって停止できるMvでないと意味がない
	//これが長いと小刻みな動きができなくなる
	//少なすぎると慣性つけたダッシュ弱攻撃をやるのがやや難しくなる
	//停止モーションまでいけばリセット（ガードできる）ので"ダッシュガード不能Ｆ"より長くてもＯＫ
	local type = "ダッシュ停止不能Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 4);
	chrparam.Param[type][Def_ChrNo_Hyd] = 4;
	chrparam.Param[type][Def_ChrNo_Lin] = 6;
	chrparam.Param[type][Def_ChrNo_EXLin] = 6;
	chrparam.Param[type][Def_ChrNo_Wal] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Car] = 4;
	chrparam.Param[type][Def_ChrNo_Ori] = 4;
	chrparam.Param[type][Def_ChrNo_Gor] = 4;
	chrparam.Param[type][Def_ChrNo_Mer] = 8;
	chrparam.Param[type][Def_ChrNo_Vat] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Set] = 3; //ダッシュガード苦手
	chrparam.Param[type][Def_ChrNo_Yuz] = 4;
	chrparam.Param[type][Def_ChrNo_Hil] = 12;
	chrparam.Param[type][Def_ChrNo_Elt] = 4;
	chrparam.Param[type][Def_ChrNo_Nan] = 4;
	chrparam.Param[type][Def_ChrNo_Bya] = 4;
	chrparam.Param[type][Def_ChrNo_Aka] = -1; //任意停止はない
	chrparam.Param[type][Def_ChrNo_Cha] = 4;
	chrparam.Param[type][Def_ChrNo_Wag] = 4;
	chrparam.Param[type][Def_ChrNo_Enk] = 4;
	chrparam.Param[type][Def_ChrNo_Lnd] = 5;
	chrparam.Param[type][Def_ChrNo_Mik] = 4;
	chrparam.Param[type][Def_ChrNo_Pho] = 5;
}

{	//ダッシュ停止やMv抜けのときのベクトル係数
	local type = "ダッシュ停止慣性";
	// 慣性係数, 収束F, 慣性最大値, 慣性最大値に対して1フレーム毎に加算される値
	chrparam.Param[type] <- array(CHRMAX, [100,10,2700,200]);
	chrparam.Param[type][Def_ChrNo_Hyd] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Lin] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_EXLin] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Wal] = [100,14,   0,  0];
	chrparam.Param[type][Def_ChrNo_Car] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Ori] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Gor] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Mer] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Vat] = [100,10,   0,  0];
	chrparam.Param[type][Def_ChrNo_Set] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Yuz] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Hil] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Elt] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Nan] = [100,12,2700,200];
	chrparam.Param[type][Def_ChrNo_Bya] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Aka] = [100,10,   0,  0];
	chrparam.Param[type][Def_ChrNo_Cha] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Wag] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Enk] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Lnd] = [100,10,2700,200];
	chrparam.Param[type][Def_ChrNo_Mik] = [100,10,2700,250];
	chrparam.Param[type][Def_ChrNo_Pho] = [100,10,2700,200];	
}

{	//ダッシュジャンプの慣性
	//ベクトル * この値 / 100
	local type = "ダッシュジャンプ慣性";
	chrparam.Param[type] <- array(CHRMAX, 17);
	chrparam.Param[type][Def_ChrNo_Hyd] = 17;
	chrparam.Param[type][Def_ChrNo_Lin] = 20;
	chrparam.Param[type][Def_ChrNo_EXLin] = 20;
	chrparam.Param[type][Def_ChrNo_Wal] = 17;
	chrparam.Param[type][Def_ChrNo_Car] = 17;
	chrparam.Param[type][Def_ChrNo_Ori] = 17;
	chrparam.Param[type][Def_ChrNo_Gor] = 17;
	chrparam.Param[type][Def_ChrNo_Mer] = 17;
	chrparam.Param[type][Def_ChrNo_Vat] = 17;
	chrparam.Param[type][Def_ChrNo_Set] = 17;
	chrparam.Param[type][Def_ChrNo_Yuz] = 17;
	chrparam.Param[type][Def_ChrNo_Hil] = 17;
	chrparam.Param[type][Def_ChrNo_Elt] = 25;
	chrparam.Param[type][Def_ChrNo_Nan] = 25;
	chrparam.Param[type][Def_ChrNo_Bya] = 17;
	chrparam.Param[type][Def_ChrNo_Aka] = 20;
	chrparam.Param[type][Def_ChrNo_Cha] = 17;
	chrparam.Param[type][Def_ChrNo_Wag] = 17;
	chrparam.Param[type][Def_ChrNo_Enk] = 20;
	chrparam.Param[type][Def_ChrNo_Lnd] = 17;
	chrparam.Param[type][Def_ChrNo_Mik] = 20;
	chrparam.Param[type][Def_ChrNo_Pho] = 17;
}



{	//バックダッシュの無敵時間
	local type = "バクステ打撃無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 8);
	chrparam.Param[type][Def_ChrNo_Hyd] = 8;
	chrparam.Param[type][Def_ChrNo_Lin] = 8;
	chrparam.Param[type][Def_ChrNo_EXLin] = 8;
	chrparam.Param[type][Def_ChrNo_Wal] = 10;
	chrparam.Param[type][Def_ChrNo_Car] = 8;
	chrparam.Param[type][Def_ChrNo_Ori] = 8;
	chrparam.Param[type][Def_ChrNo_Gor] = 8;
	chrparam.Param[type][Def_ChrNo_Mer] = 10;
	chrparam.Param[type][Def_ChrNo_Vat] = 8;
	chrparam.Param[type][Def_ChrNo_Set] = 7;
	chrparam.Param[type][Def_ChrNo_Yuz] = 8;
	chrparam.Param[type][Def_ChrNo_Hil] = 9;
	chrparam.Param[type][Def_ChrNo_Elt] = 8;
	chrparam.Param[type][Def_ChrNo_Nan] = 8;
	chrparam.Param[type][Def_ChrNo_Bya] = 8;
	chrparam.Param[type][Def_ChrNo_Aka] = 8;
	chrparam.Param[type][Def_ChrNo_Cha] = 8;
	chrparam.Param[type][Def_ChrNo_Wag] = 8;
	chrparam.Param[type][Def_ChrNo_Enk] = 8;
	chrparam.Param[type][Def_ChrNo_Lnd] = 8;
	chrparam.Param[type][Def_ChrNo_Mik] = 8;
	chrparam.Param[type][Def_ChrNo_Pho] = 8;
}

{	// バクステの投げ無敵フレーム
	local type = "バクステ投げ無敵Ｆ";
	chrparam.Param[type] <- array(CHRMAX, 10);
	chrparam.Param[type][Def_ChrNo_Hyd] = 10;
	chrparam.Param[type][Def_ChrNo_Lin] = 10;
	chrparam.Param[type][Def_ChrNo_EXLin] = 10;
	chrparam.Param[type][Def_ChrNo_Wal] = 10;
	chrparam.Param[type][Def_ChrNo_Car] = 10;
	chrparam.Param[type][Def_ChrNo_Ori] = 10;
	chrparam.Param[type][Def_ChrNo_Gor] = 10;
	chrparam.Param[type][Def_ChrNo_Mer] = 10;
	chrparam.Param[type][Def_ChrNo_Vat] = 10;
	chrparam.Param[type][Def_ChrNo_Set] = 10;
	chrparam.Param[type][Def_ChrNo_Yuz] = 10;
	chrparam.Param[type][Def_ChrNo_Hil] = 10;
	chrparam.Param[type][Def_ChrNo_Elt] = 10;
	chrparam.Param[type][Def_ChrNo_Nan] = 10;
	chrparam.Param[type][Def_ChrNo_Bya] = 10;
	chrparam.Param[type][Def_ChrNo_Aka] = 10;
	chrparam.Param[type][Def_ChrNo_Cha] = 10;
	chrparam.Param[type][Def_ChrNo_Wag] = 10;
	chrparam.Param[type][Def_ChrNo_Enk] = 10;
	chrparam.Param[type][Def_ChrNo_Lnd] = 10;
	chrparam.Param[type][Def_ChrNo_Mik] = 10;
	chrparam.Param[type][Def_ChrNo_Pho] = 10;
}

//歩きやダッシュの足音ＳＥ定義
{
	//Param0が10のタイミングでＡ→Ｂ→Ａ→Ｂと再生される
	//定義が-1だと再生されない
	// st[170] =	{  file=path+"SE170_Walk_ShoesA", type=-1  }; // 歩き
	// st[171] =	{  file=path+"SE171_Walk_ShoesB", type=-1  }; // 歩き
	// st[172] =	{  file=path+"SE172_Walk_BootsA", type=-1  }; // 歩き
	// st[173] =	{  file=path+"SE173_Walk_BootsB", type=-1  }; // 歩き
	// st[174] =	{  file=path+"SE174_Walk_HeelsA", type=-1  }; // 歩き
	// st[175] =	{  file=path+"SE175_Walk_HeelsB", type=-1  }; // 歩き
	local _FSST_Shoes = 170;
	local _FSST_Boots = 172;
	local _FSST_Heels = 174;
	
	local typeA = "足音Ａ_ＳＥ番号";

	chrparam.Param[typeA] <- array(CHRMAX, -1);
	chrparam.Param[typeA][Def_ChrNo_Hyd] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Lin] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_EXLin] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Wal] = 25;
	chrparam.Param[typeA][Def_ChrNo_Car] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Ori] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Gor] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Mer] = -1;
	chrparam.Param[typeA][Def_ChrNo_Vat] = -1;
	chrparam.Param[typeA][Def_ChrNo_Set] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Yuz] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Hil] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Elt] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Nan] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Bya] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Aka] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Cha] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_Wag] = _FSST_Heels;
	chrparam.Param[typeA][Def_ChrNo_Enk] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Lnd] = -1;
	chrparam.Param[typeA][Def_ChrNo_Mik] = _FSST_Boots;
	chrparam.Param[typeA][Def_ChrNo_Pho] = _FSST_Heels;
	
	chrparam.Param[typeA][Def_ChrNo_Naoto] = _FSST_Shoes;
	chrparam.Param[typeA][Def_ChrNo_KDash] = _FSST_Shoes;

	local typeB = "足音Ｂ_ＳＥ番号";
	
	chrparam.Param[typeB] <- array(CHRMAX, -1);
	chrparam.Param[typeB][Def_ChrNo_Hyd] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Lin] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_EXLin] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Wal] = 25;
	chrparam.Param[typeB][Def_ChrNo_Car] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Ori] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Gor] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Mer] = -1;
	chrparam.Param[typeB][Def_ChrNo_Vat] = -1;
	chrparam.Param[typeB][Def_ChrNo_Set] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Yuz] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Hil] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Elt] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Nan] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Bya] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Aka] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Cha] = _FSST_Shoes+1;
	chrparam.Param[typeB][Def_ChrNo_Wag] = _FSST_Heels+1;
	chrparam.Param[typeB][Def_ChrNo_Enk] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Lnd] = -1;
	chrparam.Param[typeB][Def_ChrNo_Mik] = _FSST_Boots+1;
	chrparam.Param[typeB][Def_ChrNo_Pho] = _FSST_Heels+1;
	
	chrparam.Param[typeA][Def_ChrNo_Naoto] = _FSST_Shoes+1;
	chrparam.Param[typeA][Def_ChrNo_KDash] = _FSST_Shoes+1;
}

{
	local type = "空中受け身バリアタイプ";
	chrparam.Param[type] <- array(CHRMAX, Def_Sys_RecoverBarrierType);
	chrparam.Param[type][Def_ChrNo_Hyd] = 1;
	chrparam.Param[type][Def_ChrNo_Lin] = 1;
	chrparam.Param[type][Def_ChrNo_Wal] = 1;
	chrparam.Param[type][Def_ChrNo_Car] = 1;
	chrparam.Param[type][Def_ChrNo_Ori] = 1;
	chrparam.Param[type][Def_ChrNo_Gor] = 1;
	chrparam.Param[type][Def_ChrNo_Mer] = 1;
	chrparam.Param[type][Def_ChrNo_Vat] = 1;
	chrparam.Param[type][Def_ChrNo_Set] = 1;
	chrparam.Param[type][Def_ChrNo_Yuz] = 1;
	chrparam.Param[type][Def_ChrNo_Hil] = 0; // バリア継続しない
	chrparam.Param[type][Def_ChrNo_Elt] = 1;
	chrparam.Param[type][Def_ChrNo_Nan] = 1;
	chrparam.Param[type][Def_ChrNo_Bya] = 1;
	chrparam.Param[type][Def_ChrNo_Aka] = 1;
	chrparam.Param[type][Def_ChrNo_Cha] = 1;
	chrparam.Param[type][Def_ChrNo_Wag] = 1;
	chrparam.Param[type][Def_ChrNo_Enk] = 1;
	chrparam.Param[type][Def_ChrNo_Lnd] = 1;
	chrparam.Param[type][Def_ChrNo_Mik] = 1;
	chrparam.Param[type][Def_ChrNo_Pho] = 1;
}

{
	local type = "地上受け身着地エフェクトタイプ";
	chrparam.Param[type] <- array(CHRMAX, 0);
	chrparam.Param[type][Def_ChrNo_Hyd] = 0;
	chrparam.Param[type][Def_ChrNo_Lin] = 0;
	chrparam.Param[type][Def_ChrNo_Wal] = 1; // 大きい＋SE違い
	chrparam.Param[type][Def_ChrNo_Car] = 0;
	chrparam.Param[type][Def_ChrNo_Ori] = 0;
	chrparam.Param[type][Def_ChrNo_Gor] = 0;
	chrparam.Param[type][Def_ChrNo_Mer] = 0;
	chrparam.Param[type][Def_ChrNo_Vat] = 0;
	chrparam.Param[type][Def_ChrNo_Set] = 0;
	chrparam.Param[type][Def_ChrNo_Yuz] = 0;
	chrparam.Param[type][Def_ChrNo_Hil] = 0;
	chrparam.Param[type][Def_ChrNo_Elt] = 0;
	chrparam.Param[type][Def_ChrNo_Nan] = 0;
	chrparam.Param[type][Def_ChrNo_Bya] = 0;
	chrparam.Param[type][Def_ChrNo_Aka] = 0;
	chrparam.Param[type][Def_ChrNo_Cha] = 0;
	chrparam.Param[type][Def_ChrNo_Wag] = 0;
	chrparam.Param[type][Def_ChrNo_Enk] = 0;
	chrparam.Param[type][Def_ChrNo_Lnd] = 0;
	chrparam.Param[type][Def_ChrNo_Mik] = 0;
	chrparam.Param[type][Def_ChrNo_Pho] = 0;
}

{
	local type = "立ち挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 0); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Hyd] = 1;
	chrparam.Param[type][Def_ChrNo_Lin] = 1;
	chrparam.Param[type][Def_ChrNo_Wal] = 0;
	chrparam.Param[type][Def_ChrNo_Car] = 1;
	chrparam.Param[type][Def_ChrNo_Ori] = 1;
	chrparam.Param[type][Def_ChrNo_Gor] = 0;
	chrparam.Param[type][Def_ChrNo_Mer] = 0;
	chrparam.Param[type][Def_ChrNo_Vat] = 1;
	chrparam.Param[type][Def_ChrNo_Set] = 0;
	chrparam.Param[type][Def_ChrNo_Yuz] = 1;
	chrparam.Param[type][Def_ChrNo_Hil] = 1;
	chrparam.Param[type][Def_ChrNo_Elt] = 1;
	chrparam.Param[type][Def_ChrNo_Nan] = 0;
	chrparam.Param[type][Def_ChrNo_Bya] = 1;
	chrparam.Param[type][Def_ChrNo_Aka] = 1;
	chrparam.Param[type][Def_ChrNo_Cha] = 1;
	chrparam.Param[type][Def_ChrNo_Wag] = 1;
	chrparam.Param[type][Def_ChrNo_Enk] = 1;
	chrparam.Param[type][Def_ChrNo_Lnd] = 1;
	chrparam.Param[type][Def_ChrNo_Mik] = 0;
	chrparam.Param[type][Def_ChrNo_Pho] = 1;
}

{
	local type = "しゃがみ挑発タイプ";
	chrparam.Param[type] <- array(CHRMAX, 0); // 0:モーション無し・挑発無し 1:モーションあり(512)・挑発あり　2:モーション無し・挑発あり
	chrparam.Param[type][Def_ChrNo_Hyd] = 0;
	chrparam.Param[type][Def_ChrNo_Lin] = 0;
	chrparam.Param[type][Def_ChrNo_Wal] = 0;
	chrparam.Param[type][Def_ChrNo_Car] = 0;
	chrparam.Param[type][Def_ChrNo_Ori] = 0;
	chrparam.Param[type][Def_ChrNo_Gor] = 0;
	chrparam.Param[type][Def_ChrNo_Mer] = 0;
	chrparam.Param[type][Def_ChrNo_Vat] = 0;
	chrparam.Param[type][Def_ChrNo_Set] = 0;
	chrparam.Param[type][Def_ChrNo_Yuz] = 0;
	chrparam.Param[type][Def_ChrNo_Hil] = 1;
	chrparam.Param[type][Def_ChrNo_Elt] = 0;
	chrparam.Param[type][Def_ChrNo_Nan] = 0;
	chrparam.Param[type][Def_ChrNo_Bya] = 0;
	chrparam.Param[type][Def_ChrNo_Aka] = 0;
	chrparam.Param[type][Def_ChrNo_Cha] = 0;
	chrparam.Param[type][Def_ChrNo_Wag] = 0;
	chrparam.Param[type][Def_ChrNo_Enk] = 0;
	chrparam.Param[type][Def_ChrNo_Lnd] = 0;
	chrparam.Param[type][Def_ChrNo_Mik] = 0;
	chrparam.Param[type][Def_ChrNo_Pho] = 0;
}

{
	local type = "ウェブやられエフェクトサイズ";
	chrparam.Param[type] <- array(CHRMAX, [100,100]); // X Y
	chrparam.Param[type][Def_ChrNo_Hyd] = [100,100];
	chrparam.Param[type][Def_ChrNo_Lin] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_EXLin] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Wal] = [130,100];
	chrparam.Param[type][Def_ChrNo_Car] = [100,100];
	chrparam.Param[type][Def_ChrNo_Ori] = [100,100];
	chrparam.Param[type][Def_ChrNo_Gor] = [100,100];
	chrparam.Param[type][Def_ChrNo_Mer] = [130,100];
	chrparam.Param[type][Def_ChrNo_Vat] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Set] = [100,100];
	chrparam.Param[type][Def_ChrNo_Yuz] = [100,100];
	chrparam.Param[type][Def_ChrNo_Hil] = [100,100];
	chrparam.Param[type][Def_ChrNo_Elt] = [100,100];
	chrparam.Param[type][Def_ChrNo_Nan] = [100,100];
	chrparam.Param[type][Def_ChrNo_Bya] = [100,100];
	chrparam.Param[type][Def_ChrNo_Aka] = [100,100];
	chrparam.Param[type][Def_ChrNo_Cha] = [100,100];
	chrparam.Param[type][Def_ChrNo_Wag] = [100,100];
	chrparam.Param[type][Def_ChrNo_Enk] = [100,100];
	chrparam.Param[type][Def_ChrNo_Lnd] = [100,100];
	chrparam.Param[type][Def_ChrNo_Mik] = [ 90, 90];
	chrparam.Param[type][Def_ChrNo_Pho] = [100,100];
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "地上アサルト硬直"; // デフォ値10。飛ぶまでが5Fなので、5+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
	chrparam.Param[type][Def_ChrNo_Hyd] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Lin] = [7,-1,-1];
	chrparam.Param[type][Def_ChrNo_EXLin] = [7,-1,-1];
	chrparam.Param[type][Def_ChrNo_Wal] = [-1,-1,9]; // バグ
	chrparam.Param[type][Def_ChrNo_Car] = [-1,8,-1];
	chrparam.Param[type][Def_ChrNo_Ori] = [-1,9,-1];
	chrparam.Param[type][Def_ChrNo_Gor] = [8,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mer] = [9,8,8]; // バグ
	chrparam.Param[type][Def_ChrNo_Vat] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Set] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Yuz] = [7,8,9]; // バグ
	chrparam.Param[type][Def_ChrNo_Hil] = [7,8,7]; // バグ 85/80 85/96
	chrparam.Param[type][Def_ChrNo_Elt] = [-1,8,-1];
	chrparam.Param[type][Def_ChrNo_Nan] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Bya] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Aka] = [8,8,-1];
	chrparam.Param[type][Def_ChrNo_Cha] = [-1,9,-1];
	chrparam.Param[type][Def_ChrNo_Wag] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Enk] = [8,-1,-1]; // バグ
	chrparam.Param[type][Def_ChrNo_Lnd] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mik] = [9,-1,-1];
	chrparam.Param[type][Def_ChrNo_Pho] = [-1,-1,-1];
}

{
	//最小の値から行動可能になる（必殺技とかも出せる）
	//特殊技はABCによって分けられるので注意（J2CはJCのフレームになる）
	//同じフレームにしないとJ2Cを入れたのにJCが出たりして不快
	local type = "空中アサルト硬直"; // デフォ値9。飛ぶまでが5Fなので、5+値+ジャンプ攻撃のフレームが最速
	chrparam.Param[type] <- array(CHRMAX, [-1,-1,-1]); // JA, JB, JC
	chrparam.Param[type][Def_ChrNo_Hyd] = [8,-1,8];
	chrparam.Param[type][Def_ChrNo_Lin] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_EXLin] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Wal] = [8,8,8];
	chrparam.Param[type][Def_ChrNo_Car] = [-1,7,8];
	chrparam.Param[type][Def_ChrNo_Ori] = [-1,7,7];
	chrparam.Param[type][Def_ChrNo_Gor] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Mer] = [8,8,8];
	chrparam.Param[type][Def_ChrNo_Vat] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Set] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Yuz] = [7,7,8];
	chrparam.Param[type][Def_ChrNo_Hil] = [7,7,7]; // 8,10,16
	chrparam.Param[type][Def_ChrNo_Elt] = [8,7,7];
	chrparam.Param[type][Def_ChrNo_Nan] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Bya] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Aka] = [7,7,7];
	chrparam.Param[type][Def_ChrNo_Cha] = [8,7,8];
	chrparam.Param[type][Def_ChrNo_Wag] = [-1,8,8];
	chrparam.Param[type][Def_ChrNo_Enk] = [7,8,7];
	chrparam.Param[type][Def_ChrNo_Lnd] = [-1,-1,-1];
	chrparam.Param[type][Def_ChrNo_Mik] = [7,8,8];
	chrparam.Param[type][Def_ChrNo_Pho] = [-1,8,8];
}

//パターン定義
{	// 空中ガードからの戻りパターン
	local type = "空中ガードからの戻りパターン";
	chrparam.Param[type] <- array(CHRMAX, 20);
	chrparam.Param[type][Def_ChrNo_Pho] = 39;
}

_dp1p("\n[btl_ChrParamFunc] -> end");

//local test = chrparam.Get( { type="地上アサルト硬直", chrnum=_ChrNo } );
//print("test:"+test);






// キャラクター固有ヒットエフェクト定義
// タイプ：Ａ〜Ｚ
// 強さ：弱　中　強　間引き　特大
// 回転・拡大・ＳＥは判定ツールのグラフィック側で設定する
// {
	// chrparam.Param["固有ヒットエフェクト1"] <- array(CHRMAX, -1);
	// chrparam.Param["固有ヒットエフェクト1"][Def_ChrNo_Cha] = [
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // 間引き
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // A
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // B
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 }, // C
	// { datatype=0, pat="eff_DahHitFlash", MaxFrameID=1 } // D
	// ];
// }




local val_GroundRecoverEffectType = chrparam.Get( { type="地上受け身着地エフェクトタイプ", chrnum=_ChrNo } ); 
local callLandEffect = function() : (val_GroundRecoverEffectType)
{
	switch( val_GroundRecoverEffectType )
	{
	case 1: // ワレンとか重い
		BMvEff.CreateObject( { datatype=1, start_pat=290 } );
		BSound.SE_Play( { type=_SeType_Player, num=25 } );
		BMvEff.SetCamera_Quake( { time=20, type=0 } );
		break;
	default: // 通常
		BMvEff.CreateObject( { datatype=1, start_pat=20 } );
		break;
	}
}


// ----------------------------------------------------------------------------
// Std_MoveTable作成
// ----------------------------------------------------------------------------

local Std_MoveTable = {} //基本行動リストテーブル

Battle_Std.AddHitEffects( Std_MoveTable, _ChrNo ); // ヒットエフェクトMvを追加する


local debug_HitMutekiArray = array(1024,"");

const Def_HitCheckFlag_Ptimer = 512;

const Def_HitCheckFlag_TRUEINV = 256;

debug_HitMutekiArray[0] = "none";

debug_HitMutekiArray[_HitCheckFlag_Head] = "head";
debug_HitMutekiArray[_HitCheckFlag_Legs] = "legs";
debug_HitMutekiArray[_HitCheckFlag_FireBall] = "fireball";
debug_HitMutekiArray[Def_HitCheckFlag_AirDive] = "dive";
debug_HitMutekiArray[Def_HitCheckFlag_LightLegs] = "l_legs";
debug_HitMutekiArray[_HitCheckFlag_Throw] = "throw";
debug_HitMutekiArray[_HitCheckFlag_Body] = "body";
debug_HitMutekiArray[Def_HitCheckFlag_Ptimer] = "ptimer";
debug_HitMutekiArray[Def_HitCheckFlag_TRUEINV] = "traditional";





Std_MoveTable.Mv_Obj_CheckGuardDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local flags = false;
		//print("\nFrame:"+s.MvCount);
		
		if(s.CallCount==0)
		{
			local p = BMvCore.GetPlayerCharaData(); // 情報を得る
			
			local command = BMvTbl.GetLP(0);
			local commandstr = [["4"],"HIGH"];
			
			switch(command)
			{
				case 1:
					commandstr = [["1"],"LOW"];
					break;
				case 2:
					commandstr = [["<"],"GENERAL"];
					break;
				case 3:
					commandstr = [["<"]"AIR"]
					break;
			}
			
			if( p.IsDone ) // 有効かどうか一応チェック
			{
				BMvCore.PushCharaData( p ); // 
					if( BMvTbl.CheckCommandString( { command=commandstr[0] } ) ) flags = true;
				BMvCore.PopCharaData();
			}
			
			if( flags )
			{
				local frame = (s.MvCount+1);
				Battle_Std.DrawDebugAttackInfo("GUARD LATE "+commandstr[1]+": "+frame+"FRAME" );
				// _dm("投げ抜け:"+frame+"F遅い");
				BMvTbl.SetFinalize(0);
			}
			
			if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
		}
		if(!Battle_Std.CheckPlayerisDamage()) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_ComboMeterDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		//Battle_Std.DrawDebugAttackInfo( "stdmvtblver " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local cpval = BMvTbl.ComboPoint_Calc({});
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = cpval / 100;
					break;
				case 1:
					drawnum = (cpval / 10) % 10;
					break;
				case 2:
					drawnum = cpval % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMeterDmgDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local cv = BMvEff.ComboView_Set();
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = cv / 100;
					break;
				case 1:
					drawnum = (cv / 10) % 10;
					break;
				case 2:
					drawnum = cv % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMinHoseiDisplay_Debug <-
{
	function Init()
	{
		//BMvTbl.AddLP(0, 1);
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{
		local placevalue = BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetPlayerCharaData();
		if(oya.push())
		{
			local pmuki = BMvTbl.GetMuki();
			
			local minhosei = BMvTbl.GetHoseiMinValue();
			
			oya.pop();
			
			local drawnum = 0;
			
			switch(placevalue)
			{
				case 0:
					drawnum = minhosei / 100;
					break;
				case 1:
					drawnum = (minhosei / 10) % 10;
					break;
				case 2:
					drawnum = minhosei % 10;
					break;
			}
			
			BMvTbl.JumpFrameID( drawnum );
			
			BMvTbl.SetPosition( { x=( -180+( ( placevalue * 15 )*pmuki ) )*pmuki, flags=_Position_ToolShift } );
		}
	}
}

Std_MoveTable.Mv_Obj_ComboMeter_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local bs = BMvTbl.GetMvStatus();
			local cp = BMvTbl.ComboPoint_Calc({});
			local cv = BMvEff.ComboView_Set();

			oya.pop();
			/*
				local greenval = cp * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (redval << 16) + (greenval << 8) + ( greenval << 0) )
			*/
			BMvTbl.SetScale( { x=cp*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0x00ffff, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+cv+" cp "+cp + " val "+redval );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_ComboDmgMeter_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local bs = BMvTbl.GetMvStatus();
			local cp = BMvTbl.ComboPoint_Calc({});
			local cv = BMvEff.ComboView_Set();

			oya.pop();
			
			/*
				local greenval = cv * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (redval << 16) + (greenval << 8) + ( 0 << 0) )
			*/
			
			BMvTbl.SetScale( { x=cv*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0x00ff00, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+cv+" red "+redval+" green "+greenval );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_ComboMinHosei_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "he " );
		
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local s = BMvTbl.GetMvStatus();	
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local minhosei = BMvTbl.GetHoseiMinValue();

			oya.pop();
			
			/*
				local greenval = minhosei * 2;
				local redval = 200 - greenval;
				
				local val2 = ( (greenval << 16) + (redval << 8) + ( greenval << 0) )
			*/
			
			BMvTbl.SetScale( { x=minhosei*10000, y=10*10000 } );
			
			BMvEff.SetCharaColor( { color=0xff00ff, time=9999, type=0 } );
			
			//Battle_Std.DrawDebugAttackInfo( "dam "+minhosei );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CharaOrigin_AutoDel_Debug <-
{
	function Init()
	{
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		BMvEff.SetCharaColor( { color=0xffff00, time=9999, type=0 } );
		
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount > 0 ) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CharaOrigin_Debug <-
{
	function Init()
	{
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
	function FrameUpdate()
	{	
		local oya = BMvCore.GetParentCharaData();
		local color = 0xffff00;
		
		if( !oya.isPlayer() ) color = 0xff00ff;
		
		BMvEff.SetCharaColor( { color=color, time=9999, type=0 } );
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_DebugFunctions_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local focus = -1;
		
		local cap = 0;
		local release = 0;
		local enemy = BMvCore.GetEnemyCharaData();
		local oya = BMvCore.GetParentCharaData();
		local p = BMvCore.GetPlayerCharaData();
		local s = BMvTbl.GetMvStatus();
		
		local timestop = BMvTbl.GetLP(3);
		
		local fadvance = 0;
		
		local pstop = 0;
		
		
		

		
		local inputstr = ["@H,D@+0+A","@H,D@+0+B","@H,D@+0+C","@H,D@+2+C","@H,D@+2+A","@H,D@+2+B","@H,D@+4+B","@H,D@+1+B","@H,D@+3+B","@H,D@+06"];
		if(p.push())
		{
		
			local pmvs = BMvTbl.GetMvStatus();
					
			for(local i = 0; i < inputstr.len(); i++)
			{

				
				if( BMvTbl.CheckCommandString( { command=[ inputstr[i] ] } ) )
				{
					
					switch(i)
					{
						case 0:
						BMvEff.Cockpit_SetView( { mode=0 } );
							break;
						case 1:
						BMvEff.Cockpit_SetView( { mode=1 } );
							break;
						case 2:
						Battle_Std.DrawPoint({ objflags=0, procflags=0 });
							break;
						case 3:
						
						cap = 1;
						
							break;
						case 4:
						
						release = 1;
						
							break;
						case 5:
						
						focus = 0;
						
							break;
						case 6:
						
						focus = 1;
						
							break;
						case 7:
						pstop = 1;
							break;
						case 8:
						pstop = 2;
						if(timestop) Battle_Std.DrawDebugAttackInfo( "end stop" );
							break;
						case 9:
						if(timestop)
						{
							fadvance = 1;
							Battle_Std.DrawDebugAttackInfo( "frame "+(pmvs.MvCount+1));
						}
							break;
					}
				}
			}
			
			p.pop();
			
			if(pstop==1) BMvTbl.SetLP(3,1);
			else
			if(pstop==2) BMvTbl.SetLP(3,0)
			
			if (BMvTbl.GetLP(3)==1 && !fadvance)
			{
				if(p.push())
				{
					BMvEff.SetStopTime( { time=2, stopme=1 } );
				}
			}
			
			
			if(cap)
			{
				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					//BMvTbl.SetFinalize(0);
					
				}
			}
			
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p ); //	
					if(cap) BMvTbl.SetPattern(50);
					
					if(cap) BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_RenderShadow } ); //非表示にする
					
					if(release) BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
					
				BMvCore.PopCharaData(); //	
				
				if(focus > -1 ) BMvEff.ThrowChara_SetCamera( focus );
				
				if(release) BMvEff.ThrowRelease( { type=0, airrecover=0 } )
			}
		}
		


	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_CheckHitbox_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		//BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local oya = BMvCore.GetParentCharaData();
		local s = BMvTbl.GetMvStatus();
		if(s.CallCount==0)
		{
			if(oya.push())
			{
				local ps = BMvTbl.GetMvStatus();
				
				if(oya.isPlayer())
				{
					if( oya.isPlayer() ) 
					{
						if(Def_Dbg_DrawHitBox_Outline)
						{
							Battle_Std.DrawHitBoxes_Outlined();
						}
						else
						{
							Battle_Std.DrawHitBoxes();
						}
					}
				}
				else
				{
					if( ps.DataPattern != 0 )
					{
						if(Def_Dbg_DrawHitBox_Outline)
						{
							Battle_Std.DrawHitBoxes_Outlined();
						}
						else
						{
							Battle_Std.DrawHitBoxes();
						}
					}
				}
				
				oya.pop();
			}
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Tuto_CheckInv <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		//BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local flag =  BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetParentCharaData();
		if(oya.push())
		{
			local myhitcheck = BMvTbl.GetHitCheckFlag(1);
			
			Battle_Std.DrawDebugAttackInfo("tutocheck fu "+myhitcheck);
			
			local atkisthrow = Battle_Std.MoveCodeEx.CheckFlag(2, def_MC2_SkillThrow);
			for( local i=0; i<8; i++ ) // compare all hurtboxes to all hitboxes
			{
				for( local b=0; b<8; b++ )
				{
					local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack, i, -1 ], dst=[ _Hantei_Kurai, b, -1 ], flags=_HC_EnemyPc  } );
					
					if( enemy.isdone() )
					{
						Battle_Std.DrawDebugAttackInfo("my hit check "+myhitcheck);
						
						if( enemy.push() )
						{
							local throwmuteki = BMvEff.GetPlayerMuteki( 1 );
							
							Battle_Std.DrawDebugAttackInfo("flags "+BMvTbl.GetHitCheckFlag(0));
							if( BMvTbl.GetHitCheckFlag(0)&flag )
							{
								Battle_Std.DrawDebugAttackInfo("flags confirmed adding mvcode");
								
								Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_TutoBallMuteki );
							}
							
							if(flag==_HitCheckFlag_Throw)
							{
								Battle_Std.DrawDebugAttackInfo("throw check");
								
								if( throwmuteki && myhitcheck&_HitCheckFlag_Throw )
								{
									Battle_Std.DrawDebugAttackInfo("throw confirmed adding mvcode");
								
									Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_TutoBallMuteki );
								}
								
								if( throwmuteki && atkisthrow )
								{
									Battle_Std.DrawDebugAttackInfo("throw confirmed via movecode adding mvcode");
								
									Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_TutoBallMuteki );
								}
							}
							
							enemy.pop();
						}
					}
				}
			}
			
			oya.pop();
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Tuto_CheckBoxRetract <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		//BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function FrameUpdate()
	{
		local box =  BMvTbl.GetLP(0);
		
		local oya = BMvCore.GetNearEnemyCharaData();
		if(oya.push())
		{
			local rccol = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
			local basebox = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai, box ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			local colap = 0;
			
			if(basebox.sx != _Hantei_Error)
			{
				if(rccol != _Hantei_Error)
				{
					if( basebox.ex <  rccol.ex && rccol.ex > 200 )
					{	
						for( local i=0; i<8; i++ ) // compare all hurtboxes to all hitboxes
						{
							for( local b=0; b<8; b++ )
							{
								local col_overlap = BMvEff.CheckHantei( { src=[ _Hantei_Kasanari, 0, -1 ], dst=[ _Hantei_Attack, b, -1 ], flags=_HC_EnemyPc  } );
								local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack, i, -1 ], dst=[ _Hantei_Kurai, b, -1 ], flags=_HC_EnemyPc  } );
								
								if(col_overlap.isdone()) colap = 1;
								
								if( enemy.isdone() )
								{
									colap = 0;
									Battle_Std.DrawDebugAttackInfo("dodge failure");
								}
							}
						}
						
						if( colap )
						{						
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_TutoBallMuteki );
						}
					}
				}
			}
			
			oya.pop();
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_HitboxBox_Debug <-
{
	function Init()
	{
		//BMvTbl.SetLP(1,-1); //hitcheckflag
		
		//BMvTbl.JumpFrameID( 100 );
		
		BMvTbl.SetLP(4,BMvTbl.GetLP(0)); 
	}
	function FrameUpdate()
	{		
		local s = BMvTbl.GetMvStatus();	
		if(s.CallCount==0)
		{
			local oya = BMvCore.GetParentCharaData();
			
			local p_layer = _CharaPrio_GaugeCombo_P1; // _CharaPrio_Near_Layer_0
			local o_layer = _CharaPrio_GaugeCombo_P1;
			
			//Battle_Std.DrawDebugAttackInfo( "flag val "+_CharaPrio_GaugeCombo_P1 );
					
			if(oya.isPlayer())
			{
				BMvTbl.SetPrio( p_layer );
			}
			else
			{
				BMvTbl.SetPrio( o_layer );
			}
			
			if(oya.push())
			{
				local bs = BMvTbl.GetMvStatus();
				
				oya.pop();
				
				if(s.MvCount > 0) BMvTbl.SetFinalize(0);
				
				/*
				
				if( BMvTbl.GetLP(0) != BMvTbl.GetLP(4) )
				{
					BMvTbl.SetFinalize(0); // by doing it here it corrects for mid move frame jumps hopefully
				}

				BMvTbl.SetLP(4,bs.DataFrame);
				
				if( ( BMvTbl.GetLP(0) == BMvTbl.GetLP(4) && bs.isFrameUpdate ) && s.MvCount > 0	 ) BMvTbl.SetFinalize(0); // correct for looping sequences
				*/
			}
		}
		
		//Battle_Std.DrawDebugAttackInfo( "box create val "+BMvTbl.GetLP(0)+" theval "+val );
		
		//if( oya.isPlayer()==0 && BMvTbl.GetLP(1)==0 ) BMvTbl.SetFinalize(0); // correct for created objects
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "box destroy" );
		
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_ErrorCheckObject <-
{
	function Init_Std()
	{
		_dp1p("\n【ErrorCheckObjectの監視あり】")
		
		//LP0 硬直差チェック管理　1:監視中 0:監視してない
		//LP1 硬直差
		//LP2 連携の隙間計算F
		//LP3 Updateタイミングかどうか
		//LP4 boundチェック済みかどうか
	}
	function Update_Std()
	{
		//操作親がつかまれ中である
		//最後に殴られた
		
		//Mv_TukamiErrorCheck not required
		/* 
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
				local bs = BtlMvStd.GetBoundStatus(); //のけぞり情報取得
				if( bs.isCapture ) //操作親が捕まれ中のようだな
				{
					//_dm("つかまれ中ですお");
					local lastenemy = BMvCore.GetLastDamageCharaData(0); //0:そのままの相手を取得 1:殴られた相手の一番親を取得
					if( lastenemy.IsDone )
					{
						BMvCore.PushCharaData( lastenemy ); //掴んでいる相手をpush
							if( BMvTbl.GetPP( def_PP_CaptureCheckObject ) <=0 )
							{
								
								local e = BMvEff.CreateObject( { mvname="Mv_TukamiErrorCheck" } );
								BMvCore.PushCharaData( e );
									BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
									BMvEff.SetExist( { level = _Exist_NoHantei } );
									BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
								BMvCore.PopCharaData();	
								
							}
						BMvCore.PopCharaData(); //掴んでいる相手をpop
					}
					else
					{
						//print("\nつかまれ中だが。最後に殴った人は取得できなかった。（消えてるとか）");
					}
				}
			BMvCore.PopCharaData(); //操作親pop
		}
		*/
	
		//操作親から見てつかみ中の相手がいるとき
		//・やられ判定がある
		//・投げ無敵がついていない（？）
		//・行動可能になったor何らかのキャンセルが可能だ
		//の時はエラーを出す
		local errorcode = 0;
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
				//つかみ中の相手がいるかチェック
				local enemy = BMvCore.GetCaptureCharaData(); //誰か掴んでいるかチェック
				
				//Y==0で落下ベクトルが無い上に判定ツール上で空中だとエラー
				local vec = BMvTbl.GetVector(0);
				local pos = BMvTbl.GetPosition(0);
				local mv = BMvTbl.GetMvName();
				local ignoreMv = ["Mv_WallRecover"];
				local isBound = Battle_Std.CheckPlayerisDamage();
				local mvcheck = function() : (mv,ignoreMv)
				{
					foreach(v in ignoreMv)
					{
						if(mv==v) return false;
					}
					return true;
				};
				//print(format("\n Check: y:%d vec:y pos:%d",pos.y, vec.y, BCMDTbl.CheckPosState( _PosState_Air )))
				if( pos.y==0 && vec.y<=0 && vec.addy<=0 && BCMDTbl.CheckPosState( _PosState_Air ) && mvcheck() && !isBound )
				{
					//こっちはあんまり役に立たなくなった
					//_dem("【警告】Y==0で空中判定");
				}
				if( pos.y<0 && BCMDTbl.CheckPosState( _PosState_Ground ) && mvcheck() && !isBound )
				{
					_dem("【警告】Y<0で地上判定");
				}
			BMvCore.PopCharaData(); //操作親pop
		}
		
		
		//・やられ判定か重なり判定が無い
		//・行動可能
		//の時はエラー
		if( oya.IsDone )
		{
			if( BMvCore.PushCharaData( oya ) )
			{
				local oya_ismoveable = ( BCMDTbl.CheckCancel( _SkillType_None ) > 0 );
				if( oya_ismoveable )
				{
					local existKuraiRect = false;
					for( local i=0; i<8; i++ )
					{
						local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
						if( rc.sx != _Hantei_Error )
						{
							existKuraiRect = true;
							break;
						}
					}
					if( !existKuraiRect ) _dem("【警告】行動可能なのに食らい判定が無いです");
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=_HanteiFlag_Tool } );
					if( rc.sx == _Hantei_Error )
					{
						_dem("【警告】行動可能なのに重なり判定が無いです");
					}
				}
			}
			BMvCore.PopCharaData();
		}		

		BMvTbl.SetLP(3,1); //Updateタイミングです
	}
	function FrameUpdate_Std()
	{
		//キーディスプレイが無いのでここで何となく表示しよう
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		BMvCore.PushCharaData( player ); // 情報push
			local plside = BMvTbl.GetPlayerSide(); //プレイヤーサイド
			if( (Def_Dbg_KeyLog1P && plside==0) || (Def_Dbg_KeyLog2P && plside==1) )
			{
				// 4 A B C D
				local stick = 0;
				if( BMvTbl.CheckStickHold( (1<<4) ) ) stick = 4;
				if( BMvTbl.CheckStickHold( (1<<7) ) ) stick = 7;
				if( BMvTbl.CheckStickHold( (1<<8) ) ) stick = 8;
				if( BMvTbl.CheckStickHold( (1<<9) ) ) stick = 9;
				if( BMvTbl.CheckStickHold( (1<<6) ) ) stick = 6;
				if( BMvTbl.CheckStickHold( (1<<3) ) ) stick = 3;
				if( BMvTbl.CheckStickHold( (1<<2) ) ) stick = 2;
				if( BMvTbl.CheckStickHold( (1<<1) ) ) stick = 1;

				local button = ["-","-","-","-"];
				if( BMvTbl.CheckButtonHold( (1<<0) ) ) button[0] = "A";
				if( BMvTbl.CheckButtonHold( (1<<1) ) ) button[1] = "B";
				if( BMvTbl.CheckButtonHold( (1<<2) ) ) button[2] = "C";
				if( BMvTbl.CheckButtonHold( (1<<3) ) ) button[3] = "D";
				
				_dp( "\n"+plside+" "+stick+" "+button[0]+" "+button[1]+" "+button[2]+" "+button[3] );
			}
		BMvCore.PopCharaData(); // 情報を戻す	
	
	
		local update = ( BMvTbl.GetLP(3)==1 );
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( update )
		{
			//自分が行動可能
			//相手が行動不能 = +1
			local enemy_moveable = false;
			local oya_moveable = false;
			local enemy_bound = false;
			
			local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( oya.IsDone )
			{
				BMvCore.PushCharaData( oya ); //操作親push
					oya_moveable = (BCMDTbl.CheckCancel( _SkillType_None ) >0 );
				BMvCore.PopCharaData(); //操作親pop
			}

			local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); //操作親push
					//local enemy_moveable = (BCMDTbl.CheckCancel( _SkillType_None ) >0 );
					local bs = BtlMvStd.GetBoundStatus();
					local e_bound = (bs.isDone!=0);
					//if( e_bound ) enemy_moveable=false;
	//				local enemy_moveable = ( !e_bound );
					enemy_moveable = ( !e_bound && (BCMDTbl.CheckCancel( _SkillType_None ) >0 ) );

					if( bs.isBound == 1 || bs.isCapture != 0 ) enemy_bound = true;
				BMvCore.PopCharaData(); //操作親pop		
			}
		
			if( oya_moveable && enemy_moveable )
			{
				BMvTbl.SetLP(2,0); //隙間リセット
				//BMvTbl.SetLP(5,0); //隙間リセット
			}

			//両者行動不能ならリセットなんだな
			if( !oya_moveable && !enemy_moveable )
			{
				local sukima = BMvTbl.GetLP(2);
				if( sukima>0 && Def_Dbg_InterruptedLog)
				{
					Battle_Std.DrawDebugAttackInfo("Interrupted: "+sukima+"F");
					_dp("\n隙間:"+sukima);
					
					local enemy = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
					if( enemy.IsDone )
					{
						BMvCore.PushCharaData( enemy ); //操作親push
							//_dm("隙間:"+sukima);
							Battle_Std.DrawDebugAttackInfo("Breaking: "+sukima+"F");
						BMvCore.PopCharaData(); //操作親pop		
					}
				}
				//互角か・・・
				BMvTbl.SetLP(0,0); //チェックしない
				BMvTbl.SetLP(1,0); //硬直差リセット
				BMvTbl.SetLP(2,0); //隙間リセット				
			}		

			//自分と相手が行動可能になるとフラグが折れてチェック終了
			local flag = (BMvTbl.GetLP(0)==1); //1ならフラグたってる
			

			//フラグがたってなくて、自分と相手が行動不能だとフラグがたってチェック開始
			if( !flag )
			{
				//行動可能かどうかチェック
				if( !oya_moveable && !enemy_moveable )
				{
					BMvTbl.SetLP(0,1); //チェック開始
					BMvTbl.SetLP(1,0); //硬直差リセット
					BMvTbl.SetLP(2,0); //隙間リセット
					BMvTbl.SetLP(4,1); //チェック開始
				}
			}
			flag = (BMvTbl.GetLP(0)==1); //1ならフラグたってる
			
			//BMvTbl.GetPlayerSide()==0
			if( flag ) //フラグがたっている時の処理
			{
				if( oya_moveable && !enemy_bound && BMvTbl.GetLP(4)==1 )
				{
					BMvTbl.SetLP(4,0); //チェック済み
					//結果を出力
					local sa = BMvTbl.GetLP(1); //硬直差取得
					if( sa>0 && Def_Dbg_ComboChanceLog )
					{
						Battle_Std.DrawDebugAttackInfo("ComboFrame: "+sa+"F");					
						_dp1p("\n追撃可能フレーム："+sa);
					}
				}

				if( oya_moveable && enemy_moveable )
				{
					BMvTbl.SetLP(0,0); //チェック終了
					//結果を出力
					local sa = BMvTbl.GetLP(1); //硬直差取得
					local str = "";
					local str2 = "";
					//Updateタイミングなので1F遅いのでこうする
					if( sa> 0 )
					{
						//sa--;
						str="Plus:";
					}
					else if( sa< -0 )
					{
						//sa++;
						str="Minus:";
					}
					else
					{
						//sa=0;
						str="Draw:";
					}
					if( Def_Dbg_KoukaFrameLog )
					{
						_dp1p("\n硬直差："+sa);
					}
					Battle_Std.DrawDebugAttackInfo(str+" "+sa+"F "+str2);
				}		
				else if( oya_moveable )
				{
					//print("\n+1");
					BMvTbl.AddLP(1,1); //+1F					
				}
				else if( enemy_moveable )
				{
					//print("\n-1");
					BMvTbl.AddLP(1,-1); //-1F					
					
					BMvTbl.AddLP(2,1); //1F隙間がある
				}

			}
			
			BMvTbl.SetLP(3,0); //Updateタイミングフラグ消し
		}
	
	}
	function Finalize_Std()	
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_CheckStarupFrame_Debug <-
{
	function getlp5flag( flag )
	{
		return ( (BMvTbl.GetLP(5)&flag) != 0 );
	}
	function setlp5flag( flag )
	{
		BMvTbl.SetLP(5, BMvTbl.GetLP(5)|flag );
	}
	function Init()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 : フレームオフセット
		
		//LP1 : 発生Fを記憶
		BMvTbl.SetLP(1,-1);
		
		//LP2 : 全体Fを記憶
		BMvTbl.SetLP(2,-1);
		
		//LP3 : 初段の持続Fを記憶
		BMvTbl.SetLP(3,-1);		
		
		//LP4 : 初段からの硬直Fを記憶
		BMvTbl.SetLP(4,-1);
		
		//LP5 : 適当なフラグ関係
		BMvTbl.SetLP(5,0);
		// 1<<0 : 一度でも空中にとんだ
		// 1<<1 : 空中で行動可能になった
		
		//LP6 : 地上の硬直Fだけを記憶
		BMvTbl.SetLP(6,-1);
		
		//LP7 : 発動時の行動コード
		BMvTbl.SetLP(7,0);
		
		//行動コードを記憶
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local mvcode = 0;
		if( player.IsDone )
		{
			if( BMvCore.PushCharaData( player ) )
			{
				mvcode = BMvTbl.GetMoveCode();
			}
			BMvCore.PopCharaData();
		}
		BMvTbl.SetLP(7,mvcode);
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>600 )
		{
			BMvTbl.SetFinalize(0); //長すぎ
			return;
		}
		
		if( 1 ){
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				// 除外Mvがあるんだ
				local mvname = BMvTbl.GetMvName();
				local bs = BtlMvStd.GetBoundStatus();
				player.pop();
				
				if( bs.isDone || mvname=="Mv_ComboBlastWait" || mvname=="Mv_Convert" )
				{
					//_dp("\n もうちぇっくしない");
					BMvTbl.SetFinalize(0); //もうチェックしない
					return;
				}
			}
		}
		
		local endflag = false;
		//操作親の攻撃判定出現をチェック
		if( BMvTbl.GetLP(1) == -1 ) //まだ発生測定終わってない
		{
			local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc   } );
			local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourObj   } );
			if( e_pc.IsDone || e_obj.IsDone )
			{
				local off = BMvTbl.GetLP(0);
				local s_frame = (s.MvCount-1+off);
				//Battle_Std.DrawDebugAttackInfo("StartUp: "+s_frame+"F");			
				//
				//_dm("発生F:"+s_frame );
				BMvTbl.SetLP(1,s_frame);
				//endflag = true;
			}
		}
		else if( BMvTbl.GetLP(3)==-1 ) //まだ持続測定終わってない
		{
			local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc   } );
			local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourObj   } );
			if( e_pc.IsDone || e_obj.IsDone )
			{
				//持続中
			}
			else
			{
				//local off = BMvTbl.GetLP(0);
				local z_frame = s.MvCount - BMvTbl.GetLP(1);
				
				//_dm("持続F:"+z_frame );
				BMvTbl.SetLP(3,z_frame);
			}		

		}
		else
		{
			local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc   } );
			local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourObj   } );
			
			if( (e_pc.IsDone || e_obj.IsDone) && Def_Dbg_ExFrameLog==1 )
			{
				//Battle_Std.DrawDebugAttackInfo("occ2");
				//Battle_Std.DrawDebugAttackInfo( strhitchk );
				
				BMvTbl.SetLP(4,s.MvCount-BMvTbl.GetLP(3)-BMvTbl.GetLP(1));
				
				BMvTbl.SetLP(2,s.MvCount);
				
				local out = format("%d %d %d (%d)",BMvTbl.GetLP(1)+1,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2),BMvTbl.GetLP(6));
				
				Battle_Std.DrawDebugAttackInfo( out );
				
				//LP1 : 発生Fを記憶
				BMvTbl.SetLP(1,s.MvCount);
				
				//LP2 : 全体Fを記憶
				BMvTbl.SetLP(2,-1);
				
				//LP3 : 初段の持続Fを記憶
				BMvTbl.SetLP(3,-1);		
				
				//LP4 : 初段からの硬直Fを記憶
				BMvTbl.SetLP(4,-1);
				
				//LP5 : 適当なフラグ関係
				BMvTbl.SetLP(5,0);
				// 1<<0 : 一度でも空中にとんだ
				// 1<<1 : 空中で行動可能になった
				
				//LP6 : 地上の硬直Fだけを記憶
				BMvTbl.SetLP(6,-1);
				
				//LP7 : 発動時の行動コード
				BMvTbl.SetLP(7,0);
				
				BMvTbl.SetLP(10,-1);
				BMvTbl.SetLP(12,-1);
				
			}
		}			

		
		
		if( BMvTbl.GetLP(2) == -1 )
		{
			//行動可能になるまでのフレームを記憶
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local move = 0; //行動可能かどうか
			local isGround = 0; //地上かかどうか
			
			if( player.IsDone )
			{
				BMvCore.PushCharaData( player );
					if( BCMDTbl.CheckCancel( _SkillType_None ) )
					{
						move = 1; //行動可能だな
					}
					isGround = (BCMDTbl.CheckPosState(_PosState_Ground )!=0);
				BMvCore.PopCharaData();
				
				//行動可能になったら硬直Fと全体Fを記録する
				if( move )
				{
					local off = BMvTbl.GetLP(0);
					local t_frame = (s.MvCount-1+off); //全体F
					//_dm("全体F:"+t_frame );
					BMvTbl.SetLP(2,t_frame);
					
					if( !isGround )
					{
						setlp5flag( (1<<1) ); //空中で行動可能になった
					}

					local k_frame = t_frame - BMvTbl.GetLP(3) - BMvTbl.GetLP(1);
					//_dm("硬直F:"+k_frame);
					BMvTbl.SetLP(4,k_frame);
					
					
					//endflag = true;
				}
				else //行動不能の時
				{
					if( isGround )
					{
						BMvTbl.AddLP(6,1);
					}
					else
					{
						setlp5flag( (1<<0) ); //一度でも空中に浮いた
						BMvTbl.SetLP(6,0);
					}
				}
			}
		}
		
		if( ( BMvTbl.GetLP(1) != -1 ) && ( BMvTbl.GetLP(2) != -1 ) && ( BMvTbl.GetLP(3) != -1 ) )
		{
						
			local out = "";
			local a_out = ""; //アナウンス用
			if( getlp5flag( (1<<0) ) ) //一度でも浮いた技
			{
				out = format("\n発:%dF 持:%dF 硬:%dF 着:%dF 全:%dF",BMvTbl.GetLP(1)+1,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(6),BMvTbl.GetLP(2));
				a_out = format("%d %d %d (%d) L:%d",BMvTbl.GetLP(1)+1,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2),BMvTbl.GetLP(6));
				
				if( getlp5flag( (1<<1) ) ) //空中で行動可能になった技
				{
					out += " (空中で行動可)";
				}
				else
				{
					if( BMvTbl.GetLP(6)==0 && ( (BMvTbl.GetLP(7)&def_MC_Atk) == 0 ) ) //通常技は除外
					{
						local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
						if( player.push() )
						{
							if( BCMDTbl.CheckCancel( _SkillType_None ) )
							{
								_dem("【警告】着地硬直がありません");
							}
							
							player.pop();
						}
					}
				}
			}
			else
			{
				out = format("\n発:%dF 持:%dF 硬:%dF 全:%dF",BMvTbl.GetLP(1)+1,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2));
				a_out = format("%d %d %d (%d)",BMvTbl.GetLP(1)+1,BMvTbl.GetLP(3),BMvTbl.GetLP(4),BMvTbl.GetLP(2));
				
				if( getlp5flag( (1<<1) ) ) //空中で行動可能になった技
				{
					out += " (空中で行動可)";
				}				
			}
			if( Def_Dbg_TotalFrameLog )
			{
				_dp(out);
				Battle_Std.DrawDebugAttackInfo( a_out );
			}
			endflag = true;
		}
		
		if( endflag )
		{
			BMvTbl.SetFinalize(0);
			return;		
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


Std_MoveTable.Mv_Obj_CheckStartupFrameAlternate_Debug <-
{
	function clear_lp()
	{
		BMvTbl.SetLP(0,-1); //startup
		BMvTbl.SetLP(1,0); //active
		BMvTbl.SetLP(2,-1); //recovery
		BMvTbl.SetLP(3,-1); //p mvcnt
		BMvTbl.SetLP(4,0); //isobj
		BMvTbl.SetLP(5,0); //obj mvcount
		
		
		BMvTbl.SetLP(6,0); //reset
	}
	function draw_info(pre_string = "")
	{				
		local startup = BMvTbl.GetLP(0) + 1;
		local active = BMvTbl.GetLP(1);
		local recovery = BMvTbl.GetLP(2) - 1;
		local total = BMvTbl.GetLP(3);
		
		if(BMvTbl.GetLP(4)==0) startup += 1;
		
		local out = pre_string + format("%d %d %d (%d)",startup,active,recovery,total,0);
		
		//out += " isobj? "+BMvTbl.GetLP(4);
		
		//out += " "+Battle_Std.GetPlayerMvName();
		
		if( active > 0 ) Battle_Std.DrawDebugAttackInfo(out);
	}
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		local re_occ = 0;
		
		if( mvs.CallCount==1 )
		{
			local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourPc   } );
			local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Kurai, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_FavourObj   } );
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local p_mvs = BMvTbl.GetMvStatus();
				local atk_rect = BMvEff.IsAttackRect();
				local oc = BMvEff.GetMyObjectCount();
				
				local p_stoptime = BMvEff.IsMyStopTime();
				
				local p_move = ( BCMDTbl.CheckCancel( _SkillType_None ) > 0 );
				
				player.pop();
				
				//Battle_Std.DrawDebugAttackInfo("frame "+p_mvs.MvCount+" atkrect "+atk_rect+" myframe "+mvs.MvCount);
							
				if( !p_stoptime && BMvTbl.GetLP(1)==0 ) BMvTbl.AddLP(0,1); //startup minus stoptime
				
				//Battle_Std.DrawDebugAttackInfo("start "+BMvTbl.GetLP(0)+" act "+BMvTbl.GetLP(1)+" mv "+p_move );
				
				if( !p_stoptime ) BMvTbl.AddLP(3,1); //total mvcount minus stoptime
				
				if( e_pc.push() )
				{
					local pc_mvs = BMvTbl.GetMvStatus();
					
					e_pc.pop();
					
					//Battle_Std.DrawDebugAttackInfo("pushtime "+p_mvs.MvCount+" mycount "+BMvTbl.GetLP(0));
					
					if( BMvTbl.GetLP(2) > 0 ) 
					{
						re_occ = 1;
						
						local startup = BMvTbl.GetLP(0) + 1;
						local recovery = BMvTbl.GetLP(2) + 1;
						local total = BMvTbl.GetLP(3);
						
						BMvTbl.AddLP(2,2); //correct incorrect recovery
						
						draw_info("reocc pc " );
						//Battle_Std.DrawDebugAttackInfo("reocc "+startup+" "+active+" "+recovery+" "+total);
						
						
						clear_lp();
						
						//Battle_Std.DrawDebugAttackInfo("reoccfo "+recovery);
						
						BMvTbl.SetLP(0,startup+recovery+1);
						BMvTbl.SetLP(3,0);
						
						if(!p_stoptime) BMvTbl.AddLP(1,1);

					}
					else
					{
						if(!p_stoptime) BMvTbl.AddLP(1,1); //active frames
					}
					
											
					BMvTbl.SetLP(4,0); //is not obj

					//Battle_Std.DrawDebugAttackInfo("pl push frame "+p_mvs.MvCount);
				}
				else if( BMvTbl.GetLP(1) > 0 && !e_obj.isdone() )
				{
					BMvTbl.AddLP(2,1); //recovery frames
				}
				
				if( e_obj.push() )
				{
					if(!p_move )
					{
						local obj_mvs = BMvTbl.GetMvStatus();
						local obj_stoptime = BMvEff.IsMyStopTime();
						local obj_hs = BMvTbl.GetMvHitStatus();
						
						//BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop } );
						
						e_obj.pop();
								
						
						
						local o_cnt = BMvTbl.GetLP(5);
						
						BMvTbl.SetLP(5,obj_mvs.MvCount);
						
						local o_cnt_c = obj_mvs.MvCount;
						
						//Battle_Std.DrawDebugAttackInfo("hs "+obj_hs.Count+" cc "+obj_mvs.MvCount);

						//if( BMvTbl.GetLP(1)==0 ) BMvTbl.AddLP(0,-1); //correct wrong startup for nonplayer obj
						
						if( BMvTbl.GetLP(2) > 0 ) 
						{
							re_occ = 1;
							
							local startup = BMvTbl.GetLP(0) + 1;
							local recovery = BMvTbl.GetLP(2) + 1;
							local total = BMvTbl.GetLP(3);
							
							BMvTbl.AddLP(2,2); //correct incorrect recovery
							
							draw_info("reocc obj ");
							
							//Battle_Std.DrawDebugAttackInfo("obj reocc "+startup+" "+active+" "+recovery+" "+total);
							
							clear_lp();
							BMvTbl.SetLP(0,startup+recovery+1);
							BMvTbl.SetLP(3,0);
							
							if( !p_stoptime && o_cnt != o_cnt_c ) BMvTbl.AddLP(1,1);

						}
						else
						{
							if(!p_stoptime && o_cnt != o_cnt_c ) BMvTbl.AddLP(1,1); //active frames
						}
						
						BMvTbl.SetLP(4,1); //isobj
					}
					else if( BMvTbl.GetLP(1) > 0 && !e_pc.isdone() )
					{
						e_obj.pop();
						//BMvTbl.AddLP(2,1); //recovery frames
					}
					else
					{
						e_obj.pop();
					}
				}

				
				
				if( BMvTbl.GetLP(6)==1 )
				{
					//draw_info();
					//clear_lp();
				}
				
				//Battle_Std.DrawDebugAttackInfo("oc "+p_mvs.MvCount);
				
				//if( ( p_move || re_occ ) )
				
				if( BMvTbl.GetLP(6) )
				{
					//BMvTbl.SetLP(6,1);
					
					//if(BMvTbl.GetLP(0) > 0 ) Battle_Std.DrawDebugAttackInfo("d "+p_move+" cnt "+mvs.MvCount+" pmvcnt "+BMvTbl.GetLP(3)+" 2 "+p_mvs.MvCount );
					//BMvTbl.AddLP(0,1);
					
					if( 1 )
					{
						//BMvTbl.AddLP(3,p_mvs.MvCount);
						if( !re_occ ) draw_info();
					
						if( re_occ )
						{
						}
						else
						{
							clear_lp();
						}
					}
				}
			}
		}
		else
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local p_mvs = BMvTbl.GetMvStatus();
				local p_move = ( BCMDTbl.CheckCancel( _SkillType_None ) > 0 );
				
				player.pop();
				
				if( p_move ) BMvTbl.SetLP(6,1);
				else
				{
					BMvTbl.SetLP(6,0);
				}
				
				//Battle_Std.DrawDebugAttackInfo("ocdz "+p_mvs.MvCount);
			}
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.CallCount==0 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Obj_CheckStartupFrameAlternate_Debug" );
	}	
}



Std_MoveTable.Mv_Obj_CheckState_Debug <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 : フレームオフセット
		
		//LP1 : 発生Fを記憶
		BMvTbl.SetLP(1,-1);
		
		//LP2 : 全体Fを記憶
		BMvTbl.SetLP(2,-1);
		
		//LP3 : 初段の持続Fを記憶
		BMvTbl.SetLP(3,-1);		
		
		//LP4 : 初段からの硬直Fを記憶
		BMvTbl.SetLP(4,-1);
		
		//LP5 : 適当なフラグ関係
		BMvTbl.SetLP(5,-1);
		// 1<<0 : 一度でも空中にとんだ
		// 1<<1 : 空中で行動可能になった
		
		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//last state
		BMvTbl.SetLP(9,0);
		
		//行動コードを記憶
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local mvcode = 0;
		if( player.IsDone )
		{
			if( BMvCore.PushCharaData( player ) )
			{
				mvcode = BMvTbl.GetMoveCode();
			}
			BMvCore.PopCharaData();
		}
		//BMvTbl.SetLP(7,mvcode);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>600 )
		{
			BMvTbl.SetFinalize(0); //長すぎ
			return;
		}
		
		if( 1 ){
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				// 除外Mvがあるんだ
				local mvname = BMvTbl.GetMvName();
				local bs = BtlMvStd.GetBoundStatus();
				player.pop();
				
				if( bs.isDone || mvname=="Mv_ComboBlastWait" || mvname=="Mv_Convert" )
				{
					//_dp("\n もうちぇっくしない");
					BMvTbl.SetFinalize(0); //もうチェックしない
					return;
				}
			}
		}
		
		local endflag = false;
		//操作親の攻撃判定出現をチェック
		
		
		if( BMvTbl.GetLP(2) == -1 )
		{
			//行動可能になるまでのフレームを記憶
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local move = 0; //行動可能かどうか
			local isGround = 0; //地上かかどうか
			local isStand = 0; //地上かかどうか
			local isCrouch = 0; //地上かかどうか
			local isAir = 0; //地上かかどうか
			
			if( player.IsDone )
			{
				BMvCore.PushCharaData( player );
					if( BCMDTbl.CheckCancel( _SkillType_None ) )
					{
						move = 1; //行動可能だな
					}
					isGround = (BCMDTbl.CheckPosState(_PosState_Ground )!=0);
					isStand = (BCMDTbl.CheckPosState(_PosState_Stand )!=0);
					isCrouch = (BCMDTbl.CheckPosState(_PosState_Crouch )!=0);
					isAir = (BCMDTbl.CheckPosState(_PosState_Air )!=0);
				BMvCore.PopCharaData();
				
				//行動可能になったら硬直Fと全体Fを記録する
				if( move )
				{
					local off = BMvTbl.GetLP(0);
					local t_frame = (s.MvCount); //全体F
					//_dm("全体F:"+t_frame );
					BMvTbl.SetLP(2,t_frame);
					
				}
				else //行動不能の時
				{
					local t_frame2 = (s.MvCount); //全体F
					
					local laststate = BMvTbl.GetLP(9);
					
					if(s.CallCount == 0)
					{
					
					
					
					
					if( (isStand || isCrouch) && laststate == 3 )
					{
					
						local str = "";
						
						local off = 1;
			
						local tf2 = BMvTbl.GetLP(2);
			
						local stand = BMvTbl.GetLP(3)+off;
						local crouch = BMvTbl.GetLP(4)+off;
						local air = BMvTbl.GetLP(5)+off;
			
						local standst = BMvTbl.GetLP(6)+off;
						local crouchst = BMvTbl.GetLP(7)+off;
						local airst = BMvTbl.GetLP(8)+off;
						
						BMvTbl.SetLP(9,0);
						BMvTbl.SetLP(8,-1);
						BMvTbl.SetLP(7,-1);
						BMvTbl.SetLP(6,-1);
						BMvTbl.SetLP(5,-1);
						BMvTbl.SetLP(4,-1);
						BMvTbl.SetLP(3,-1);
						
						
						if( stand > 0) str+= "stand: "+standst+"-"+stand+" ";
						if( crouch > 0) str+= "crouch: "+crouchst+"-"+crouch+" ";
						if( air > 0) str+= "air: "+airst+"-"+air+" ";
						
						
						//Battle_Std.DrawDebugAttackInfo( "stand: "+standst+"-"+stand+" "+"crouch: "+crouchst+"-"+crouch+" "+"air: "+airst+"-"+air+" ");
						
						Battle_Std.DrawDebugAttackInfo( str );
					
					}
					
					if( isStand )
					{
						if( BMvTbl.GetLP(6) == -1 )
						{
							BMvTbl.SetLP(6, t_frame2);
							BMvTbl.SetLP(3, t_frame2);
							
							BMvTbl.SetLP(9,1);
							
							local ga = BMvTbl.GetLP(6);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(6) != -1 && BMvTbl.GetLP(8) == -1)
						{
							BMvTbl.AddLP(3,1);
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					if( isCrouch )
					{
						if( BMvTbl.GetLP(7) == -1 )
						{
							BMvTbl.SetLP(7, t_frame2);
							BMvTbl.SetLP(4, t_frame2);
							
							BMvTbl.SetLP(9,2);
							
							//local ga = BMvTbl.GetLP(7);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(7) != -1 && BMvTbl.GetLP(8) == -1)
						{
							BMvTbl.AddLP(4,1);
							
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					if( isAir )
					{
						if( BMvTbl.GetLP(8) == -1 )
						{
							BMvTbl.SetLP(8, t_frame2);
							BMvTbl.SetLP(5, t_frame2);
							
							BMvTbl.SetLP(9,3);
							
							//local ga = BMvTbl.GetLP(8);
							
							//Battle_Std.DrawDebugAttackInfo( "smaller/notset so tframe "+ga );
						}
						else if( BMvTbl.GetLP(8) != -1)
						{
							BMvTbl.AddLP(5,1);
							
							//local ge = BMvTbl.GetLP(3);
							
							//Battle_Std.DrawDebugAttackInfo( "greater so add "+ge );
						}
					}
					
					}
				}
			}
		}
		
		
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
			BMvCore.PopCharaData(); //操作親pop
		}
		
		//Battle_Std.DrawDebugAttackInfo( hitst.Count );
		
		
		//if( hitst )Battle_Std.DrawDebugAttackInfo( "hit" );
		
		//Battle_Std.DrawDebugAttackInfo( "cando "+norcanfr);
		
		if( BMvTbl.GetLP(2) != -1 )
		{
		
			local str = "";
			
			local off = 1;
			
			local tf2 = BMvTbl.GetLP(2);
			
			local stand = BMvTbl.GetLP(3)+off;
			local crouch = BMvTbl.GetLP(4)+off;
			local air = BMvTbl.GetLP(5)+off;
			
			local standst = BMvTbl.GetLP(6)+off;
			local crouchst = BMvTbl.GetLP(7)+off;
			local airst = BMvTbl.GetLP(8)+off;
			
			
			
			if( stand > 0) str+= "stand: "+standst+"-"+stand+" ";
			if( crouch > 0) str+= "crouch: "+crouchst+"-"+crouch+" ";
			if( air > 0) str+= "air: "+airst+"-"+air+" ";
			
			
			//Battle_Std.DrawDebugAttackInfo( "stand: "+standst+"-"+stand+" "+"crouch: "+crouchst+"-"+crouch+" "+"air: "+airst+"-"+air+" ");
			
			Battle_Std.DrawDebugAttackInfo( str );
			
			endflag = true;
		}
		
		if( endflag )
		{
			BMvTbl.SetFinalize(0);
			return;		
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}



Std_MoveTable.Mv_Obj_CheckCancel_Debug <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 : フレームオフセット
		
		//LP1 : normal cancel
		BMvTbl.SetLP(1,-1);
		
		//LP2 : special cancel
		BMvTbl.SetLP(2,-1);
		
		//LP3 : exspecial cancel
		BMvTbl.SetLP(3,-1);		
		
		//LP4 : 初段からの硬直Fを記憶
		BMvTbl.SetLP(4,-1);
		
		//LP5 : 適当なフラグ関係
		BMvTbl.SetLP(5,-1);
		// 1<<0 : 一度でも空中にとんだ
		// 1<<1 : 空中で行動可能になった
		
		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//ismove
		BMvTbl.SetLP(9,-1);
		
		//行動コードを記憶
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		local mvcode = 0;
		if( player.IsDone )
		{
			if( BMvCore.PushCharaData( player ) )
			{
				mvcode = BMvTbl.GetMoveCode();
			}
			BMvCore.PopCharaData();
		}
		//BMvTbl.SetLP(7,mvcode);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>600 )
		{
			BMvTbl.SetFinalize(0); //長すぎ
			return;
		}
		
		if( 1 ){
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				// 除外Mvがあるんだ
				local mvname = BMvTbl.GetMvName();
				local bs = BtlMvStd.GetBoundStatus();
				player.pop();
				
				if( bs.isDone || mvname=="Mv_ComboBlastWait" || mvname=="Mv_Convert" )
				{
					//_dp("\n もうちぇっくしない");
					BMvTbl.SetFinalize(0); //もうチェックしない
					return;
				}
			}
		}
		
		local endflag = false;
		//操作親の攻撃判定出現をチェック
		
		
		if( BMvTbl.GetLP(1) == -1 || BMvTbl.GetLP(2) == -1 || BMvTbl.GetLP(3) == -1 )
		{
			//行動可能になるまでのフレームを記憶
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			local move = 0; //行動可能かどうか
			local CancelFlagN = 0; //地上かかどうか
			local CancelFlagS = 0; //地上かかどうか
			local CancelFlagEXS = 0; //地上かかどうか
			local isAir = 0; //地上かかどうか
			local ene = 0;
			
			if( player.IsDone )
			{
				BMvCore.PushCharaData( player );
					if( BCMDTbl.CheckCancel( _SkillType_None ) )
					{
						move = 1; //行動可能だな
					}
					CancelFlagN = BCMDTbl.CheckCancel( _SkillType_Normal ) >0;
					CancelFlagS = BCMDTbl.CheckCancel( _SkillType_Special ) >0;
					CancelFlagEXS = BCMDTbl.CheckCancel( _SkillType_ExSpecial ) >0;
				BMvCore.PopCharaData();
				
				//行動可能になったら硬直Fと全体Fを記録する
				if( move )
				{
					local t_frame = (s.MvCount); //全体F
					//_dm("全体F:"+t_frame );
					BMvTbl.SetLP(9,1);
					
				}
				else //行動不能の時
				{
					local t_frame2 = (s.MvCount); //全体F
					
					local laststate = BMvTbl.GetLP(9);
					
					if(s.CallCount == 0)
					{
					
						if(CancelFlagN)
						{
							BMvTbl.AddLP(1,1);
						}
						if(CancelFlagS)
						{
							BMvTbl.AddLP(2,1);
						}
						if(CancelFlagEXS && !CancelFlagS)
						{
							BMvTbl.AddLP(3,1);
						}
					
					}
				}

			}

		}
		
		
		local oya = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( oya.IsDone )
		{
			BMvCore.PushCharaData( oya ); //操作親push
			BMvCore.PopCharaData(); //操作親pop
		}
		
		//Battle_Std.DrawDebugAttackInfo( hitst.Count );
		
		
		//if( hitst )Battle_Std.DrawDebugAttackInfo( "hit" );
		
		//Battle_Std.DrawDebugAttackInfo( "cando "+norcanfr);
		
		if( BMvTbl.GetLP(9) != -1 )
		{
		
			local str = "";
			
			local N = BMvTbl.GetLP(1)+1; //カウンタ取得
			
			local S = BMvTbl.GetLP(2)+1; //カウンタ取得
			
			local EXS = BMvTbl.GetLP(3)+1; //カウンタ取得
			
			if( N > 0) str+= "Normal: "+N+" ";
			if( S > 0) str+= "Special: "+S+" ";
			if( EXS > 0) str+= "EX: "+EXS+" ";
			
			if(str != "") Battle_Std.DrawDebugAttackInfo( str );
			
			endflag = true;
		}
		
		if( endflag )
		{
			BMvTbl.SetFinalize(0);
			return;		
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CheckInvuln_Debug <-
{
	function Init()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );

		BMvTbl.SetLP(1,-1); //hitcheckflag
		

		BMvTbl.SetLP(2,-1); //hitcheck start
		

		BMvTbl.SetLP(3,-1);		
		

		BMvTbl.SetLP(4,-1);
		
		BMvTbl.SetLP(5,-1);

		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//thing
		//BMvTbl.SetLP(9,0);
	}
	function FrameUpdate() : (debug_HitMutekiArray)
	{
		
		local player = BMvCore.GetPlayerCharaData();
		local s = BMvTbl.GetMvStatus();	
		
		local playerpat = 0;	
		
		local move = 0;
		
		local finalizeflag = 0;
		
		local hitcheck = BMvTbl.GetHitCheckFlag(0); //current hitcheck invulnerability flag
		
		local TInvuln = 0; // actually the number of hurtboxes
		
		local off = 1;

		//local Def_HitCheckFlag_TRUEINV = 256;
		
		local str = "";
		
		local code = 0;
		
		if( player.IsDone )
		{
			
			BMvCore.PushCharaData( player );
				hitcheck = BMvTbl.GetHitCheckFlag(0);
				local throwmuteki = BMvEff.GetPlayerMuteki( 1 ); // throw inv
				local bodymuteki = BMvEff.GetPlayerMuteki( 0 ); // ptimer body inv
				local ps = BMvTbl.GetMvStatus();
				
				code = BMvTbl.FromFinalize();
				
				if( BCMDTbl.CheckCancel( _SkillType_None ) )
				{
					move = 1; //行動可能だな
				}
				local existKuraiRect = false;
				for( local i=0; i<8; i++ )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error )
					{
						TInvuln++; //add them up ( hurtboxes )
					}
					//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
				}
			BMvCore.PopCharaData();
			
			if( throwmuteki ) hitcheck += _HitCheckFlag_Throw;
			if( bodymuteki ) hitcheck += Def_HitCheckFlag_Ptimer;
			//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
			
			playerpat = ps.DataPattern;
		}
		
		if( TInvuln == 0 ) hitcheck += Def_HitCheckFlag_TRUEINV;
		
		//Battle_Std.DrawDebugAttackInfo( "inv n "+hitcheck );
		//Battle_Std.DrawDebugAttackInfo( "inv type "+debug_HitMutekiArray[hitcheck] );
		
		if(hitcheck > 0)
		{
			//BMvTbl.SetLP(1,hitcheck);
			//Battle_Std.DrawDebugAttackInfo( "inv on "+debug_HitMutekiArray[hitcheck] );
			//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck] );
			
			BMvTbl.SetLP(3,s.MvCount);	
			
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "differentiation "+"number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3);
				
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);

				
				//finalizeflag = 1;
			}
			
			BMvTbl.SetLP(1,hitcheck);
			
			if( BMvTbl.GetLP(2)==-1 )
			{
				BMvTbl.SetLP(2,s.MvCount);
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
			}
			
			//BMvTbl.SetLP(9,1);
		}
		else
		{
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3) + off;
				
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);
				
				//finalizeflag = 1;
			}
		}

		if( move ) finalizeflag = 1;
		
		if( finalizeflag )
		{
			local finalstart = BMvTbl.GetLP(2) + off;
			local finalend = BMvTbl.GetLP(3) + off;
			
			if( BMvTbl.GetLP(3) > 0 )
			{	
				foreach(key, inv in debug_HitMutekiArray)
				{
					if( BMvTbl.GetLP(1) & key ) 
					{
						if(inv != "")
						{
							str += inv+"&";
						}
					}
				}
				
				str = str.slice(0,str.len()-1)
				
				str += " inv "+finalstart+"-"+finalend+"f ";
				
				Battle_Std.DrawDebugAttackInfo( str );
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		//Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Obj_CheckInvulnAlt <-
{
	function Init()
	{
		Battle_Std.DrawDebugAttackInfo( "obj create" );
		
		//BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus|_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );

		BMvTbl.SetLP(1,-1); //hitcheckflag
		

		BMvTbl.SetLP(2,-1); //hitcheck start
		

		BMvTbl.SetLP(3,-1);		
		

		BMvTbl.SetLP(4,-1);
		
		BMvTbl.SetLP(5,-1);

		//flag
		BMvTbl.SetLP(6,-1);
		
		//flag
		BMvTbl.SetLP(7,-1);
		
		//flag
		BMvTbl.SetLP(8,-1);
		
		//thing
		//BMvTbl.SetLP(9,0);
	}
	function FrameUpdate() : (debug_HitMutekiArray)
	{
		
		local player = BMvCore.GetPlayerCharaData();
		local s = BMvTbl.GetMvStatus();	
		
		local playerpat = 0;	
		
		local move = 0;
		
		local finalizeflag = 0;
		
		local hitcheck = BMvTbl.GetHitCheckFlag(0); //current hitcheck invulnerability flag
		
		local TInvuln = 0; // actually the number of hurtboxes
		
		local off = 0;

		//local Def_HitCheckFlag_TRUEINV = 256;
		
		local str = "";
		
		local code = 0;
		
		local pmvcnt = 0;
		
		local pstoptime = 0;
		
		if( player.IsDone )
		{
			
			BMvCore.PushCharaData( player );
				hitcheck = BMvTbl.GetHitCheckFlag(0);
				local throwmuteki = BMvEff.GetPlayerMuteki( 1 ); // throw inv
				local bodymuteki = BMvEff.GetPlayerMuteki( 0 ); // ptimer body inv
				local ps = BMvTbl.GetMvStatus();
				
				pstoptime = BMvEff.IsMyStopTime();
				
				code = BMvTbl.FromFinalize();
				
				if( BCMDTbl.CheckCancel( _SkillType_None ) )
				{
					move = 1; //行動可能だな
				}
				local existKuraiRect = false;
				for( local i=0; i<8; i++ )
				{
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai , i ], flags=_HanteiFlag_Tool } );
					if( rc.sx != _Hantei_Error )
					{
						TInvuln++; //add them up ( hurtboxes )
					}
					//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
				}
			BMvCore.PopCharaData();
			
			if( throwmuteki ) hitcheck += _HitCheckFlag_Throw;
			if( bodymuteki ) hitcheck += Def_HitCheckFlag_Ptimer;
			//Battle_Std.DrawDebugAttackInfo( "tinv "+TInvuln );
			
			playerpat = ps.DataPattern;
			pmvcnt = ps.MvCount;
			
		}
		
		if( TInvuln == 0 ) hitcheck += Def_HitCheckFlag_TRUEINV;
		
		//Battle_Std.DrawDebugAttackInfo( "inv n "+hitcheck );
		//Battle_Std.DrawDebugAttackInfo( "inv type "+debug_HitMutekiArray[hitcheck] );
		//Battle_Std.DrawDebugAttackInfo( "stopt "+pstoptime+" "+BMvTbl.GetLP(9) );
		
		if(hitcheck > 0)
		{
			//BMvTbl.SetLP(1,hitcheck);
			//Battle_Std.DrawDebugAttackInfo( "inv on "+debug_HitMutekiArray[hitcheck] );
			//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck] );
			
			BMvTbl.SetLP(3,pmvcnt);	
			
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "differentiation "+"number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3);
				
				if( debug_HitMutekiArray[BMvTbl.GetLP(1)] == " - " )
				{
					str = BMvTbl.GetLP(1)+" inv: "+finalstart+"-"+finalend;
				}
				else
				{
					str = debug_HitMutekiArray[BMvTbl.GetLP(1)]+" inv: "+finalstart+"-"+finalend;	
				}
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);

				
				//finalizeflag = 1;
			}
			
			BMvTbl.SetLP(1,hitcheck);
			
			if( BMvTbl.GetLP(2)==-1 )
			{
				BMvTbl.SetLP(2,pmvcnt);
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
			}
			
			//BMvTbl.SetLP(9,1);
		}
		else
		{
			if( hitcheck != BMvTbl.GetLP(1) && BMvTbl.GetLP(1) != -1 )
			{		
				//Battle_Std.DrawDebugAttackInfo( "number "+s.MvCount+" hit "+debug_HitMutekiArray[hitcheck]+" lp2 "+BMvTbl.GetLP(2) );
				local finalstart = BMvTbl.GetLP(2) + off;
				local finalend = BMvTbl.GetLP(3) + off;
				
				if( debug_HitMutekiArray[BMvTbl.GetLP(1)] == " - " )
				{
					str = BMvTbl.GetLP(1)+" inv: "+finalstart+"-"+finalend;
				}
				else
				{
					str = debug_HitMutekiArray[BMvTbl.GetLP(1)]+" inv: "+finalstart+"-"+finalend;	
				}
				
				Battle_Std.DrawDebugAttackInfo( str );
				//Battle_Std.DrawDebugAttackInfo( "htv "+hitcheck+" lp1 "+BMvTbl.GetLP(1) );
				
				//Battle_Std.DrawDebugAttackInfo( "i "+debug_HitMutekiArray[hitcheck]+" mvcnt "+s.MvCount+" lp3 "+(BMvTbl.GetLP(3)+1) );
				BMvTbl.SetLP(1,-1); //hitcheckflag

				BMvTbl.SetLP(2,-1); //hitcheck start
				
				BMvTbl.SetLP(3,-1);	//hitcheck end	
				
				BMvTbl.SetLP(4,-1);
				
				BMvTbl.SetLP(5,-1);

				//flag
				BMvTbl.SetLP(6,-1);
				
				//flag
				BMvTbl.SetLP(7,-1);
				
				//flag
				BMvTbl.SetLP(8,-1);
				
				//thing
				BMvTbl.SetLP(9,0);
				
				//finalizeflag = 1;
			}
		}

		//if( move ) finalizeflag = 1;
		
		if( finalizeflag )
		{
			local finalstart = BMvTbl.GetLP(2) + off;
			local finalend = BMvTbl.GetLP(3) + off;
			
			if( BMvTbl.GetLP(3) > 0 )
			{	
				if( debug_HitMutekiArray[BMvTbl.GetLP(1)] == " - " )
				{
					str = BMvTbl.GetLP(1)+" inv: "+finalstart+"-"+finalend;
				}
				else
				{
					str = debug_HitMutekiArray[BMvTbl.GetLP(1)]+" inv: "+finalstart+"-"+finalend;	
				}
				
				Battle_Std.DrawDebugAttackInfo( str );
			}
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize()
	{
		Battle_Std.DrawDebugAttackInfo( "obj destroy" );
		BMvTbl.SetDeleteMoveTable();
	}
}

// ----------------------------------------------------------------------------
// ゲーム全体の割り込み関数
// ----------------------------------------------------------------------------
//function Std_MoveTable::GeneralInterrupt( info )
Std_MoveTable.GeneralInterrupt <- function( info )
{
	// info は BMvTbl::MvInterruptInfo クラス
	switch( info.type ) // typeで分岐
	{
	case _InterruptType_Ko_Atk: // KOした
		//print( "\n_InterruptType_Ko_Atk" );
		break;
	case _InterruptType_Ko_Def: // KOされた
		//print( "\n_InterruptType_Ko_Def" );
		//スローにする
		BMvEff.Slowmotion_Set( { type=1, time=120, power=6666 } ); //KOスローを他の登録を全消去して追加
		BMvEff.SetCamera_Quake( { type=2, time=40, clear=1 } ); //他の揺らしを止めて画面揺らし

		//キャラ別にいじれるオブジェクトを一応呼ぶ
		BMvEff.CreateObject( { mvname="Mv_KOImpact_Object" } );
		
		//オーラとかがあったら消す
		Battle_Std.PcAuraEffect_AllAuraEnd(); //ＫＯされたキャラはこのタイミングでオーラを消す
		
		BSound.SE_Play( { type=_SeType_Normal, num=71 } ); //ＫＯ効果音
		break;
	case _InterruptType_Judge: // Judge
		//print( "\n_InterruptType_Judge" );
		//ジャッジの結果を取得してペカらせる
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			if( BMvEff.GRD_GetJudgeResult() > 0 )
			{
				Battle_Std.SetCharaFlash_GRDJudgeFlash();
				//集中わっか
				//わっかエフェクト側からオーラは呼ばれます（座標とタイミングの関係上仕方ない）
				local eff = BMvEff.CreateObject( { x=0, y=-200, datatype=1, start_pat=190, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags({ flags=_ObjFlags_ParentMove|_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll });
					
					eff.pop();
				}
				if( Def_Dbg_NoPlayUpsetSE == 0 ) BSound.SE_Play( { type=_SeType_Normal, num=75 } ); //GRD勝利効果音を再生
			}
			player.pop();
		}
		break;
	}
}


//空振りガード関係
Std_MoveTable.Mv_VGuard_Stand <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_S )
		{
			BMvTbl.SetPattern(def_PAT_VGuard_S); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}		
		
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 ); // そのまま継続
			else if( type == 2 ) BMvTbl.SetFinalize(2); // しゃがみへ
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
		//
		//print("\nKeep_Stand" + BMvTbl.VGuard_Time(-1) ); //-1で取得
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_StandEnd", [2,"Mv_VGuard_Crouch"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}

Std_MoveTable.Mv_VGuard_Crouch <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.DataPattern!=def_PAT_VGuard_C )
		{	
			//print("\n違うパターンなので設定");
			BMvTbl.SetPattern(def_PAT_VGuard_C); // 任意
			BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ		
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time);
		}
		else //同じパターンでもFrameIDをチェック
		{
			if( (s.FrameID==120 || s.FrameID==130 ) ) //抜けてた
			{
				BMvTbl.JumpFrameID(100); // 行動可能のガードポーズへ
			}
		}
		Battle_Std.InitCharaVector(); //InitCharaVectorでXMAX初期化するようにしたのでこっちでＯＫ
		//Battle_Std.InitVector(); //ダッシュの慣性が乗ってしまうのでこうする
	}
	function Update_Std() // 
	{
		local type = BMvTbl.VGuard_CheckKeep();
		if( type != 0 )
		{
			// 継続
			BMvTbl.VGuard_Time(def_PAT_VGuard_Time); // もどす
			if( type == 1 )  BMvTbl.SetFinalize(1); // 立ちへ
			else if( type == 2 ); // そのまま継続
			else
			{
				// 例外、怖いので終わり
				BMvTbl.SetFinalize(0);
			}
		}
		else //継続しない
		{
			if( BMvTbl.VGuard_Time(-1) == 0 ) // 時間を取得し0だと終了
			{
				BMvTbl.VGuard_Time(0); // 0にする
				BMvTbl.SetFinalize(0);
			}
		}
		// 
		//print("\nKeep_Crouch" + BMvTbl.VGuard_Time(-1)+" type:"+type );
	}
	function Finalize_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
		Battle_Std.SwitchNextMoveTable("Mv_VGuard_CrouchEnd", [1,"Mv_VGuard_Stand"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std() // 
	{
		BMvTbl.VGuard_Time(0); // 0にする
	}
}


// 
Std_MoveTable.Mv_VGuard_StandEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_S, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_VGuard_CrouchEnd <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		Battle_Std.JumpFrameIDEX(120, def_PAT_VGuard_C, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}


if( Def_Dbg_GuardCancelAttack ) { //Def_Dbg_GuardCancelAttack
//ガードキャンセル　ガードスラスト
Std_MoveTable.Mv_GuardCancelAttack <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern( def_PAT_GuardCancelAtk ); // パターン変更
		Battle_Std.InitCharaVector();
		//フラッシュとかゲージ消費とか
		
		//GuardCanselエフェクトよび
		//GuardCansel
		Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
		datatype=1, pat="GuardCansel", angle="rand",
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=180 } ); //ゲージ増加制限
		Battle_Std.TypeSE_Play({ type="ガーキャン" }); //発動ボイス
		
		//アナウンス表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_GuardCancel,} );
		
		BMvTbl.SetPrio( _CharaPrio_Near ); // プライオリティ手前に
		
		//発動時にGRDを消費
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
		BMvTbl.SetLP(9,stock); // 発動時のストックを記憶
		
		// GRDの数に応じて割れる時間を短くする
		// 12個で0、6個で半分のようなイメージ
		//   0   6  12
		// 1.0 0.5 0.0
		local stockPar = (12-stock)*100/12;
		_dp("\n stockPar:"+stockPar+" stock:"+stock);
		
		// GRDブレイクする
		// テクニックとして、CS→すぐにGTでブレイクを回避できるんだよなぁ
		
		if( BMvTbl.GetPP(def_PP_GuardCancelStatus) == 1 ) // 200% or VO
		{
			local useframe = def_GRDBF_GuardCancel_Max * stockPar / 100;
			_dp("\n 200% GT:"+useframe);
			BMvEff.GRD_SetBreak( 0, useframe, useframe );
			BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
		}
		else // 100%
		{
			local useframe = def_GRDBF_GuardCancel * stockPar / 100;
			_dp("\n 100% GT:"+useframe);
			BMvEff.GRD_SetBreak( 0, useframe, useframe );
			BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
		}
		BMvTbl.SetPP(def_PP_GuardCancelStatus,0); // 一応初期化
		
		// BMvEff.SetSpGauge( { value=-500000 } ); //ＳＰゲージ全消費 ※200% VOだと全部減るわけではないようだ？
		// ↑が無くても予約分は消費される。ここで消費して０にしないと、GC→VOで回復の流れになる
		// まぁいいかな…ってことでestからは減らさないようにする

		local stop_frame = 6; // 自分にだけかかるヒットストップ
		local muteki_frame = 15+stop_frame; // 無敵時間　相打ちが多いので+1Fした
		BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		
		// ガーキャン演出強化
		BMvEff.SetStopTime( { time=7, stopme=0 } );
		BMvEff.SetCamera_Quake( { time=14, type=0, } );
		
		// 自分にヒットストップをかけて発生を遅くする
		local hitst = BMvTbl.MvHitStatus();
		hitst.Count = stop_frame;
		BMvTbl.SetMvHitStatus( hitst );				
		
		// ↑ 2Aの硬直差-3Fまではガードされる発生
		
		//念のため関係
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local muteki_frame = 254; // 無敵時間
			BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		// 無敵消去
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}

Std_MoveTable.Mv_GuardCancelAttackEX <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern( def_PAT_GuardCancelAtk ); // パターン変更
		Battle_Std.InitCharaVector();
		//フラッシュとかゲージ消費とか
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		//GuardCanselエフェクトよび
		//GuardCansel
		Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
		datatype=1, pat="GuardCansel", angle="rand",
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=180 } ); //ゲージ増加制限
		Battle_Std.TypeSE_Play({ type="ガーキャン" }); //発動ボイス
		
		//アナウンス表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_GuardCancel,} );
		
		BMvTbl.SetPrio( _CharaPrio_Near ); // プライオリティ手前に
		
		//発動時にGRDを消費
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
		BMvTbl.SetLP(9,stock); // 発動時のストックを記憶
		
		BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する

		local stop_frame = 3; // 自分にだけかかるヒットストップ
		local muteki_frame = 15+stop_frame; // 無敵時間
		BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		
		// ガーキャン演出強化
		BMvEff.SetStopTime( { time=7, stopme=0 } );
		BMvEff.SetCamera_Quake( { time=14, type=0, } );
		
		// 自分にヒットストップをかけて発生を遅くする
		local hitst = BMvTbl.MvHitStatus();
		hitst.Count = stop_frame;
		BMvTbl.SetMvHitStatus( hitst );				
		
		// ↑ 2Aの硬直差+0Fまではガードされる発生
		
		//念のため関係
		BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=0, flag=_ClearFlag_ChangeMv } );
		
		BMvTbl.Achievement_Unlock(6); // 【トロフィー】安全な切り返し
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local muteki_frame = 254; // 無敵時間
			BMvEff.SetPlayerTimer( { muteki_dage=muteki_frame, muteki_dageX=muteki_frame, muteki_nage=muteki_frame, muteki_nageX=muteki_frame } );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		// 無敵消去
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0, muteki_nage=0, muteki_nageX=0 } );
	}
}

} //Def_Dbg_GuardCancelAttack





















// ----------------------------------------------------------------------------
// コンセントレーション
// ----------------------------------------------------------------------------
//コンセントレーションエフェクト
Std_MoveTable.Mv_ConvertChargeEff <-
{
	function Init_Std()
	{
		BSound.SE_Play( { num=239 } ); //コンセントレーション効果音再生でだし
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std()
	{
		local id = Battle_Std.GetPlayerFrameID();
		local mv = Battle_Std.GetPlayerMvName();
		
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvcnt%50==49 )
		{
			BSound.SE_Play( { num=238 } ); //コンセントレーションループ＋フェード効果音再生		
		}
		
		if( id==256 && mv=="Mv_ConvertCharge_Modori" )
		{
			BMvTbl.JumpFrameID(256);
			BMvEff.EraseObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage } );	
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();	
	}
	function LastUpdate_Std()
	{
		BSound.SE_Stop( { type=_SeType_Normal, num=239, fadetime=10 } ); // コンセントＳＥフェードアウト
	}
}

//コンセントレーション
Std_MoveTable.Mv_ConvertCharge <- 	//コンバート
{
	function Init_Std() //
	{
		//共通処理
		BMvTbl.SetMuki(_Direction_Auto);
		
		BMvTbl.ClearHitStatus(); //ヒット情報のクリア（空振りキャンセル可能フラグをたててるため必要）

		BMvTbl.SetPattern(def_PAT_Convert);
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			local eff = BMvEff.CreateObject( { x=rc.sx, y=0, mvname="Mv_ConvertChargeEff", datatype=1, start_pat=84, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_EraseParentDamage } );	
				BMvTbl.SetPosition( { y=0 } );
				eff.pop();
			}
		}
		Battle_Std.InitVector(); // ベクトル初期化

		Battle_Std.TypeSE_Play({ type="コンセントレーション" });
		
		//D連打でCS出せるように空振りCS可能に
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=60, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // DDでCSが出せるようにする
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		
		BMvTbl.SetLP(5,0); //前回のMvCount
		
		// ループの抜け先を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Convert, frame=stopframe, rest=4 } );
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Convert, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか
	
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//キャラをちょっと青く光らせる
		if( s.MvCount%4==0 )
		{
			Battle_Std.SetCharaFlash_ConvertCharge();
		}
		
		// 1Fに１回の処理
		if( s.CallCount == 0 )
		{
			// GRD増加関係
			//チャージ中のGRD増加基本値
			local mGRDAddVal = def_GRD_Convert_Frame;
			local eGRDAddVal = def_GRD_Convert_Frame_Enemy;
			
			if( BMvEff.Liberate_Get()!=_SpGaugeMode_Normal ) //ヴェールオフ中
			{
				mGRDAddVal = def_GRD_Convert_Frame_VeilOff;
				eGRDAddVal = def_GRD_Convert_Frame_VeilOff_Enemy;
			}
			else if( BCMDTbl.GetComboGauge()==0 ) //自分のEXSが空
			{
				mGRDAddVal = def_GRD_Convert_Frame_NoEXS;
				eGRDAddVal = def_GRD_Convert_Frame_NoEXS_Enemy;		
			}
			else if( Battle_Std.CheckEnemyisDamage() )  //相手がやられのとき
			{
				mGRDAddVal = def_GRD_Convert_Frame_EnemyisDamage;
				eGRDAddVal = def_GRD_Convert_Frame_EnemyisDamage_Enemy;		
			}
			
			if( s.MvCount<def_FL_Shield_SPCostStartFrame )
			{
				//でかかりはたまりにくく
				mGRDAddVal = mGRDAddVal * 25 / 100; //整数化:0.25;
				eGRDAddVal = eGRDAddVal * 45 / 100; //整数化:0.45;
			}
			
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(mGRDAddVal), pressure=0 }); //自分の増加
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(eGRDAddVal), pressure=0, target=1 }); //相手の減少

			Battle_Std.SetSpGauge_ConvertChargeFU( {value=def_SP_ConvertCharge_Frame,} ); //モーション中のEXS消費
			
			//それとは別に
			//自分のエリアまで侵食しているGRDは強く減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
			if( enemy.push() )
			{
				local enemyGRD_count = BMvEff.GRD_CheckStock( { val=-1 } );
				if( enemyGRD_count>=6 ) 
				{
					BMvEff.GRD_AddValue( { val=-600, } ); //固定値で減る
				}
				
				enemy.pop();
			}
			
			
			// パーティクル関係
			// つぶを出す
			if( s.MvCount%3==0 ) //気持ち軽くする
			{
				local muki = BMvEff.Random_Limit(2); //BMvTbl.SetMuki( muki )
				local iRnd = BMvEff.Random_Limit(100); //0〜99 基本ランダム値
				local posx = iRnd;
				local vecy = (-2300 + (iRnd*15))*150/100;
				local vecx = (posx*3)*150/100;
				local frame = 45;
				if( muki==1 )
				{
					posx*=-1;
				}
				local eff = BMvEff.CreateObject( { x=posx, y=-25, mvname="", datatype=1, start_pat=27, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );	
					if( muki==1 ) BMvTbl.SetMuki( _Direction_Reverse );
					BMvTbl.SetVector( { x=vecx, y=vecy, addx=0, addy=-vecy/frame, flags=_Vector_Div } );
					BMvTbl.JumpFrameID(20);
					
					eff.pop();
				}
			}
		}
		
		// 1Fに2回以上やってもいい重要な処理
		switch( s.FrameID )
		{
		case 100: //ループ開始
			break;
		case 200: //ループ分岐
			BMvTbl.JumpFrameID(100);
			break;
		}
		
		if( s.MvCount>def_FL_ConvertMinTime && !BMvTbl.CheckCommandString( [ "@H,0D@" ] ) )
		{
			BMvTbl.SetFinalize(256);
		}
		
		// Ver1.03での無敵バグ防止用
		// 今はもう不要だが、無限に続けられるパターンはそれなりに危険なので一応残しておく
		if( s.MvCount>def_FL_ConvertMaxTime )
		{
			BMvTbl.SetFinalize(256);		
		}
		
		//200225:コンセで2Pが必ず勝ってしまうの対応
		BMvEff.GRD_SetSpFlag(1);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_ConvertCharge_Modori"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount>4 )
		{
		}
		else
		{
			Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生したＳＥを停止（コンセントレーション）
		}
	}
}

//コンセントレーションの戻り
//一応スクリプトでも行動可能にしておこう
Std_MoveTable.Mv_ConvertCharge_Modori <-
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Convert, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); //行動可能に変更
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

// ----------------------------------------------------------------------------
// やられ関係
// ----------------------------------------------------------------------------
// ○特殊なもの
// Mv_Bound_0023 投げ抜け押し返し攻撃
// Mv_Bound_0024 投げ抜けられガードポーズ

Std_MoveTable.Mv_Bound <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();		
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
		
		local cv_thresh = 35;
		local grav_multi = 0.04;
		
		local bs = BtlMvStd.GetBoundStatus();
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( bs.GetVecCount() > 0 )
		{
			if( BCMDTbl.CheckPosState( _PosState_Air ) )
			{
				if( enemy.push() )
				{
					local cpval = BMvTbl.ComboPoint_Calc({});

					enemy.pop();
					
					
					if(cpval < cv_thresh)
					{
					
						local nowvec = BMvTbl.GetVector( { flags=_Vector_Bound } );
						if(nowvec.y < 0)
						{
							local use_val = (100 - cpval)*grav_multi;
							
							nowvec.y += use_val;
							
							//Battle_Std.DrawDebugAttackInfo( "cnt "+bs.GetVecCount()+" D "+cpval+" usev "+use_val+" nvy "+nowvec.y );
							
							BMvTbl.SetVector( { x=nowvec.x, y=nowvec.y, addx=nowvec.addx, addy=nowvec.addy, flags=_Vector_Bound } );
						}
						
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		if( Def_Rule_GroundBoundSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}
		BtlMvStd.ClearBound(); // 状態解除(ベクトルが無くなる)
		// print("\nMv_Bound LastUpdate()");		
	}
}

//捕まれ中はMv_BoundではなくMv_Bound_Captureになります(毎フレームInitする)
//Mv_Bound_Captureは名前だけでBoundではないため、Bound関係で何かしようとすると危ない
//Mv_Bound_Captureという状態を取得できるだけと考えたほうがいい
//エラーがうざいので一応定義するけど何もしない
Std_MoveTable.Mv_Bound_Capture <- 
{
	function Init_Std() // 
	{
		//print("\nMv_Bound_Capture Init()");
		// ベクトル初期化だけ行う
		// つかみ成立→前MvのLastUpdateでベクトル設定→このMvで動きっぱなしになる
		Battle_Std.InitVector();
		// やられボイス再生処理
		
		local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
		if( sound_st&def_PP_SS_NoBoundVoice )
		{
		}
		else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
		{
		}
		else
		{
			Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		}
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		
		BMvTbl.SetFinalize( 0 );
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Bound_CaptureLoop" );
	}
}

// 毎フレームInitするのはやっぱり気になるので、こっちのMvに移行する
// こっちのMvでは特に何もしない
// 以前は、ロック系で毎フレームベクトル初期化していたので、こっちになることで少し影響ある
Std_MoveTable.Mv_Bound_CaptureLoop <- 
{
	function Init_Std() // 
	{
	}
	function Finalize_Std() // 
	{
	}
	function LastUpdate_Std() // 
	{
	}
}

// ----------------------------------------------------------------------------
// Guard
// ----------------------------------------------------------------------------
Std_MoveTable.Mv_Guard <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector(); // ベクトル初期化
		BtlMvStd.SetGuardStatus();
		//print("\nMv_Bound Init()\n");
		
		// ガードキャンセル用処理
		BMvTbl.SetLP(9,0); //ガードしてから何フレーム経過したか

		BMvTbl.SetLP(5,0); // ガードシールドを次のフレームで発動する
		BMvTbl.SetLP(6,0); // ガードシールド状態になって何フレームたったか。ガード開始時でのみリセット。2回目の発動があった場合継続。
		BMvTbl.SetLP(7,0); // ガードシールド発動回数
		//BMvTbl.SetPP(def_PP_ShieldStatus,0); //シールドステータスはここで初期化
		BMvTbl.SetLP(8,0); // ガードフロートで無敵時間のついたガードだよ
		
		//ガードのボイスを選んで再生
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound )
		{
			//_dm("pow:"+bs.Power+" def_BS_Pow_LV2"+def_BS_Pow_LV2);
			local bs_power = bs.Power;
			
			if( bs_power&def_BS_Pow_LV2 )
			{
				Battle_Std.TypeSE_Play({ type="ガード中" });
			}
			else if( bs_power&def_BS_Pow_LV1 )
			{
				Battle_Std.TypeSE_Play({ type="ガード弱" });
			}
			else if( bs_power&def_BS_Pow_LV0 )
			{
			}
			else
			{
				Battle_Std.TypeSE_Play({ type="ガード強" });
			}
			
			if( bs_power&def_BS_Pow_GuardFloat ) 
			{
				// ガードフロートなので無敵にします
				_dp("\n ガードフロートなので無敵をセット");
				BMvEff.SetPlayerTimer( { muteki_dage=64, muteki_dageX=64 } ); // 怖いので時間は短め
				BMvTbl.SetLP(8,1); // 無敵をセットしたことを記憶
			}
		}

		//シールド成功時の処理
		if( BMvEff.GuardSP_Success() )
		{
			// _dm("シールド成功（旧ＥＸ）");
			
			// バリアガード（シールド）が成功したときの処理
			Battle_Std.TypeSE_Play({ type="シールド成功" });	
			
			//シールドに成功
			BMvEff.AttackInfoString_Set({ word=def_AISW_SPGuard,} );									
			
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ShiledSuccess ); // シールド成功
			
			//距離を離れやすくする
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //増やすため今のガードベクトル取得
			if( vec.x<=0 ) //離れるベクトルのみ増やす
			{
				local isGround = BCMDTbl.CheckPosState( _PosState_Ground ); //def_VEC_GuardSP_Xvec_Air
				local useXvec = (isGround)? def_VEC_GuardSP_Xvec : def_VEC_GuardSP_Xvec_Air;//地上と空中で別の係数を使う
				local useXmax = (isGround)? def_VEC_GuardSP_Xmax : def_VEC_GuardSP_Xmax_Air;//地上と空中で別

				//係数をかけて最大値を制限
				//_dp("\n nowvecx:"+vec.x);
				vec.x = vec.x * useXvec/100;
				if( vec.x<useXmax) vec.x = useXmax;
				vec.addx = vec.addx * useXvec/100;
			
				//BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Bound } );
			}
			
			//相手のＧＲＤを無条件に１つ減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				BMvEff.GRD_AddValue( { val=def_GRD_Shield_Success_Enemy, pressure=0 } ); //val:10000で１ストック
				
				enemy.pop();
			}
			
			//自分のＧＲＤにボーナス
			Battle_Std.GRD_AddValue( { val=def_GRD_Shield_Success, boundplus=1 } );								
			
			//シールドによる時間停止（ヒットストップ）
			if( def_FL_ShieldStopTime )
			{
				BMvEff.SetStopTime( { time=def_FL_ShieldStopTime, stopme=2 } );
			}
			
			// シールド時にベクトルを減らす
			if( Def_Sys_ShieldSuccess_MinusVecTime )
			{
				if( BCMDTbl.CheckPosState(_PosState_Air) )
				{
					BMvEff.SetBoundSt( { addtime = -6 } );
				}
				else
				{
					BMvEff.SetBoundSt( { addtime = -3 } );
				}
			}
			
			//殴られた相手の行動がジャンプ攻撃だったらキャンセル不可とシールドされたフラグを与える　＋　※できない：空中ガード可能にする（多段シールドめんどくさい）
			local enemy_LastDmgChr = BMvCore.GetLastDamageCharaData( 0 ); // 殴られた敵情報を得る
			if( enemy_LastDmgChr.push() )
			{
				Battle_Std.MoveCode.AddFlag( def_MC_Shield ); // シールドを取られたMvとする
				
				local grd_add = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_ShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃
				local grd_add_comp = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_CompletedShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃を処理済みかどうか
				
				Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_CompletedShieldWeakGRDAdd ); // 処理済みということにする
				
				local grd_add_timing = (!grd_add_comp && grd_add); // このタイミングで専用GRD増加処理を入れる
				
				//local epos = BMvTbl.GetPosition(); // 位置取得
				// local isAir = ( BCMDTbl.CheckPosState(_PosState_Air) != 0 );
				// local emvname = BMvTbl.GetMvName();
				// 181203 : ジャンプ攻撃かどうかのチェックを変更
				// local isJumpAtk = Battle_Std.MoveCodeEx.CheckFlag( 0, def_MC_EnableAirAtkStatus|def_MC_Atk );
				local isJumpAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump );
				
				
				// if( isAir && emvname.find("Mv_Atk_Air")==0 ) //空中だったら・ジャンプ攻撃っぽかったら
				if( isJumpAtk ) //ジャンプ攻撃なら
				{
					// _dm("キャンセル不可＋行動不可＋空ガ可能を受けた");
					BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
					// BMvTbl.SetAtkGuardFlag( {  guard=_GuardFlag_GuardAir, time=254, flag=_ClearFlag_ChangeMv })
					
					BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
					Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Shielded ); // シールドを取られた
				}
				if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_Shield_CanselNG ) )
				{
					_dp("\n シールドによるキャンセル不能");
					BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
					BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
					// BMvTbl.SetAsFlag( { as_flags=_AsFlag_ExCancel, time=0, flag=_ClearFlag_ChangeMv } );
				}
				
				enemy_LastDmgChr.pop();
				
				if( grd_add_timing )
				{
					//GRD増加？
					_dpn("シールドによるGRD増加:"+def_GRD_Shield_Success_WeakBonus);
					Battle_Std.GRD_AddValue( { val=def_GRD_Shield_Success_WeakBonus, boundplus=1 } );
					
					local enemy_LastDmgPlayer = BMvCore.GetLastDamageCharaData( 1 ); // 殴られた敵情報を得る
					if( enemy_LastDmgPlayer.push() )
					{
						BMvEff.GRD_AddValue( { val=def_GRD_Shield_Success_WeakBonus_Enemy, pressure=0 } ); //val:10000で１ストック
						
						enemy_LastDmgPlayer.pop();
					}
				}
			}
			
			
			if( Def_Sys_HajiShield_EnemyNockBack )
			{
				// 画面端背負ってたら　＆　端へのベクトルが入っていたら
				if( Battle_Std.GetHaimenStageHajiDistance() <= 0 && vec.x < 0 )
				{
					if( enemy_LastDmgChr.push() )
					{
						local nosend_vector = Battle_Std.MoveCode.CheckFlag(def_MC_NoSend_ScriptKnockBackVecor);
						
						enemy_LastDmgChr.pop();
						
						if( nosend_vector==0 )
						{
							if( enemy.push() )
							{
								local divvec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
								if( divvec.x == 0 ) // 何もベクトルが設定されて無い時だけにする
								{
									local nockbackvec = vec.x * 200 / 100;
									if( nockbackvec < -4000 ) nockbackvec = -4000; // 上限きめとく
									BMvTbl.SetVector( { x=nockbackvec, addx=-nockbackvec/6, flags=_Vector_DivKeep } );
									// _dp("\n nockbackvec:"+nockbackvec);
								}
								enemy.pop();
							}
						}
					}
				}
			}
		}
		
		// パターンによってフラグをつけておく
		local mvs = BMvTbl.GetMvStatus();
		local nowpat = mvs.DataPattern;
		if( nowpat == def_PAT_GuardS ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusStd );
		if( nowpat == def_PAT_GuardC ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusCro );
		if( nowpat == def_PAT_GuardA ) Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_StatusAir );
		
		if( !Battle_Std.GS_CheckFlag( def_PP_GS_GuardCancelCmdCheckObj ) )
		{
			BMvEff.CreateObject( { mvname="Mv_GuardCancelCheck", datatype=1 } );
			Battle_Std.GS_AddFlag( def_PP_GS_GuardCancelCmdCheckObj );
			Battle_Std.GS_AddFlag( def_PP_GS_GuardCancelCmdFaild );
		}
	}
	function Update_Std() // 
	{
		// ガードキャンセル用処理
		local updateCnt = BMvTbl.AddLP(9,1); // ヒットストップも含めて何フレーム経過したか加算
		
		if( Def_Rule_GuardPat_HitStopAnime )
		{
			//ガード中ヒットストップ時もアニメさせる
			local mvs = BMvTbl.GetMvStatus();
			local bst = BtlMvStd.GetBoundStatus();
			local nowFra = BMvTbl.Frame_Proc( 0, _ValAdd );
			// _dp("\n updateCnt:"+updateCnt+" bst:"+bst.BoundTime );
			if( mvs.FrameID == 10 && bst.isBound && bst.BoundTime == 0 && ( nowFra >= 0 && nowFra < Def_Rule_GuardPat_HitStopAnime ) )
			{
				//ガードのモーション＆ヒットストップ中
				//6枚ループのガードポーズ、3F枚に絵を進める
				//0 0
				//1 0
				//2 0
				//3 1
				//4 1
				//5 1
				//6 2 ...
				local guardFra = (updateCnt/5)%Def_Rule_GuardPat_HitStopAnime;
				// _dp(" -> guardFra:"+guardFra );
				BMvTbl.Frame_Proc( guardFra, _ValSet );
			}
		}
		
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}

		// SP状態でのガードかどうかでGRDのフレーム毎増加値を変える
		// BMvEff.GuardSP_Success()の戻り値
		// 0 何もなし
		// 1 成功
		// -1 ブレイク技をガードした
		// ガード成立時に更新され、次のガード成立まで変化しません
		local noChange = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_GuardGRDChangeStop );
		if( !noChange )
		{
			if( BMvEff.GuardSP_Success() )
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_GuardSP_Frame_Vorpal: def_GRD_GuardSP_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
			else
			{
				local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_Guard_Frame_Vorpal: def_GRD_Guard_Frame;
				Battle_Std.GRD_AddValue({ val=useval, pressure=0,boundplus=1 });
			}
		}


		//ジャストでシールドを成功すると、シールドした直後にガードシールドが出てしまう
		//ガードのMvに入った直後＆シールド成功中は検知しないようにする…と
		//はりっぱのあと出そうとしてもでないので、直前のMvがシールド1Fのときは出ないようにする
		//1回の入力で、シールド→ガードシールドとなるのがよくない
		// local t_mvs_cnt = BMvTbl.GetMvStatus().MvCountFrame;
		// local justSpGguard = 0;//(t_mvs_cnt == 0 && BMvEff.GuardSP_Success() );
		// _dp("\n チェック:"+t_mvs_cnt+", "+BMvEff.GuardSP_Success()+" ？:"+justSpGguard );
		local cmd_info0 = BCMDTbl.GetCmdInfoEx(0);
		local last_mvname = BMvTbl.ChangeMv_GetMvName();
		local isJustTiming = (cmd_info0.GetFrame() == 0 && (last_mvname=="Mv_Barrier_Std" || last_mvname=="Mv_Barrier_Cro" || last_mvname=="Mv_Barrier_Air") );
		// _dp("\n frame:"+cmd_info0.GetFrame()+" Mv:"+last_mvname+" -> "+isJustTiming );
		
		//普通のガードの時はガードシールドの入力チェック
		//ガードシールドのコマンドが後ろ+Dなので、投げコマンドと被っていて、暴発を防ぐために1F遅らせる
		if( BMvEff.GuardSP_Get() != 1 && !isJustTiming ) // ガードシールド状態でない、普通のガードのとき（ガードシールド発動するとsetの値）
		{
			local grd = BMvEff.GRD_GetBreak( 0 ); //GRDのブレイク状態を取得
			local notGRDBreak = !( grd==1 || grd==255 ); //ブレイクorオーバーブレイク以外かどうか
			
			//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その１
			if( BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } ) )
			{
				BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
				BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す				
			}
			/*
			else if( notGRDBreak ) //ガードシールドはGRDブレイク中は出せない
			{
				local guard_shield = BMvTbl.GetLP(5); //次のフレームでガードシールド発動するかどうかフラグ(おしっぱのフレーム)
				
				// ちょっと突貫処理っぽいけど、まぁ大丈夫だべ
				if( BMvTbl.CheckCommandString( [ "214D" ] ) && BMvEff.GetPlayerMuteki( 0 ) == 10 && BMvEff.GetPlayerMuteki( 1 ) == 10 )
				{
					// _dp("\n ガードスラスト出したい！");
				}
				else if( BMvTbl.CheckCommandString( [ "4+D","7+D","1+D" ] ) || BMvTbl.TM_GetCancelShieldTiming() ) //Dを押したら次のフレーム用にフラグをたてる
				{
					BMvTbl.AddLP(5,1); //次のフレームで反応
					//自分が空中の時は空中投げ抜け無いので1F遅らせを無くそう（まぁあるキャラもいるけど、空ガの状況もないし）
					//これで密度の高いジャンプ攻撃も連続シールドできるよ
					if( BCMDTbl.CheckPosState( _PosState_Air ) )
					{
						guard_shield = BMvTbl.GetLP(5); //1F目からガードシールド反応させる
					}
				}
				else
				{
					BMvTbl.SetLP(5,0); //ダメならリセット
				}
				
				local guard_shield_canseled = (BMvTbl.GetLP(7) >= 1 && BMvTbl.GetLP(6) > 4); // ガードシールド発動回数1回以上＆発動時間も4F以上
				if( guard_shield >= 1 && !guard_shield_canseled ) // Dボタンを前のフレームで押していたらガードシールド発動＆ガードシールド発動キャンセルしてなかったら
				{
					//ガードシールド発動処理
					
					BMvEff.GuardSP_Set( { val=1 } ); // ガードシールド状態にセット
					BMvTbl.SetLP(5,0); // ガードシールド入力フラグを消す
					
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_GuardShiled ); // ガードシールド状態
					
					// カウンタはリセットしない。ガード状態になった時点でしかリセットされない。
					// BMvTbl.SetLP(6,0); // 何フレームガードシールド発動したかのカウンタリセット
					
					BMvTbl.AddLP(7,1); // ガードシールド発動回数を加算

					//ガードシールド発動直後に終了する場合もあるのでコストなどはMv_GuadShieldEffで処理するように変更
					//特殊判定の座標にガードシールドエフェクトを表示
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{			
						BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=74, mvname="Mv_GuadShieldEff", flags=_Position_ToolShift } );
					}
				}
			}
			*/
		}
		
		if( BMvEff.GuardSP_Get() == 1 ) //ガードシールド中の処理
		{
			local guard_shield_cnt = BMvTbl.AddLP(6,1); // ガードシールド状態のカウンター加算
			//ガード中投げ抜けを入力した時にガードシールドが出ないようにする　その２
			
			// print("\n guard_shield_cnt:"+ guard_shield_cnt);
		
			//A+Dの同時押しをD→Aとしてしまい、先にガードシールドが発動してしまった場合は、ここで投げコマンドかどうかチェックして解除
			if( guard_shield_cnt <=2 && BMvTbl.CheckCommandString( { command=[ "A+D" ], lastdelay=1, } ) )
			{
				BMvEff.GuardSP_Set( { val=0 } ); // バリアガード状態解除
				BMvTbl.SetLP(5,0); //ガードシールド入力フラグを消す
				BMvEff.SetCharaFlash( { color = 0xAAAAFF, type = 0, time = 0 } ); //ガードシールド入力での発光を消す
			}
		}
	}
	function FrameUpdate_Std() : (callLandEffect)
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		//空中ガード中に着地したら立ちガードポーズに移行
		if( mvs.isLanding )
		{
			BMvTbl.SetPattern(def_PAT_GuardS);
			//Yベクトルだけ初期化（着地・念のため）
			BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );
			//着地エフェクトを呼ぶ
			callLandEffect(); // 着地エフェクト
			
			// ガードフロートからの着地だったら打撃無敵を削除
			if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
			{
				// 打撃無敵を削除
				BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
			}
		}
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGuardFinalize();
		//print("SetGuardFinalize()");
	}
	function LastUpdate_Std() // 
	{
		//ガードシールドを発動したが攻撃をとれなかった場合のみGRDコストを消費する
		//ガードシールドを入力してて　かつ　シールド成功フラグはないかどうかチェック
		if( BMvEff.GuardSP_Get()!=0 && BMvEff.GuardSP_Success()!=1 )
		{
			//_dm("ガードシールドコスト消費");
			
			//失敗によるコスト消費
			Battle_Std.UseGRDStock( def_GRD_GuardShieldCost, def_GRD_GuardShieldNotEnough_Enemy); // 消費GRD数, 相手増加GRD値(単位違注意)
			
			_dp("\n 失敗シールド！");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ShieldFailed ); // 失敗シールドなの
		}
		
		if( Def_Rule_GroundGuardSlideKeep )
		{
			//地上状態では慣性を残す
			if( BMvTbl.CheckPosState( _PosState_Ground  ) )
			{
				local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
				BMvTbl.SetVector( { x=vec.x, addx=-vec.x/10, flags=_Vector_DivKeep } );
				// print("\n vec.x:"+vec.x);
			}
		}		
		
		// ガードフロートで浮いて、空中だったら空ガ不能技でハメられないように無敵時間をセットする
		if( BMvTbl.GetLP(8) ==1 && BMvTbl.CheckPosState( _PosState_Air ) ) // ガードフロートで無敵をセットされていた,空中だった
		{
			// 抜けるときに少し打撃無敵をつける（ハメ回避）
			BMvEff.SetPlayerTimer( { muteki_dage=def_FL_ModoriGuardFloatDagekiMuteki, muteki_dageX=def_FL_ModoriGuardFloatDagekiMuteki } );
		}
		
		BtlMvStd.ClearGuard(); // 状態解除
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		//print("ClearGuard()");
		
	}
}

//ガードシールド発動エフェクト
//LPが1の間は成功チェックして、成功エフェクトもこっから呼ぶ
Std_MoveTable.Mv_GuadShieldEff <-
{
	function Init_Std() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
		
		BMvTbl.SetLP(0,0); //0: ガードシールドの成功をチェックする 1:もうチェックしない
		
		//呼び出し後、そのフレーム内に終了してしまうケースが有る
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			BMvTbl.SetFinalize(0);
		}
		else
		{
			//ガードシールド発動が確定した
			//ここでゲージとか消費するように変更 18/6/13
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				Battle_Std.SetCharaFlash_GuardSPCommand(); //ヒカル
				BSound.SE_Play( { type=_SeType_Normal, num=193 } ); //ガードシールド発動音
			
				//発動時のゲージ消費
				if( Def_Sys_GuardShield_UseEXS )
				{
					BMvEff.SetSpGauge( { value=def_SP_GuardShield_Init } );
				}
				
				if( Def_Sys_GuardShield_PlusVecTime )
				{
					BMvEff.SetBoundSt( { addtime = Def_Sys_GuardShield_PlusVecTime } ); // ガードシールド発動すると硬直が増加する
				}
				
				//自分を少し離れるようにする（？）　☆テスト実装
				//ガードシールド＝ガード中のみだからDIVをいじっても大丈夫なはず？
				//相手をいじるのは何か怖い。地上のみにする？
				BMvTbl.SetVector( { x=-1400, addx=200, flags=_Vector_DivKeep } );//UNIst x:-1000, add:200
				
				player.pop();
			}
		}
	}
	function FrameUpdate_Std()
	{
		local mode = BMvTbl.GetLP(0);
		
		switch( mode )
		{
		case 0: //Mvの変化をチェック。変わったらもうガードシールドは成功するはずがない。
			local mv = Battle_Std.GetPlayerMvName();
			if( mv!="Mv_Guard" )
			{
				BMvTbl.SetLP(0,1)
				// print("\nガードシールド成功チェック終了");
				return;
			}
			//Mvが変わらずガードＳＰになってたらエフェクトを呼ぶ
			
			local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( player.push() )
			{
				local guardSP_get = BMvEff.GuardSP_Get(); //SPガード（バリガ）状態の取得
				local guardSP_success = BMvEff.GuardSP_Success(); //SPガード（バリガ）状態でガードが成立したかどうか
				local guardSP_effcallok = (guardSP_get==0 && guardSP_success); //SPガード（バリガ）状態じゃないガードでかつSPガードが成立
				
				player.pop();
				
				if( guardSP_effcallok )
				{
					// print("\nガードシールド成功");
					local eff = BMvEff.CreateObject( { datatype=1, start_pat=72, } );
					if( eff.push() )
					{
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_MoveTimeStopAll } );
						BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } ); // これがないと_ObjFlags_ParentMoveがおかしくなる
						eff.pop();
					}
					BMvTbl.SetLP(0,1);
					BMvTbl.SetFinalize(0); // 消滅へ
				}
				if( guardSP_get!=1 )
				{
					BMvTbl.SetFinalize(0); // 消滅へ
				}
			}
			
			break;
		case 1: //Ｍｖが変わったorガードシールド成功エフェクトをもうよんだ後
			break;	
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ガードすると生成される
//ガード硬直がなくなると消えはじめるが、20Fぐらい消えるまで猶予がある
//猶予中にガードすると生き返る
Std_MoveTable.Mv_GuardCancelCheck <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		BMvTbl.SetLP(2,0); // ガード状態の間は1以上　ガード状態でなくなると減っていき、0になるとこのオブジェクト自体消滅
		BMvTbl.SetLP(3,0); // ガード中の214入力に成功したら1 1の間はガード中生き続ける（けしちゃうと次のガードでまたガーキャンが出せなくなる）
	}
	function Update_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local cmd_ret = BMvTbl.CheckCommandString( "2" );
			
			local bs = BtlMvStd.GetBoundStatus();
			local isGuard = ( bs.isBound == 2 || (bs.isBound && bs.Name.find("ガード")!=null ) );
			
			player.pop();
			
			// 2を入れるまでの処理
			if( BMvTbl.GetLP(3)==0 )
			{
				if( cmd_ret )
				{
					BMvTbl.SetLP(3,1);
					Battle_Std.GS_DelFlag( def_PP_GS_GuardCancelCmdFaild ); // ガーキャンだしてもOKにする
				}
			}

			// ガード中生き残るが、ガード状態でなくなっても20Fの間は生き続ける処理
			if( isGuard )
			{
				BMvTbl.SetLP(2,20);//生きる時間にもなる
			}
			else
			{
				// ガード状態でなければカウンタ減らして0になったら消滅へ
				if( BMvTbl.GetLP(2) > 0 )
				{
					BMvTbl.AddLP(2,-1);//カウントを減らす
				}
				else
				{
					BMvTbl.SetLP(2,0); // 猶予なくなったので消える
					BMvTbl.SetFinalize();
				}
			}
		}
		
		if( Def_Dbg_LocalDebugMode )
		{
			local side = BMvTbl.GetPlayerSide();
			debugfontL.setcolor( 0xFFFFFFFF );
			local base_pos = { x=200, y= 120 };
			debugfontL.draw( base_pos.x + (side*640), base_pos.y+ 20, format("ガード中余韻F:%2d 214成功？:%d ガーキャン不可？:%d",BMvTbl.GetLP(2), BMvTbl.GetLP(3), Battle_Std.GS_CheckFlag( def_PP_GS_GuardCancelCmdFaild ) ) );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_GuardCancelCmdCheckObj );
		Battle_Std.GS_DelFlag( def_PP_GS_GuardCancelCmdFaild );
	}
}


Std_MoveTable.Mv_GroundUkemi <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BtlMvStd.SetGroundUkemiStatus();
	}
	function Update_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetGroundUkemiFinalize();
	}
	function LastUpdate_Std() // 
	{
	}
}

// ----------------------------------------------------------------------------
// 基本アクション
// ----------------------------------------------------------------------------
//全キャラほぼ共通部分（個別に変えたい場合はキャラ別で同名Mv作っておく）---------------------------------------------------------------

local val_StdTyouhatsuType = chrparam.Get( { type="立ち挑発タイプ", chrnum=_ChrNo } ); 

Std_MoveTable.Mv_Neutral <- // ニュートラル待機
{
	function Init_Std() // 
	{	
		BMvTbl.SetPattern(def_PAT_Neutral);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
		BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		BMvTbl.SetPP(def_PP_TMP0,0); // 挑発待機
	}
	function FrameUpdate_Std() : (val_StdTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}

		// 通常時と、トレーニング時に挑発を行う
		// チュートリアルとミッションは除外
		local stage_st = BMvTbl.GetMvStageStatus().IsTrainingBattle();
		if( stage_st == 0 || stage_st == 1 )
		{
			local s = BMvTbl.GetMvStatus(); // ステータス取得
			//挑発再生チェック
			switch( val_StdTyouhatsuType )
			{
			case 0: // 挑発無し
				break;
			case 1: // 挑発あり・モーションあり
				if( BMvTbl.GetPP(def_PP_TMP0) <= 0 && s.MvCount>def_FL_NeutralWaitMin && s.MvCount%def_FL_NeutralWaitStep==0 && BMvTbl.GetFinalizeCode() == 0 ) //振り向き中は反応しないとか
				{
					if( BMvEff.Random_Limit(100) < 15 ) //発動確率
					{
						if (BMvTbl.JumpFrameID( 512 )!= -1 ) //あった？
						{
							BMvTbl.SetPP(def_PP_TMP0,10); // 10F後に挑発を行う予約
							Battle_Std.CallSkillSoonCache( 512, 10 );
						}
					}
				}
				break;
			case 2: // 挑発あり・モーション無し ※暫定未実装
				// if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
				break;
			}
		}
	}
	function Update_Std()
	{
		if( BMvTbl.GetPP(def_PP_TMP0)>0 )
		{
			// _dp("\n 挑発予約:"+BMvTbl.GetPP(def_PP_TMP0) );
			local left_frame = BMvTbl.AddPP(def_PP_TMP0,-1);
			if( left_frame <=0 )
			{
				BMvTbl.SetFinalize(512); // 立ち待機アニメへ
			}
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"], [512,"Mv_NeutralWait"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_NeutralWait <- // ニュートラル待機
{
	function Init_Std() // 
	{
		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Update_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );	
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_NeutralWaitNoMotion <- // ニュートラル待機
{
	function Init_Std() // 
	{
		if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Update_Std() // 
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
		if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
		if( s.MvCount>180 ) BMvTbl.SetFinalize(0); // 時間で終了（ポーズが無い人だっているんです）
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

local footstepA_senum = chrparam.Get( { type="足音Ａ_ＳＥ番号", chrnum=_ChrNo } );
local footstepB_senum = chrparam.Get( { type="足音Ｂ_ＳＥ番号", chrnum=_ChrNo } );



//Param0が10の時足音を再生する
Std_MoveTable.Mv_Null_PlayFootstepSE <- 
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0);
		
		//デバッグ用間隔表示
		BMvTbl.SetLP(1,0);
	}
	function FrameUpdate_Std() : ( footstepA_senum, footstepB_senum)
	{
		local my_st = BMvTbl.GetMvStatus();
		if( my_st.CallCount!=0 )
		{
			return;
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.isdone() )
		{
			local playtiming = 0;
			if( player.push() )
			{
				if( Battle_Std.GetUpdateParam0() == 10 )
				{
					playtiming = 1;
				}
				player.pop();
			}

			if( playtiming==1 )
			{
				local setype = BMvTbl.GetLP(0);
				BMvTbl.SetLP(0, 1-setype ); // 0 1 0 1 ...
				switch( setype )
				{
				case 0:
					if( footstepA_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepA_senum } );
					break;
				case 1:
					if( footstepB_senum != -1 ) BSound.SE_Play( { type=_SeType_Normal, num=footstepB_senum } );
					break;
				}
				// デバッグ
				local mvs = BMvTbl.GetMvStatus();
				local aida = mvs.MvCount - BMvTbl.GetLP(1);
				BMvTbl.SetLP(1,mvs.MvCount);
				if( aida != 0 )
				{
					// print("\nＳＥ間隔："+aida+" setype:"+setype+" mvs.MvCount:"+mvs.MvCount);
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Walk_F <- // 前進
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_F);
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std()
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<6) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_F" );
	}
}

Std_MoveTable.Mv_WalkStop_F <- // 前進停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}		

Std_MoveTable.Mv_Walk_B <- // 後退
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Walk_B);
		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
	}
	function FrameUpdate_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		if( BMvTbl.CheckStickHold( (1<<0) ) || !BMvTbl.CheckStickHold( (1<<4) ) )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_WalkStop_B" );
	}
}

Std_MoveTable.Mv_WalkStop_B <- // 後退停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Walk_B, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// カットインの絵だけ
Std_MoveTable.Mv_CutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(def_PAT_IWCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		// _dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// カットインの絵だけ　使わない

Std_MoveTable.Mv_IWXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// これは絵だけじゃない、表示して他をとめる
//インフィニットワースイグジスト
Std_MoveTable.Mv_IWXCutin <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_IWXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		Battle_Std.PcAuraEffect_CutinInit();
		//_dm("カットイン呼ばれ");
		
		local eff;
		/*
		eff = BMvEff.CreateObject( { datatype=1, start_pat=997 }); //背景のフラッシュ板を呼ぶ
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			BMvCore.PopCharaData(); //	
		}
		*/
		
		eff = BMvEff.CreateObject( { datatype=1, start_pat=998 }); //黒い板を呼ぶ
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=0, y=-360*128 } );			
			BMvCore.PopCharaData(); //	
		}


		BMvEff.SetStopTime( { time=50, stopme=2 } ); //自分以外をとめてしまう
	}
	function FrameUpdate_Std()
	{
		//print("\n.");
	}
	function Finalize_Std()
	{
		//print("\n -------------------☆");
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		//
	}
}



// EXカットインの絵だけ
Std_MoveTable.Mv_EXCutinGrp <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPattern(def_PAT_EXCutinGrp);
		BMvTbl.SetPosition( { x=0, y=0 } );
		//_dm("Mv_EXCutinGrp　EXカットイン呼ばれ");		
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

//暫定カットイン処理
Std_MoveTable.Mv_CutinObject <- //カットイン スクロールの影響を受けない
{
	function Init_Std()
	{
	}
	function Update_Std()
	{
		local effcallflag = false;
		if( BMvTbl.GetLP(0) == 0) //まだ出てない
		{
			//特殊判定を見つけたらカットイン集中エフェクトをそこに出す
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			BMvCore.PushCharaData( p ); //		
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				if( rc.sx != _Hantei_Error ) // 存在するか
				{	
					local e = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
					BMvCore.PushCharaData( e ); //
						BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_MoveTimeStopAll } );	
					BMvCore.PopCharaData(); //				
					effcallflag = true;
				}
			BMvCore.PopCharaData(); //	
			if( effcallflag ) BMvTbl.SetLP( 0, 1); //エフェクト出した			
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}			
}

local chp_DashJumpKansei = chrparam.Get( { type="ダッシュジャンプ慣性", chrnum=_ChrNo } );

//地上ジャンプの離陸から着地まで持続するオブジェクト
Std_MoveTable.Mv_JumpKanseiCheckObject <- //ジャンプ中の慣性（収束ベクトルじゃなくする）
{
	function Init_Std() : (chp_DashJumpKansei)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( { y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local v = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			
			local use_dashJumpKansei = chp_DashJumpKansei;
			//_dpn("ダッシュジャンプ慣性:"+use_dashJumpKansei);
			BMvTbl.SetVector( { x=v.x*use_dashJumpKansei/100, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ

			player.pop();
		}
	}
	function Update_Std() // 
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			local playerisground = ( (BMvTbl.CheckPosState( _PosState_Ground ))==1 );
			if( playerisground )	
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //メルブラジャンプ終了
			}
			player.pop();
		
			if ( playerisground )	
			{
				BMvTbl.SetFinalize(0);
				BMvTbl.SetPP(def_PP_JumpStatus,0); //ジャンプステータスを初期化
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}	
}

local func_JumpWaitInit = function()
{
	BMvTbl.SetMuki(_Direction_Auto);
	local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
	Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
	BMvTbl.SetVector( { x=vec.x, addx=-vec.x/20, flags=_Vector_DivKeep } ); //メルブラジャンプ
	BMvEff.SetPlayerTimer( { muteki_nage=def_FL_JumpWaitNageMuteki, muteki_nageX=def_FL_JumpWaitNageMuteki } ); //ジャンプ移行は投げ無敵に設定
	
	/*
	if( BMvTbl.ChangeMv_GetMvName().find("Mv_JumpCanselWait_") == 0 && Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_CounterHit ) ) 
	{
		BMvTbl.SetLP(0,1);
		
		//Battle_Std.DrawDebugAttackInfo( "jumpcancel buffer extend ch" );
	}
	else
	{
		BMvTbl.SetLP(0,0);
	}
	*/
	
	//BMvTbl.SetCommandLongDelay(1);
	
	BMvTbl.AirSkill_Begin(); // ジャンプ準備フレームのはじめに呼ぶ

	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
}

local func_JumpWaitFU = function()
{
	/*
	// ここでボタンを何か押していたら先行入力を受け付ける、みたいな
	if( BMvTbl.CheckCommandString( ["A","B","C","D"] ) )
	{
		// _dp("\n 先行入力！");
		BMvTbl.SetLP(0,1); // 先行入力チェック用
		
		//Battle_Std.DrawDebugAttackInfo( "jump attack during jumpwait" );
	}
	*/
	
}

// ジャンプで空中に浮いた時共通処理
local func_JumpFlightInit = function()
{
	BMvTbl.AirSkill_Check(); // ジャンプ開始フレームのはじめに呼ぶ
	
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
	
	BMvTbl.SetPP(def_PP_JumpFrame,0);//離陸から何フレームかを記憶する
		
	if( BMvTbl.GetLP(0)==1 )
	{
		//BMvTbl.SetCommandLongDelay(2); //extend buffer for ch reception
		
		//Battle_Std.DrawDebugAttackInfo( "jump buffer extend" );
	}	
}

//二段ジャンプで浮いたときの共通処理
local func_MultiJumpInit = function()
{
	local angle = Battle_Std.CCharaVector_GetToolAngle();
	local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=233, flags=_Position_ToolShift } );
	if( eff.push() )
	{
		BMvTbl.SetAngle({ angle=angle });
		
		eff.pop();
	}
	
	BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );
	BMvTbl.SetAirJumpOK(0);  //再度ジャンプできないようにする
	BMvTbl.AddAirJumpCount(1);  //回数を加算
	
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
}

// CVO中の簡易IW用かませMv
Std_MoveTable.Mv_41236SP_ABC <-
{
	function Init_Std() // 
	{
		//【トロフィー】実戦でクロスキャストヴェールオフ中にA+B+Cの入力でインフィニットワースを使用した。
		BMvTbl.Achievement_Unlock(3);
		
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP" );
	}
}

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_F <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
			
		//if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 2, def_MC2_CounterHit ) ) BMvTbl.SetLP(0,1);
		Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_CounterHit );
		
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_F" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_F <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_F);
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}		
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=255, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")

		BMvTbl.SetNextMoveTable( "Mv_Jump_F" ); //						
	}
}

// ジャンプ
Std_MoveTable.Mv_Jump_F <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpF ); //前ジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_JumpFrame,BMvTbl.GetMvStatus().MvCount);//離陸から何フレームかを記憶
	}
}

//ジャンプ共通着地Mv
Std_MoveTable.Mv_Jump_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Jump_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}		

//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_B <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_B" );
	}
}



// ジャンプ待機
Std_MoveTable.Mv_JumpWait_B <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_B);
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=257, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}		

		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_B" ); //
	}
}	

Std_MoveTable.Mv_Jump_B <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpB ); //後ろジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_JumpFrame,BMvTbl.GetMvStatus().MvCount);//離陸から何フレームかを記憶
	}
}


//ジャンプキャンセル制限フラグを立てる用のかませMv
Std_MoveTable.Mv_JumpCanselWait_N <-
{
	function Init_Std() // 
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_JumpWait_N" );
	}
}

// ジャンプ待機
Std_MoveTable.Mv_JumpWait_N <- 
{
	function Init_Std() : (func_JumpWaitInit)
	{
		func_JumpWaitInit();
		BMvTbl.SetPattern(def_PAT_Jump_N);		
	}
	function FrameUpdate_Std() : (func_JumpWaitFU)
	{
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvTbl.SetFinalize(0);
		}
		func_JumpWaitFU();
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_nageX=0 } ); //抜けるときに初期化
		if( BMvTbl.CheckPosState( _PosState_Air ) == 1) //空中に進んだ
		{
			BMvEff.CreateObject( { mvname="", datatype=1, start_pat=256, flags=_Position_ToolShift } );		
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_JumpKanseiCheckObject", flags=_Position_ToolShift } );		
		}
		
		// ダッシュジャンプでかかり必殺技でスーっと滑るのが強いので補正
		if( !BMvTbl.FromFinalize() )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_DivKeep } );
			BMvTbl.SetVector( { x=vec.x*100/150, addx=-vec.x/10,flags=_Vector_DivKeep } ); // 収束ダッシュ慣性を減少
		}
	}
	function Finalize_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount<4 ) _dem("【警告】ジャンプ移行フレームが["+(s.MvCount-1)+"F]しかありません")
		
		BMvTbl.SetNextMoveTable( "Mv_Jump_N" ); //
	}
}	

Std_MoveTable.Mv_Jump_N <- 
{
	function Init_Std() : (func_JumpFlightInit)
	{
		Battle_Std.JumpStatus.Add( def_PP_JS_JumpN ); //垂直ジャンプからフラグを立てる
		
		func_JumpFlightInit(); // ジャンプ空中に移行した時共通処理
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_JumpFrame,BMvTbl.GetMvStatus().MvCount);//離陸から何フレームかを記憶
	}
}

Std_MoveTable.Mv_MultiJump_F <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		//BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_MultiJump_F);

		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpF ); //ジャンプフラグを立てる	
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_B <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		//BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_MultiJump_B);

		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpB ); //ジャンプフラグを立てる
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}	

Std_MoveTable.Mv_MultiJump_N <-
{
	function Init_Std() : (func_MultiJumpInit)// 
	{
		BMvTbl.SetPattern(def_PAT_MultiJump_N);
		
		func_MultiJumpInit();
		
		Battle_Std.JumpStatus.Add( def_PP_JS_MultiJumpN ); //ジャンプフラグを立てる		
	}
	function FrameUpdate_Std() // 
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Jump_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch <- // しゃがみ移行
{
	function Init_Std() // 
	{
		//print("\n->しゃがみいこう");
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	//遅立ちテクを残すためにここのUpdateではキー受付をしない
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

local val_CroTyouhatsuType = chrparam.Get( { type="しゃがみ挑発タイプ", chrnum=_ChrNo } ); 


Std_MoveTable.Mv_Crouch_Wait <- // しゃがみ待機
{
	function Init_Std() // 
	{
		// BMvTbl.SetMuki(_Direction_Auto); // これ不要。あるとしゃがみ振り向き発生しないでしょ
		BMvTbl.SetPattern(def_PAT_Crouch_Wait);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		
		BMvTbl.SetLP(0,0); //挑発状態かフラグ　0:通常 1:挑発
		BMvTbl.SetFinalizeCode(0); //初期状態が0でない＋GetFinalizeCodeで分岐してるので初期化
	}
	function FrameUpdate_Std() : (val_CroTyouhatsuType)
	{
		BMvTbl.SetMoveableFlag( { move=1, time=32, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ループに含める行動可能
		
		// トレモ的なやつ以外なら挑発を行う
		if( BMvTbl.GetMvStageStatus().IsTrainingBattle() == 0 )
		{
			switch( val_CroTyouhatsuType )
			{
			case 0: // 挑発無し
				break;
			case 1: // 挑発あり・モーションあり
				local s = BMvTbl.GetMvStatus();
				
				if( s.MvCount>def_FL_NeutralWaitMin && s.MvCount%def_FL_NeutralWaitStep==0 && BMvTbl.GetFinalizeCode() == 0 && BMvTbl.GetLP(0)==0 )
				{
					local r = BMvEff.Random_Limit(100);
					if( r<20 ) //発動確率
					{
						if (BMvTbl.JumpFrameID( 512 )!= -1 ) //あった？
						{
							BMvTbl.SetLP(0,1); //挑発状態へ
							if( Def_Dbg_NoPlayUpsetSE == 0 ) Battle_Std.TypeSE_Play({ type="挑発" });
						}
					}
				}
				if( Battle_Std.GetUpdateFrameID( s ) == 900 && BMvTbl.GetLP(0)==1 )
				{
					BMvTbl.SetLP(0,0); //挑発状態解除
				}		
				break;
			}
		}
	}	
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(0); // コード0を立ち上がりとしてFinalize
		}
		else if( BMvTbl.CheckFurimuki() ) // 振り向きチェック
		{
			BMvTbl.SetFinalize(256); // コード256を振り向きとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_toN", [256,"Mv_Furimuki_C"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Crouch_toN <- //立ち上がり
{
	function Init_Std() // 
	{
		//print("\n->たちいこう");
	
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Crouch_toN);
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 振り向き音声を再生するべきかどうかチェック
local checkFurimukiVoice = function()
{
	if( Battle_Std.CheckEnemyisBound() ) return 0;
	if( Battle_Std.CheckEnemyisUkemi() ) return 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local e_muki = BMvTbl.GetMuki();
		enemy.pop();
		
		local p_muki = BMvTbl.GetMuki();
		
		if( p_muki == e_muki )
		{
			// お互い右向きとか、お互い左向きとか
			// 先に振り向くキャラがこっちに入ることが多い
			// _dp("\n しゃべってもいい");
			return 1;
		}
		else
		{
			// お互い向き合うorお互い逆を向いている（後者でしゃべらないのは変だけど、レアケースなので除外）
			// 後から振り向くキャラがこのセリフに入ることが多い
			// _dp("\n これはしゃべらない");
			return 0;
		}
	}
	return 0; // 相手が取得できない＝よくわからないので声はなし
}

// 立ち振り向き
Std_MoveTable.Mv_Furimuki_S <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_S);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ振り向き
Std_MoveTable.Mv_Furimuki_C <- 
{
	function Init_Std() : (checkFurimukiVoice)// 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Furimuki_C);		
		Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		//相手がやられ中や受け身中なら音声は不要なのでチェック
		if( checkFurimukiVoice() )
		{
			Battle_Std.TypeSE_Play({ type="振り向き" });
		}
	}
	function Update_Std() // 
	{
		// 下方向でないとき立ち上がる
		if( !BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) ) )
		{
			BMvTbl.SetFinalize(256); // コード256を立ち上がりとしてFinalize
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Crouch_Wait", [256,"Mv_Crouch_toN"] ); //デフォ,[code,mv]...
	}
}

// 通常技もある程度統一関数
//
//

//通常攻撃Init共通関数
local ground_atk_init = function( flags=0 )
{
	if( flags&(1<<0) )
	{
		//追加派生（B>BとかC>Cとか）
	}
	else
	{
		//通常技・特殊技
		BMvTbl.SetMuki(_Direction_Auto);
	}
	Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	
	Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
	Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
	BMvTbl.AddComboRate(); // コンボレート加算
	
	BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 体無敵にスカる
	
	BMvTbl.SetNoUkemiTimeLimitFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } ); // 受け身不可時間の下限を1/2より下げる

	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
	
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ

	// コマンドステータスチェック
	local cmdst = BMvTbl.GetPP(def_PP_CmdStatus);
	
	// リバースビートのアナウンス追加
	if( Def_Sys_ReverseBeatAnnounce )
	{
		if( cmdst&def_PP_CS_ReverseBeat )
		{
			BMvEff.AttackInfoString_Set( { word=def_AISW_ReverseBeat } );		
		}
	}
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}
}

local air_atk_init = function()
{
	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkJump ); // ジャンプ攻撃
	Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
	BMvTbl.AddComboRate(); // コンボレート加算	

	BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Head, time=255, flag=_ClearFlag_ChangeMv } ); // 頭無敵にスカる
	
	BMvTbl.SetNoUkemiTimeLimitFlag( { val=1, time=255, flag=_ClearFlag_ChangeMv } ); // 受け身不可時間の下限を1/2より下げる
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	
	Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
	
	// コマンドステータスチェック
	local cmdst = BMvTbl.GetPP(def_PP_CmdStatus);
	
	// リバースビートのアナウンス追加
	if( Def_Sys_ReverseBeatAnnounce )
	{
		if( cmdst&def_PP_CS_ReverseBeat )
		{
			BMvEff.AttackInfoString_Set( { word=def_AISW_ReverseBeat } );		
		}
	}
	
	//最後のコマンドチェック時に行動可能だった
	// local info0 = BCMDTbl.GetCmdInfoEx(0);
	// info0.GetCancel( _SkillType_None );
	// print("\n BCMDTbl.CheckCancel( _SkillType_None ):"+BCMDTbl.CheckCancel( _SkillType_None ) );
	
	// CSの後とかちょっと違うみたいだけどまぁいいよね
	// if( Def_Dbg_LocalDebugMode )
	// {
		// local b_old = (cmdst&def_PP_CS_MoveAble)? 1 : 0;
		// local b_new = (BCMDTbl.CheckCancel( _SkillType_None ))? 1 : 0;
		// if( b_old != b_new )
		// {
			// _dm("★★★結果に違いが！！★★★");
		// }
	// }

	// if( cmdst&def_PP_CS_MoveAble )
	// if( info0.GetCancel( _SkillType_None ) )
	// キャンセルからだしかたどうか調べる
	local isCanseled = 0;

	//前のMvが行動可能だったかどうか、ってので見るべきじゃない？
	//
	local nowPat = BMvTbl.GetMvStatus().DataPattern;
	local isFromAssault = ( nowPat == def_PAT_Mv_Assault_Dodge || nowPat == def_PAT_Mv_Assault_Std || nowPat == def_PAT_Mv_Assault_Air )? 1 : 0;
	
	// if( !BCMDTbl.CheckCancel( _SkillType_None ) && !BMvTbl.GetMvCancel( _SkillType_None ) )
	if( !BCMDTbl.CheckCancel( _SkillType_None ) && !isFromAssault )
	{
		// print("\n 今行動不能！"+BMvTbl.GetMvName()+" pat:"+BMvTbl.GetMvStatus().DataPattern );
		// 行動不能
		// 前の行動が1Fだけで、その行動出す時が行動可能だったら、ズラし押しなんじゃないかな？
		// ボタン２つ押しも一応調べる
		
		local info0 = BCMDTbl.GetCmdInfoEx(0);
		// local info1 = BCMDTbl.GetCmdInfoEx(1);

		// 同時押しボタンのチェックはちゃんと入らない（initなので）のでチェックしないでいいよ多分
		// print("\n f:"+info0.GetFrame()+" DJ:"+Battle_Std.CheckDoujiButton( info0 ) +" none:"+info0.GetCancel( _SkillType_None ) +" MV:"+Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ));
		
		if( info0.GetFrame() <= 2 )
		{
			if( !( info0.GetCancel( _SkillType_None ) && Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CmdLvDZ_OK ) ) ) isCanseled = 1;
		}
		else
		{
			// 同時押し猶予切れ
			isCanseled = 1;
		}
	}
	else
	{
		isCanseled = 0;
	}
	
	if( isCanseled == 0 )
	{
		// print("\n 行動可能から！");
	}
	else // 行動不能だった＝キャンセルで出した　※同時押しのズラしで成立したＢ＋Ｃとかにも適用されるから処理を調整
	{
		// print("\n キャンセルで出した！");
		// しゃがみガード可能にする　＋　空中ガード可能にする
		// BMvTbl.SetAtkGuardFlag( {  guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=254, flag=_ClearFlag_ChangeMv })

		if( Def_Sys_CancelAirAtk_GuardCrouch == 1 ) // キャンセルで出したジャンプ攻撃は屈ガード可能にする
		{
			// しゃがみガード可能にする
			BMvTbl.SetAtkGuardFlag( {  guard=_GuardFlag_GuardCrouch, time=254, flag=_ClearFlag_ChangeMv })
		}
		else if( Def_Sys_CancelAirAtk_GuardCrouch == 2 ) // ガードはそのままだけど特殊な補正をかける予約を入れる
		{
			Battle_Std.MoveCode.AddFlag( def_MC_ExDamageHosei ); // 行動コード(特殊な補正予約)を設定
		}
		else
		{
			// 何もしない
		}
	}
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}
}

// 立ち通常技
Std_MoveTable.Mv_Atk_StdA <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDA);			
		BMvTbl.SetPattern(def_PAT_Atk_StdA);
		BMvTbl.SetPP(def_PP_StdComboChain,1);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち弱攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdB <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		
		BMvTbl.SetComboLimit(DEF_BS_CL_STDB);
		BMvTbl.SetPattern(def_PAT_Atk_StdB);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち中攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_StdC <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定

		BMvTbl.SetComboLimit(DEF_BS_CL_STDC);
		BMvTbl.SetPattern(def_PAT_Atk_StdC);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="立ち強攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// しゃがみ通常技
Std_MoveTable.Mv_Atk_CroA <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv

		BMvTbl.SetComboLimit(DEF_BS_CL_CROA);
		BMvTbl.SetPattern(def_PAT_Atk_CroA);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ弱攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroB <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_CROB);
		BMvTbl.SetPattern(def_PAT_Atk_CroB);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ中攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}
Std_MoveTable.Mv_Atk_CroC <- 
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		//Battle_Std.MoveCode.AddFlag( def_MC_NoJumpCansel ); // 行動コード(通常ＣでもＪＣ不可)を設定

		BMvTbl.SetComboLimit(DEF_BS_CL_CROC);
		BMvTbl.SetPattern(def_PAT_Atk_CroC);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="しゃがみ強攻撃" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//ジャンプ攻撃着地に与えるヒットステータス
local set_AirAtkLandStatus = function()
{
	local hitst = BMvTbl.GetMvHitStatus();
	if( hitst.Type&_HitType_Damage ) //ダメージ与えていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Damage );
	}
	else if( hitst.Type&_HitType_Guard ) //ガードされていたら
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Guard );
	}

}

// ジャンプ通常技
Std_MoveTable.Mv_Atk_AirA <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init
		Battle_Std.MoveCode.AddFlag( def_MC_GRDLowBreak ); // GRDブレイクの効果が短いMv
		
		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRA);
		BMvTbl.SetPattern(def_PAT_Atk_AirA);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ弱攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirA_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirA_Land"] ];//XXX:256はやめる
	}
}

local set_AirAtk_LandMoveableFrame = function( nohit, shield, damage, guard, a_nohit, a_shield, a_damage, a_guard )
{
	local atkst = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	if( atkst&def_PP_AAS_Shielded ) //シールドされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_shield : shield;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( !(atkst&def_PP_AAS_Hit) ) //空振りした（ヒットorガードしなかった）
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_nohit : nohit;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	else if( atkst&def_PP_AAS_Damage ) //ダメージを与えた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_damage : damage;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	else if( atkst&def_PP_AAS_Guard ) //ガードされた
	{
		local frame = (atkst&def_PP_AAS_inAssault)? a_guard : guard;
		BMvTbl.SetMoveableFlag( { move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
}

Std_MoveTable.Mv_Atk_AirA_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirA_LandRecovery,			//空振りした
		def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirB <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRB);
		BMvTbl.SetPattern(def_PAT_Atk_AirB);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ中攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirB_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirB_Land"] ];//XXX:256はやめる
	}
}

Std_MoveTable.Mv_Atk_AirB_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirB_LandRecovery,			//空振りした
		def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);	
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_AirC <- 
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init

		Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
	
		BMvTbl.SetComboLimit(DEF_BS_CL_AIRC);
		BMvTbl.SetPattern(def_PAT_Atk_AirC);
	}
	function FrameUpdate_Std() : (set_AirAtkLandStatus)
	{
		Battle_Std.TypeSE_Play({ type="ジャンプ強攻撃" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
			BMvTbl.SetFinalize(256); //着地したらLandへ
		}
		Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Atk_AirC_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Neutral"], [256,"Mv_Atk_AirC_Land"] ];//XXX:256はやめる
	}
}

Std_MoveTable.Mv_Atk_AirC_Land <- 
{
	function Init_Std() : (set_AirAtk_LandMoveableFrame)
	{
		set_AirAtk_LandMoveableFrame(			//着地硬直を設定
		def_FL_AtkAirC_LandRecovery,			//空振りした
		def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
		def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
		def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
		def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
		def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
		def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
		def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
		);		
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//ダッシュ攻撃Init共通処理
local DashAtk_Init = function( setpattern=1 )
{
	BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=241, flags=_Position_ToolShift } );
	Battle_Std.PcAfterImage_DashAtkInit(); //残像セット

	BMvTbl.SetComboLimit(DEF_BS_CL_DASHCROA);
	BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } );
	local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
	if (nowvec.x<2000) nowvec.x = 2000; //最低値 1.0:2500
	if (nowvec.x>2500) nowvec.x = 2500; //最大値 1.0:3000
	
	Battle_Std.InitCharaVector();		
	BMvTbl.SetMuki(_Direction_Auto);
	BMvTbl.SetPattern (setpattern ); // パターン変更
	
	BMvTbl.SetVector( { x=nowvec.x, addx=(-nowvec.x/20), flags=_Vector_Div } ); //20Fで収束ベクトルを登録
	//BMvTbl.SetMuki(_Direction_Auto); //振り向いちゃダメだよ
	
	Battle_Std.GRD_AddValue({ val=def_GRD_DashAtk_Init, pressure=0, boundplus=1 }); //ダッシュ攻撃での増加

	BMvTbl.ClearHitStatus(); //ヒット情報のクリア
	BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
	
	Battle_Std.MoveCode.AddFlag( def_MC_Atk ); // 行動コード(通常技)を設定
	Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
	BMvTbl.AddComboRate(); // コンボレート加算	
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_NoAtkCansel ); // 通常Ｃから通常技へのキャンセルを除外する
	
	BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Body, time=255, flag=_ClearFlag_ChangeMv } ); // 体無敵にスカる
	
	if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
	{
		Battle_Std.DebugFunc.CallAtkInitScript();
	}
}


Std_MoveTable.Mv_Atk_DashStdB_Direct <- // 前ダッシュを挟まないダッシュ攻撃(Def_Sys_DirectDashDelay F中継するだけ)
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= Def_Sys_DirectDashDelay ) BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_DashStdB" );
	}		
}

Std_MoveTable.Mv_Atk_DashStdC_Direct <- // 前ダッシュを挟まないダッシュ攻撃(Def_Sys_DirectDashDelay F中継するだけ)
{
	function Init_Std()
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= Def_Sys_DirectDashDelay ) BMvTbl.SetFinalize();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Atk_DashStdC" );
	}		
}


// ダッシュ通常技
Std_MoveTable.Mv_Atk_DashStdB <- 
{
	function Init_Std(): (DashAtk_Init)
	{
		DashAtk_Init(def_PAT_Atk_DashStdB);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ中攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}
Std_MoveTable.Mv_Atk_DashStdC <- 
{
	function Init_Std() : (DashAtk_Init)
	{
		DashAtk_Init(def_PAT_Atk_DashStdC);
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="ダッシュ強攻撃" });
	}
	function LastUpdate_Std()
	{
		BMvEff.PcAfterImage_Clear(); //残像の消去
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Dash_F_KazeEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPattern(990);
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,0);
	}
	function FrameUpdate_Std()
	{
		local pmv = Battle_Std.GetPlayerMvName();
		if( pmv != "Mv_Dash_F" && pmv != "Mv_DashWait_F" )
		{
			BMvTbl.SetFinalize(0);
			return;
		}	
	
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //カウンタ勧める
		
		if( cnt>5 && cnt%10==0 ) //おそらくそろそろ走ってる＆一定時間おき
		{
			Battle_Std.CreateObjectEX( { datatype=1, pat="Dash_Kaze", FrameID=[1,2], flags=_Position_ToolShift,
			objectflags=_ObjFlags_EraseParentPatChange
			} );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}



local dashwait_frame = chrparam.Get( { type="ダッシュでかかり硬直Ｆ", chrnum=_ChrNo } );
local dashstop_frame = chrparam.Get( { type="ダッシュ停止不能Ｆ", chrnum=_ChrNo } );
local dashStopKanseiAr = chrparam.Get( { type="ダッシュ停止慣性", chrnum=_ChrNo } );
local dashStopKanseiParam = { val = dashStopKanseiAr[0], frame = dashStopKanseiAr[1], max_vec = dashStopKanseiAr[2], max_add = dashStopKanseiAr[3] };


//デバッグ用ダッシュのフレーム監視
Std_MoveTable.Mv_Null_DashFrameChecker <-
{
	function Init_Std() : (dashwait_frame)
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove  | _ObjFlags_NoRender|_ObjFlags_EraseParentPatChange } );
		BMvEff.SetExist( { level = _Exist_NoHantei } )

		//使ったので初期化
		//LP0 0:でかかり硬直　10:移動中（行動可能・ガード不能） 20:移動中（行動可能・ガード可能）
		BMvTbl.SetLP(0,0); //モード
		BMvTbl.SetLP(5,0); //でかかり硬直フレーム
		BMvTbl.SetLP(6,0); //ガード可能になるまでのフレーム
		BMvTbl.SetLP(7,0); //手動停止できるダッシュかどうか
	}
	function FrameUpdate_Std() : (dashstop_frame)
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.IsDone == 0 ) return; //有効でなかったらすぐ終わる
		
		local push_ok = 0;
		
		local s = BMvTbl.GetMvStatus();
		local skill;
		local rundush = 0;
		
		local mode = BMvTbl.GetLP(0);
		
		if( BMvCore.PushCharaData( player ) )
		{
			//行動不能→行動可能をチェック
			//LP0 0:でかかり硬直　10:移動中（行動可能・ガード不能） 20:移動中（行動可能・ガード可能）
			push_ok = 1;
			
			skill = BCMDTbl.CheckCancel( _SkillType_None );
			
			//FrameIDが100だと途中で停止できるタイプのダッシュなんだ
			local oyas = BMvTbl.GetMvStatus();
			if( oyas.FrameID == 100 ) rundush = 1;
		}
		BMvCore.PopCharaData();
		
		if( push_ok == 0 ) return; //pushできなかったらすぐ終わる
		
		// print( format("\n MvCount:%d mode:%d LP5:%d LP6:%d LP7:%d",s.MvCount, mode, BMvTbl.GetLP(5), BMvTbl.GetLP(6), BMvTbl.GetLP(7) ) );
		
		if( rundush == 1 ) BMvTbl.SetLP(7,1); //停止できるダッシュなのを記憶
			
		//print("\n mode:"+mode+" skill:"+skill);
		switch( mode )
		{
		case 0: //でかかり硬直
			if( skill==255 )
			{
				BMvTbl.SetLP(0,10); //行動可能になったので移動中にmode移行
				BMvTbl.SetLP(5,s.MvCount); //でかかり硬直フレームを記憶
			}
			break;
		case 10: //移動中
			local startup_frame = BMvTbl.GetLP(5); //でかかり硬直が入っているはず
			BMvTbl.SetLP(0,20); //もうガードできるフレームまできたね
			BMvTbl.SetLP(6,s.MvCount); //ガード可能になるまでのフレームを記憶

			if( skill!=255 )
			{
				_dem("【警告】ダッシュ移動中に行動不能");
				BMvTbl.SetLP(0,90); //行動不能になったよ。おかしいね。
			}
			break;
		case 20: //移動中（ガード可）
			BMvTbl.SetFinalize();
			break;
		case 90: //なんかまずそうなとき
			BMvTbl.SetFinalize();
			break;
		}
		
	}
	function Finalize_Std() : (dashstop_frame)
	{
		local startup = BMvTbl.GetLP(5);
		local noguard = BMvTbl.GetLP(6);
		local stop = dashstop_frame;
		local str = "";
		if( BMvTbl.GetLP(7)==1 )
		{
			str = format("\nダッシュ硬直:%2dF (停止まで+%2dF) \n出だしからガード可能まで:%2dF",startup,stop,noguard);
		}
		else
		{
			str = format("\nダッシュ硬直:%2dF\n出だしからガード可能まで:%2dF",startup,noguard);		
		}
		_dp1p( str ); //結果を出力

		BMvTbl.SetDeleteMoveTable();
	}
}

// 66ダッシュもしくはボタンダッシュで生成される
Std_MoveTable.Mv_Null_CheckDashStickHold <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		Battle_Std.GS_DelFlag( def_PP_GS_DashStickHoldEnd );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local mvcheck = Battle_Std.IsMatchMvNameArray( ["Mv_DashWait_F","Mv_Dash_F","Mv_DashStop_F"] );
			
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) )	// 6か3にはいっていなかったら
			{
				Battle_Std.GS_AddFlag( def_PP_GS_DashStickHoldEnd );
			}
			player.pop();
			
			if( !mvcheck ) BMvTbl.SetFinalize( 0 ); // 消える
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_DashStickHoldEnd );
	}
}

Std_MoveTable.Mv_DashWait_F <- // 前ダッシュでかかり硬直
{
	function Init_Std() // 
	{
		// _dp("\n Mv_DashWait_F Init()");
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_F);
		BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		BMvEff.CreateObject( { mvname="Mv_Null_CheckDashStickHold" } ); //ダッシュ中にレバーを前入れっぱなしにしているか
		
		local isBtnDash = ( BMvTbl.GetCmdNumber()==def_CN_Dash_F_Douji )? 1 : 0;
		BMvTbl.SetLP(9,isBtnDash); // 記憶
		if( isBtnDash )
		{
			_dp("\n ボタンダッシュでかかり");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ
		}
		
		if( Def_Dbg_LocalDebugMode )
		{
			BMvEff.CreateObject( { mvname="Mv_Null_DashFrameChecker" } ); //ダッシュのフレームチェックオブジェクト
		}
		
		//ダッシュ風呼び
		local posy = -100; //風エフェクトのＹ座標
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 特殊判定があったらその高さから出す
		{
			posy = rc.sy;
		}
		BMvEff.CreateObject( { x=50, y=posy, mvname="Mv_Dash_F_KazeEff", datatype=1, flags=_Position_ToolShift } );
		
		//でかかり硬直は行動可能にする
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		//ボイス再生
		Battle_Std.TypeSE_Play({ type="前ダッシュ" });
		
		// 停止ジャンプ先の絵を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Dash_F, frame=stopframe, rest=4 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグをつける
	}
	function FrameUpdate_Std() : (dashwait_frame)
	{
		if(Def_Rule_NoDashGuard) BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } );
		
		local s = BMvTbl.GetMvStatus();
		if( s.MvCount >= dashwait_frame ) BMvTbl.SetFinalize(0);
	}
	function LastUpdate_Std() : (dashStopKanseiParam)//ダッシュから抜けるときに呼ぶ
	{
		if( !BMvTbl.FromFinalize() )
		{
			// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
			// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
			if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
			local xvec = 1500;
			BMvTbl.SetVector( { x=xvec, addx=-(xvec/dashStopKanseiParam.frame),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
		}
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Dash_F" );
	}		
}

Std_MoveTable.Mv_Dash_F <- // 前ダッシュ移動部分
{
	function Init_Std() // 
	{
		// BMvEff.CreateObject( { mvname="Mv_DashCountObject" } ); //ダッシュカウンタ管理
		
		// BMvTbl.SetLP(9,0); // ボタンダッシュかどうか
		if( BMvTbl.GetLP(9)==1 )
		{
			// ボタンダッシュ
			_dp("\n ボタンダッシュ");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ
		}

		Battle_Std.Call_FootStepSE(); // //足音再生監視オブジェクト
		
		Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
	}
	function FrameUpdate_Std() : ( dashstop_frame)
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Dash_F, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか
		
		local mvs = BMvTbl.GetMvStatus();
		
		//FrameIDが100だと途中で停止できるタイプのダッシュ(ダッシュ停止不能Ｆが-1ならそも停止不可)
		if( dashstop_frame != -1 && mvs.FrameID == 100 && mvs.MvCount>dashstop_frame) // ホールド可
		{
			if( !BMvTbl.CheckStickHold( (1<<6) | (1<<3) ) )	// 6か3にはいっていなかったら
			{
				BMvTbl.SetFinalize(0);			
			}
		}
		if( mvs.FrameID == 256 ) // 停止まできちゃった
		{
			BMvTbl.SetFinalize(0);
		}		
		
		//移動中行動可能にする（ダッシュの時間が分からないのでループにいれてる）
		BMvTbl.SetMoveableFlag( { move=1, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		if(Def_Rule_NoDashGuard) BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } );
		
	}
	function LastUpdate_Std() : (dashStopKanseiParam)//ダッシュから抜けるときに呼ぶ
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
	
		local vec = BMvTbl.GetVector(0); //vec に現在のベクトルを格納
		local use_vec_x = vec.x;
		if( dashStopKanseiParam.val != 100 )
		{
			use_vec_x = use_vec_x * dashStopKanseiParam.val / 100; // ダッシュ慣性調整
		}
		
		if( dashStopKanseiParam.max_vec != 0 )
		{
			local mvCount = (BMvTbl.GetMvStatus().MvCount-1);
			if( mvCount < 0 ) mvCount = 0;
			local maxXvec = dashStopKanseiParam.max_vec + (mvCount*dashStopKanseiParam.max_add);
			if( use_vec_x > maxXvec ) use_vec_x = maxXvec;
			
			_dpn("ダッシュ慣性:"+vec.x+" -> "+ use_vec_x+" 収束:"+dashStopKanseiParam.frame+" 制限("+mvCount+"F MAX:"+ maxXvec+")");
		}
		BMvTbl.SetVector( { x=use_vec_x, addx=-(use_vec_x/dashStopKanseiParam.frame),flags=_Vector_DivKeep } ); // 収束でダッシュ慣性を登録
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_DashStop_F" );
	}		
}

Std_MoveTable.Mv_DashStop_F <- // 前ダッシュ停止
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Dash_F, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		//ダッシュ停止効果音の再生　29
		BSound.SE_Play( { type=_SeType_Normal, num=29 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
		
		//停止は行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		if(Def_Rule_NoDashGuard) BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } );
		
		Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_DashKansei ); // ダッシュ慣性フラグを引き継ぐ
		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}		


Std_MoveTable.Mv_DashCountObject <- //ダッシュカウンタを設定・初期化する
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=102  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		
		BMvTbl.SetLP(0,0); // ダッシュじゃないMvになってから何フレーム経過したか
	}
	function FrameUpdate_Std() // 
	{
		//終了条件
		//ダッシュ以外で行動可能になる
		//ジャンプする
		// _dpn("チェック中");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		local endflag = false;
		if( player.push())
		{
			local pmvs = BMvTbl.GetMvStatus();
			local isDashMv = Battle_Std.IsMatchMvNameArray( ["Mv_DashWait_F","Mv_Dash_F","Mv_DashStop_F"] );
			local isMovable = BCMDTbl.CheckCancel( _SkillType_None );
			local isAir = BMvTbl.CheckPosState( _PosState_Air );
			player.pop();
			
			//ジャンプしたら終了
			if( isAir ) endflag = true;
			
			//ダッシュ以外の行動になった
			if( !isDashMv )
			{
				//行動可能なら終了
				if( isMovable ) endflag = true;
				
				//ダッシュ以外の行動のまま少したっても終わる
				if( pmvs.CallCount==1 )//1Fに1回
				{
					BMvTbl.AddLP(0,1);//ダッシュ以外の行動時間加算
				}
				if( BMvTbl.GetLP(0)>16 )//16F
				{
					endflag = true;
				}
			}
			else
			{
				//ダッシュ中の行動
				BMvTbl.SetLP(0,0);//ダッシュじゃないMvの時間リセット
			}
		}
		
		if ( endflag )	
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		// _dpn("チェックおわり");
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得	
		if( player.push() )
		{
			BMvEff.StdCall( { type=6, no=103  , param=[ 1,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //ダッシュカウンタ
			
			player.pop();
		}
		BMvTbl.SetDeleteMoveTable();
	}
}


local dageki_mutekiF = chrparam.Get( { type="バクステ打撃無敵Ｆ", chrnum=_ChrNo } );
local nage_mutekiF = chrparam.Get( { type="バクステ投げ無敵Ｆ", chrnum=_ChrNo } );

Std_MoveTable.Mv_Dash_B <- // バクステ
{
	function Init_Std() :(dageki_mutekiF,nage_mutekiF)
	{
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Dash_B);
		BMvEff.SetPlayerTimer( { muteki_nage=nage_mutekiF, muteki_dage=dageki_mutekiF } ); //バクステの無敵時間
		BMvEff.SetPlayerTimer( { muteki_nageX=nage_mutekiF, muteki_dageX=dageki_mutekiF } ); //バクステの無敵時間
		Battle_Std.TypeSE_Play({ type="後ろダッシュ" });
		
		local isReversal = Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		// バクステでのGRD減少処理
		if( !Battle_Std.CheckEnemyisDamage() ) // コンボ中はやらない
		{
			if( isReversal ) 
			{
				Battle_Std.GRD_AddValue({ val=def_GRD_ReversalBackDash, pressure=0, boundplus=1 }); // リバサバクステでの減少
			}
			else
			{
				Battle_Std.GRD_AddValue({ val=def_GRD_BackDash, pressure=0, boundplus=1 }); // 通常バクステでの減少
			}
		}
		
		local isBtnDash = ( BMvTbl.GetCmdNumber()==def_CN_Dash_B_Douji )? 1 : 0;
		if( isBtnDash )
		{
			_dp("\n ボタンダッシュ");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // ボタンダッシュ		
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

//シールド呼び出し共通関数
local Call_BarrierEff = function()
{
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, mvname="Mv_BarrierEff", datatype=1, pat=73,
		flags=_Position_ToolShift,
		objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange });
	}
}

//シールドエフェクトのＭｖ
Std_MoveTable.Mv_BarrierEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); //状態。消滅フレームへ進んだかどうか。
	}
	function FrameUpdate_Std()
	{
		//操作親のFrameIDが10の間はループ
		//違ったら消滅フレームへ飛ぶ
		//それ以外にパターン変化とかでも勝手に消える
		local p = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		BMvCore.PushCharaData( p );
			local plmvst = BMvTbl.GetMvStatus();
		BMvCore.PopCharaData();
		if( plmvst.FrameID!=10 && BMvTbl.GetLP(0)==0 )
		{
			BMvTbl.SetLP(0,1); //もう消滅フレームへ進んだ
			BMvTbl.JumpFrameID(900); //消滅フレームへ
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//シールドの処理共通
local Func_Barrier = 
{
	Init = function(pat=def_PAT_Barrier_Std) : (Call_BarrierEff)
	{
		BMvEff.GuardSP_Set( { val=2 } ); //SPガード状態の設定
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(pat);
		
		Call_BarrierEff(); //バリアエフェクト呼び出し
		Battle_Std.TypeSE_Play({ type="シールド発動" });	
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // 4+DDでCSが出せるようにする		
	},
	Update = function(cmd, grd, time)
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( !Battle_Std.CheckEnemyisDamage() && s.MvCount >= def_FL_Shield_GRDPlusStartFrame ) 
		{
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(grd), pressure=0 }); //相手がやられ以外なら増える	
		}
		
		if( BMvTbl.GetFrameID() == 10 ) // ホールド可
		{
			if( ( !BMvTbl.CheckCommandString( cmd ) && s.MvCount>=time ) || (s.MvCount>= def_FL_Shield_MaxTime) )
			{
				if (BMvTbl.JumpFrameID( 20 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}				
			}			
		}	
	},
	FrameUpdate = function(sp)
	{
		Battle_Std.SetSpGauge_BarrierFU( {value=sp,} ); //バリアによるSPゲージ消費	
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	},
	LastUpdate = function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
	}
}

//シールド
//レジストガード
Std_MoveTable.Mv_Barrier_Std <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Std);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,4D@" ], def_GRD_BarrierS_Frame, def_FL_Shield_StdTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierS_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}			
}

Std_MoveTable.Mv_Barrier_Cro <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Cro);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,1D@" ], def_GRD_BarrierC_Frame, def_FL_Shield_CroTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierC_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
	}
	function Finalize_Std() : (Func_Barrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}			
}

// 空中で立つバグがある
Std_MoveTable.Mv_Barrier_Air <- 
{
	function Init_Std() : (Func_Barrier)
	{
		Func_Barrier.Init(def_PAT_Barrier_Air);
		//着地まで行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
	}
	function Update_Std() : (Func_Barrier)
	{
		Func_Barrier.Update([ "@H,471D@" ], def_GRD_BarrierA_Frame, def_FL_Shield_AirTime);
	}
	function FrameUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.FrameUpdate(def_SP_BarrierA_Frame);
	}	
	function LastUpdate_Std() : (Func_Barrier)
	{
		Func_Barrier.LastUpdate();
		
		//救済措置
		local vec = BMvTbl.GetVector();
		if( vec.y <= 0 && vec.addy <= 0 ) vec.addy = 190;//適当決め打ち
		BMvTbl.SetVector( { addy=vec.addy, flags=_Vector_Normal } );
	}
	function Finalize_Std() : (Func_Barrier)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Barrier_Air_Fall", [256,"Mv_Barrier_Air_Land"] ); //デフォ,[code,mv]...
	}
	function GetFinalizeCode_Std()
	{
		return [ [0,"Mv_Barrier_Air_Fall"],[256,"Mv_Barrier_Air_Land"] ];
	}
}

//空中シールド着地硬直
Std_MoveTable.Mv_Barrier_Air_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAir_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

//空中シールド終了後の落下部分
Std_MoveTable.Mv_Barrier_Air_Fall <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能に
		BMvTbl.SetPattern( 20 ); // 落下パターン指定
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Barrier_AirFall_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_Barrier_AirFall_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_BarrierAirFall_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // 着地硬直
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

local Func_DashBarrier = 
{
	Init = function(pat=def_PAT_Barrier_Std)
	{
		BMvEff.GuardSP_Set( { val=1 } ); //SPガード状態の設定
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(pat);
		
		//Call_BarrierEff(); //バリアエフェクト呼び出し
		Battle_Std.TypeSE_Play({ type="シールド発動" });	
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvTbl.SetWallCount(0); // 無敵バグ対策に壁バウンド回数をリセットする
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // 4+DDでCSが出せるようにする		
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{			
			local o_obj = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=74, flags=_Position_ToolShift } );
			if(o_obj.push())
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );
				o_obj.pop();
			}
		}
		
		Battle_Std.SetCharaFlash_GuardSPCommand(); //ヒカル
		BSound.SE_Play( { type=_SeType_Normal, num=193 } ); //ガードシールド発動音
	
		//発動時のゲージ消費
		if( Def_Sys_GuardShield_UseEXS )
		{
			BMvEff.SetSpGauge( { value=def_SP_GuardShield_Init } );
		}
	},
	Update = function(cmd, grd, time)
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( !Battle_Std.CheckEnemyisDamage() && s.MvCount >= def_FL_Shield_GRDPlusStartFrame ) 
		{
			Battle_Std.GRD_AddValue({ val=Battle_Std.GetGRD_AddValue(grd), pressure=0 }); //相手がやられ以外なら増える	
		}
		
		if( BMvTbl.GetFrameID() == 10 ) // ホールド可
		{
			if( ( s.MvCount>=time ) || (s.MvCount>= def_FL_Shield_MaxTime) )
			{
				BMvEff.GuardSP_Set( { val=0 } );
				//BMvTbl.SetMoveableFlag( { move=1, time=255, flag=_ClearFlag_ChangeMv } );
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } );
				
				if (BMvTbl.JumpFrameID( 20 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}	
			}

			
			/*
			if( ( !BMvTbl.CheckCommandString( cmd ) && s.MvCount>=time ) || (s.MvCount>= def_FL_Shield_MaxTime) )
			{
				BMvEff.GuardSP_Set( { val=0 } );
					
				if (BMvTbl.JumpFrameID( 20 ) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
					BMvTbl.SetFinalize(0);
				}				
			}		
			*/			
		}	
	},
	FrameUpdate = function(sp)
	{
		Battle_Std.SetSpGauge_BarrierFU( {value=sp,} ); //バリアによるSPゲージ消費	
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地
	},
	LastUpdate = function()
	{
		BMvEff.GuardSP_Set( { val=0 } ); //SPガード状態の解除
	}
}

Std_MoveTable.Mv_DashBarrier_Std <- 
{
	function Init_Std() : (Func_DashBarrier)
	{
		Func_DashBarrier.Init(def_PAT_Barrier_Std);
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
	}
	function Update_Std() : (Func_DashBarrier)
	{
		Func_DashBarrier.Update([ "@H,4D@", "@H,1D@" ], def_GRD_BarrierS_Frame, def_FL_Shield_StdTime);
	}
	function FrameUpdate_Std() : (Func_DashBarrier)
	{
		Func_DashBarrier.FrameUpdate(def_SP_BarrierS_Frame);
	}	
	function LastUpdate_Std() : (Func_DashBarrier)
	{
		Func_DashBarrier.LastUpdate();
	}
	function Finalize_Std() : (Func_DashBarrier)
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}			
}






local ground_Assault_AirAtkFrameAr = chrparam.Get( { type="地上アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( ground_Assault_AirAtkFrameAr[0] == -1 ) ground_Assault_AirAtkFrameAr[0] = 10;
if( ground_Assault_AirAtkFrameAr[1] == -1 ) ground_Assault_AirAtkFrameAr[1] = 10;
if( ground_Assault_AirAtkFrameAr[2] == -1 ) ground_Assault_AirAtkFrameAr[2] = 10;

local air_Assault_AirAtkFrameAr = chrparam.Get( { type="空中アサルト硬直", chrnum=_ChrNo } );

//-1ならデフォ値に書き換える
if( air_Assault_AirAtkFrameAr[0] == -1 ) air_Assault_AirAtkFrameAr[0] = 9;
if( air_Assault_AirAtkFrameAr[1] == -1 ) air_Assault_AirAtkFrameAr[1] = 9;
if( air_Assault_AirAtkFrameAr[2] == -1 ) air_Assault_AirAtkFrameAr[2] = 9;


local assault_AirAtkParam =
{
	ground = 
	{
		min = ground_Assault_AirAtkFrameAr[0],
		a = ground_Assault_AirAtkFrameAr[0],
		b = ground_Assault_AirAtkFrameAr[1],
		c = ground_Assault_AirAtkFrameAr[2],
	},
	air = 
	{
		min = air_Assault_AirAtkFrameAr[0],
		a = air_Assault_AirAtkFrameAr[0],
		b = air_Assault_AirAtkFrameAr[1],
		c = air_Assault_AirAtkFrameAr[2],
	},
}

//最小フレームを決める
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.b ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.b
if( assault_AirAtkParam.ground.min > assault_AirAtkParam.ground.c ) assault_AirAtkParam.ground.min = assault_AirAtkParam.ground.c
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.b ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.b
if( assault_AirAtkParam.air.min > assault_AirAtkParam.air.c ) assault_AirAtkParam.air.min = assault_AirAtkParam.air.c

//isAir: 0 地上 1:空中 2:ダッジ
//startup: でかかり硬直
//nomove: startup以降から動けるようになるまで
//最速F　startup+nomove+ジャンプ攻撃発生F

local Make_AssaultFU = function(type=0, startup=6, nomove=14) : (assault_AirAtkParam)
{
	local isGround = (type==0);
	local isAir = (type==1);
	//local isDudge = (type==2);

	local xvec = (isGround)? 3200 : 2800;
	local xmax = 3200;
	local yvec = (isGround)? -3000 : -2400;
	local yadd = 190;
	
	//LP0 ダッジになったかどうか
	//LP1 type  0:地上 1:空中
	
	local use_assult_param = (isGround)? assault_AirAtkParam.ground : assault_AirAtkParam.air;
	
	local func = function() : (type, startup, isGround, isAir, xvec, xmax, yvec, yadd, nomove, use_assult_param)
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		switch( s.FrameID )
		{
		case 10: //地上の開始絵
		case 20: //空中の開始絵
			if( s.MvCount>startup )
			{
				BMvTbl.SetLP(1,type); //typeを記憶（ジャンプ攻撃のでかかりでチェック）//もういらないかも
				// if( isAir ) Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult );//MvのInitで設定してるので不要
				BMvTbl.SetLP(3,2); // アサルトでとんだのを記憶
				
				BMvTbl.JumpFrameID(30); //飛んでみろ
				if( def_SP_Assault_Init )
				{
					BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費
				}
				
				BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
				
				//アサルト発動時のＧＲＤ増加
				if( Battle_Std.CheckEnemyisDamage() ) //相手がやられ中
				{
					//やられ中は増加しない
					//print("\n やられ中なので増加しない");
				}
				else
				{
					//それ以外では増加する
					local addval = Battle_Std.GetGRD_AddValue(def_GRD_Assault_Init)/2;
					Battle_Std.GRD_AddValue({ val=addval, pressure=0, boundplus=0 });
					//print( "\n pt:"+pt+" def_GRD_Assault_Init:"+def_GRD_Assault_Init );
					//GRD残量に応じて増えにくくする

					//Battle_Std.GRD_AddValue({ val=def_GRD_Assault_Init, pressure=0, boundplus=0 });
				}
				
				//飛ぶときは慣性を消そう
				Battle_Std.InitVector(); //ベクトル初期化
				
				//ボイス再生
				Battle_Std.TypeSE_Play({ type="アサルト" });

				local use_xvec = xvec;
				
				BMvTbl.SetLP(0,0); //ダッジモーションになったかどうか
				if( Def_Dbg_AssaultAutoVector && isGround )
				{
					//相手までの距離
					local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
					if( enemy.IsDone ) // 有効かどうか一応チェック
					{
						local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
						
						local muki = BMvTbl.GetMuki();
						// 0〜1.0　相手が右側にいる 1.0〜2.0 相手が左側にいる
						//print("\n muki:"+muki+" angle:"+posst.angle);
						//相手が後ろにいるかどうか
						local isBack = ( muki == 1 && posst.angle >= 1.0 ) || ( muki == -1 && posst.angle <= 1.0 );
						//print("\n isBack:"+isBack);

						use_xvec = posst.distance_x / 24;
						if( use_xvec  > xmax ) use_xvec = xmax;
						if( use_xvec  < 256 || isBack ) use_xvec = 256; //相手が後ろにいたら最小値にする
						
						//ベクトルが少ないときはアサルトだと変なのでダッジモーションを使おう
						if( use_xvec < 1600 )
						{
							BMvTbl.SetPattern(def_PAT_Mv_Assault_Dodge);
							BMvTbl.JumpFrameID(30); //飛んでみろ
							BMvTbl.SetLP(0,1); //ダッジモーションになった
						}
					}
				}
				//print("\nuse_xvec:"+use_xvec);
				
				BMvTbl.SetVector( { x=use_xvec, y=yvec, addx=0, addy=yadd, flags=_Vector_Normal } ); //移動開始
				//BMvTbl.SetVector( { x=2800, y=-3000, addx=0, addy=0, flags=_Vector_Normal } ); //移動開始
				
				local angle = Battle_Std.CCharaVector_GetToolAngle();	

				local eff = BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=66, flags=_Position_ToolShift } );
				if( eff.IsDone )
				{
					BMvCore.PushCharaData( eff );
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
						BMvTbl.SetAngle({ angle=angle });
					BMvCore.PopCharaData();
				}
				
				if( isGround ) //地上の時だけ
				{
					local use_pat = (BMvTbl.GetLP(0)==0 )? 65 : 64; //通常エフェクトorダッジエフェクト
					local eff = BMvEff.CreateObject( { x=-50, y=0, mvname="", datatype=1, start_pat=use_pat, flags=_Position_ToolShift } );
					if( eff.IsDone )
					{
						BMvCore.PushCharaData( eff );
							BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
						BMvCore.PopCharaData();
					}
				}
				
				BMvTbl.AddAirCount( def_AC_Assault, 1 ); // アサルトカウンタ加算して再度使えないように
				BMvTbl.AddAirJumpCount(1);  //ジャンプ回数を加算し二段ジャンプした扱いにする
				BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる
				
				/*
				Battle_Std.CreateObjectEX( { x=0, y=-200, datatype=1, pat="Assault_Kaze", FrameID=[1,2], flags=_Position_ToolShift,
				objectflags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround,
				initfunc = function()
				{
					local angle = 9000;
					BMvTbl.SetAngle({ angle=angle });
					local speed = (-1500-(BMvEff.Random_Limit(2000)))*2.0;
					local v = BMvEff.GetVector_FromAngle( { angle = ((angle+7500)/5000.0), speed = speed } );
					BMvTbl.SetVector( { x=v.x, y=v.y, flags=_Vector_Normal } );
				}
				} );
				*/
			}
			break;
			break;
		case 30: //とんでるところループ１
		case 35: //とんでるところループ２　※pat67はループしてない
			if( s.MvCount>(startup+6) ) BMvTbl.JumpFrameID(40);
//			if( s.MvCount>(5+5) && !BMvTbl.CheckButtonHold( (1<<3) ) ) BMvTbl.JumpFrameID(40);
			break;
		case 40:
			//BMvTbl.SetVector( { addy=190, flags=_Vector_Normal } ); //移動開始
		case 45: //この絵から行動可能になる
			if( s.MvCount>(startup+nomove)  )
			{
				BMvTbl.JumpFrameID(100);
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
				BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
				BMvTbl.SetLP(3,1); //減速処理やった
			}
			break;
		case 100:
			break;
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256); //着地

		// アサルト硬直にキャラ差を付ける処理
		{
			local mvcount = s.MvCount;
			
			// _dp("\n use_assult_param:"+use_assult_param.min+", "+use_assult_param.a+", "+use_assult_param.b+", "+use_assult_param.c );
			//assault_AirAtkParam : JA, JB, JC
			if( mvcount > startup+use_assult_param.min )
			{
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=254, flag=_ClearFlag_ChangeMv } ); // 行動可能だけどガード不能にする
				BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
			}
			
			if( mvcount > startup+use_assult_param.a )
			{
				// _dp("\n a");
				Battle_Std.LP_AddFlag(2,1);
			}
			if( mvcount > startup+use_assult_param.b )
			{
				// _dp("\n b");
				Battle_Std.LP_AddFlag(2,2);
			}
			if( mvcount > startup+use_assult_param.c )
			{
				// _dp("\n c:"+mvcount);
				Battle_Std.LP_AddFlag(2,4);
			}
		}
	}
	
	return func; //
}

//アサルトをBaseDataで作り直し
Std_MoveTable.Mv_Assault_Std <-
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Std);
		BMvTbl.JumpFrameID(10); //地上の開始へ
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費		
		//BMvTbl.SetVector( { x=256, y=-128, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり
		//Battle_Std.TypeSE_Play({ type="アサルト" });

		BMvTbl.SetLP(0,0); //先行入力チェック用

		BMvTbl.SetLP(2,0); //行動可能フラグ用
		BMvTbl.SetLP(3,0); //減速処理やったかどうか
		
		BMvTbl.SetPP(def_PP_AssultFrame,0);
		
		BMvEff.AddSkillCount( _SkillCount_Assult ); // 履歴カウンタを加算
		BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
		
		//ここはbasedata側でCS可能だけじゃなくEX可能にもなっている（IWを出しやすくするため）
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_StdAssult );
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Assault_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
		//アサルトで飛んだ後(LP3==2)にやる
		//ジャンプ攻撃がXベクトル減速を受けないで出てしまうとアレなので、
		//LP3==2でまだ減速していなかったらやる
		if( BMvTbl.FromFinalize()==0 )
		{
			// 減速処理まだやってなくて動こうとしたらやる
			if( BMvTbl.GetLP(3) == 2 )
			{
				_dp("\n 減速処理");
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
			}
		}
		local mvs = BMvTbl.GetMvStatus();
		BMvTbl.SetPP(def_PP_AssultFrame,mvs.MvCount);
		// _dpn("カウント:"+mvs.MvCount);
	}
}

Std_MoveTable.Mv_Assault_Std.FrameUpdate_Std <- Make_AssaultFU(0, 4, 10 );

//アサルト共通着地Mv
Std_MoveTable.Mv_Assault_Land <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Assault_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}	

Std_MoveTable.Mv_Assault_Air <-
{
	function Init_Std() // 
	{
		//現在のベクトルを保存する
		local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
		BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Air);
		BMvTbl.JumpFrameID(20); //空中の開始へ
		
		BMvTbl.SetVector( { x=256, y=-128, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり			
		//BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費
		//Battle_Std.TypeSE_Play({ type="アサルト" });

		BMvTbl.SetLP(0,0); //先行入力チェック用
		
		BMvTbl.SetLP(2,0); //行動可能フラグ用
		BMvTbl.SetLP(3,0); //減速処理やったかどうか		
		
		BMvEff.AddSkillCount( _SkillCount_Assult ); // 履歴カウンタを加算		
		BMvTbl.SetPrio( _CharaPrio_Near ); // アサルトによるプライオリティ手前
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult );
		
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_LightLegsMuteki );//小足属性へ空振り予定のMV
		BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 小足無敵にスカる(空中は1Fから)
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Assault_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		// LastUpdateタイミングでベクトル与えるときはやられ中かチェックする
		// つかまれ時のBound_Captureだとベクトル初期化がされないので動きっぱなしになる
		if( Battle_Std.CheckPlayerisBound() ) return; // バウンド時はなし
		
		//アサルトで飛んだ後(LP3==2)にやる
		//ジャンプ攻撃がXベクトル減速を受けないで出てしまうとアレなので、
		//LP3==2でまだ減速していなかったらやる
		if( BMvTbl.FromFinalize()==0 )
		{
			// 減速処理まだやってなくて動こうとしたらやる
			if( BMvTbl.GetLP(3) == 2 )
			{
				_dp("\n 減速処理");
				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
			}
		}
		
		//でかかり数フレーム目で抜けると上昇してっちまう
		//・自分が空中
		//・addy<=0
		//だったらあがってっちゃうから保存したベクトルで上書きする
		local nowvec = BMvTbl.GetVector(0);
		local isAir = ( BMvTbl.CheckPosState(_PosState_Air)!=0 );
		
		//print("\n addy:"+nowvec.addy+" isAir:"+isAir);
		
		if( nowvec.addy <= 0 && isAir )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.y <= 0 && vec.addy <= 0 ) vec.addy = 250; //無いはずだけど万が一これだとういてっちまうので救済
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Normal } );			
		}
		BMvTbl.SetVector( { x=0, addx=0, y=0, addy=0, flags=_Vector_Keep } ); //一応消しておく
	}
}

Std_MoveTable.Mv_Assault_Air.FrameUpdate_Std <- Make_AssaultFU(1, 4, 9);


//一応時間停止あり（ダブルアップ防止用）
local func_AssaultCanselInit = function()
{
	local stop_time = 8;
	
	//時間停止
	BMvEff.SetStopTime( { time=stop_time, stopme=1 } ); //自分もとまるstopme
	//次のフレームでとまるからアサルトの絵まで進むよ

	//GuardCanselエフェクトよび
	//GuardCansel
	Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
	datatype=1, pat="GuardCansel", angle="rand",
	objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
	});
	
	//画面を揺らす？
	BMvEff.SetCamera_Quake( { time=8, type=0, } );
	
	//自キャラを発光？
	Battle_Std.SetCharaFlash_GuardCansel(); //GCで発光
}

Std_MoveTable.Mv_AssaultCansel_Std <-
{
	function Init_Std() : (func_AssaultCanselInit)
	{
		func_AssaultCanselInit();
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Assault_Std" );
	}
}

Std_MoveTable.Mv_AssaultCansel_Air <-
{
	function Init_Std() : (func_AssaultCanselInit)
	{
		func_AssaultCanselInit();
		Battle_Std.EnemyDamageFlag_Add( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手に記憶
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Assault_Air" );
	}
}




//
local func_GuardCanselInit = function()
{
	local stop_time = 20;
	
	//時間停止
	BMvEff.SetStopTime( { time=stop_time } );

	//GuardCanselエフェクトよび
	//GuardCansel
	Battle_Std.CreateObjectEX({ x=0, y=-200, flags=_Position_ToolShift,
	datatype=1, pat="GuardCansel", angle="rand" });
	
	//画面を揺らす？
	BMvEff.SetCamera_Quake( { time=8, type=0, } );
	
	//自キャラを発光？
	Battle_Std.SetCharaFlash_GuardCansel(); //GCで発光
	
	//着地まで無敵にする
	//LastUpdateと着地Mvで消える
	BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	
	//ＳＰゲージ予約分を消費
	BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } );
}

Std_MoveTable.Mv_GCAssault_Std <-
{
	function Init_Std() : (func_GuardCanselInit) 
	{
		BMvTbl.SetMuki(_Direction_Auto);		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Std);
		BMvTbl.JumpFrameID(10); //地上の開始へ
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費		
		//BMvTbl.SetVector( { x=256, y=-128, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり
		//Battle_Std.TypeSE_Play({ type="アサルト" });
		
		//行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		func_GuardCanselInit(); //GC共通処理
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_GCAssault_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_GCAssault_Std.FrameUpdate_Std <- Make_AssaultFU(0, 8 );
Std_MoveTable.Mv_GCAssault_Std.LastUpdate_Std <- function()
{
	BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
}

//アサルト共通着地Mv
Std_MoveTable.Mv_GCAssault_Land <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア（投げは確ると思われ）
		//BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Assault_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_GCAssault_Air <-
{
	function Init_Std() : (func_GuardCanselInit)
	{
		//現在のベクトルを保存する
		local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
		BMvTbl.SetVector( { x=nowvec.x, addx=nowvec.addx, y=nowvec.y, addy=nowvec.addy, flags=_Vector_Keep } ); //保存
		
		BMvTbl.SetPattern(def_PAT_Mv_Assault_Air);
		BMvTbl.JumpFrameID(20); //空中の開始へ
		
		BMvTbl.SetVector( { x=256, y=-128, addx=0, addy=0, flags=_Vector_Normal } ); //ダッシュ開始ふんばり			
		BMvEff.SetSpGauge( {value=def_SP_Assault_Init,} ); //発動でのSP消費
		//Battle_Std.TypeSE_Play({ type="アサルト" });

		//行動不能にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		
		func_GuardCanselInit(); //GC共通処理
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_GCAssault_Land"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_GCAssault_Air.FrameUpdate_Std <- Make_AssaultFU(1, 8 );
Std_MoveTable.Mv_GCAssault_Air.LastUpdate_Std <- function()
{
	BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
}


//アサルト共通着地Mv
Std_MoveTable.Mv_GCAssault_Land <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵をクリア（投げは確ると思われ）
		//BMvTbl.SetMoveableFlag( { move=0, time=def_FL_Assault_LandRecovery, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.InitVector(); //ベクトル初期化
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}



//投げ
Std_MoveTable.Mv_Throw_F <-
{
	function Init_Std() // 
	{
		// _dp("\n Mv_Throw_F_Init()");
		
		Battle_Std.InitCharaVector() //慣性を残したベクトル初期化
		//Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Throw_F);
		BMvTbl.ClearHitStatus(); // ヒット情報のクリア
		Battle_Std.ThrowTech.SetThrowMvFlag(); //投げ属性Mvを設定
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCode.AddFlag( def_MC_GRDBreak_FatalDmgHosei ); // 行動コード(GRDブレイクで攻撃力アップ)を設定
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_InActive );
		
//		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //再生済みフラグ
		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_TechWait, frame=0, rest=2 } ); // 投げつかみ分岐先予約		
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Throw_F_Hit, frame=0, rest=6 } ); // 投げ成立先予約
		
		if( BMvTbl.GetCmdNumber()==def_CN_Throw_F && Battle_Std.GS_CheckFlag( def_PP_GS_SlideDashThrow ) ) // スライド投げ
		{
			_dp("\n ★★スライドダッシュ投げ★★");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // Mv_Throw_F + def_MC1_GenFlag == スライド投げ
		}
	}
	function HitInterrupt_Std()
	{
		local neutral_tech = 0;
		
		local p_mvs = BMvTbl.GetMvStatus();
		
		//この時点で相手はダメージ状態…ではない（つかみ命令入ってない）
		//のけぞりは当然入ってくる
		if( Battle_Std.CheckDamageTiming() )
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			
			local isBMCapture = false;
			if( enemy.IsDone )
			{
			
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local hs = BtlMvStd.GetBoundStatus();
					isBMCapture = ((hs.isCapture&(1<<1))!=0); //Bound or Muteki Capture
					//print("\nhs.isCapture"+hs.isCapture+" isBMCapture:"+isBMCapture);		
					
					local e_mvs = BMvTbl.GetMvStatus();
					local e_mvn = BMvTbl.GetMvName();
					
				BMvCore.PopCharaData(); // 
				
				//Battle_Std.DrawDebugAttackInfo("c "+e_mvs.MvCount+" pc "+p_mvs.MvCount+" n "+e_mvn );
				
				if( e_mvs.MvCount == p_mvs.MvCount && e_mvn == "Mv_Throw_F" )
				{
					//Battle_Std.DrawDebugAttackInfo("neutral tech" );
					
					Battle_Std.SetThrowHitFinalize(1024);
					neutral_tech = 1;
				}
				
			}
			if(	!neutral_tech )
			{
				if( isBMCapture ) //BM掴みかどうか
				{
					// _dm("Boundか投げ無敵中をつかんだので補正をかけます");

					//コンボ補正あり
					BMvEff.ComboView_Set( { val=def_HOSEI_BoundMutekiCapture, type=1 } ); // 乗算
					// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_BoundMutekiCapture,1,0,0,0, 0,0,0,0,0, 0,0 ]} );

					// Battle_Std.DrawDebugAttackInfo("! Gouin Nage");	
					Battle_Std.SetThrowHitFinalize(512); // ヒット分岐ファイナライズ		
				}
				else
				{
					Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
				}
				// 相手にフラグを与える
				if( enemy.push() )
				{
					// print("\n 状態セット:"+_AsFlag_DamageEx);
					// BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=64, flag=0 } ); // 特殊やられ
					
					enemy.pop();
				}
			}
		}
	}
	function FrameUpdate_Std()//
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		if( s.MvCount>=4 && (BMvTbl.GetLP(1)==0) ) //投げ失敗確定後＆フラグがたっていない
		{
			Battle_Std.InitVector(); //prevent visual oddity with sliding into opponent
			
			BMvTbl.SetLP(1,1); //再生済み
			Battle_Std.TypeSE_Play({ type="投げスカり" });
			Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
			
			//投げスカりのGRD減少
			// これは相手がやられ中でも減らす。なんとなく。
			Battle_Std.GRD_AddValue({ val=def_GRD_ThrowMiss, pressure=0, boundplus=0,target=0 });
		}
	}
	function Finalize_Std() // 
	{
		//BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //カウンタ初期化
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_F_TechWait"], [512,"Mv_Throw_F_TechWait2"],[1024,"Mv_Throw_F_NeutralTech"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame(); //1F後に投げ属性モーションを1F後に削除
	}
}

Std_MoveTable.Mv_Throw_F_NeutralTech <- //throw trade tech state
{
	function Init() // 
	{
		BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		
		
		local rel_type = 201;
		BMvEff.ThrowRelease( { type=rel_type, airrecover=0, flags=0 } );
		
		
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			local p_enemy = BMvCore.GetNearEnemyCharaData();
			
			local ret = BMvEff.CapturePlayer( { target = p_enemy } ); // because we cant actually tell who initiated the original throw the opposite party will be thrown as well
			if( ret == 1 )
			{
				BMvEff.ThrowRelease( { type=rel_type, airrecover=0, flags=0 } );
				
				BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
				Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
				
				BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
				
				Battle_Std.SetCharaFlash_TechSuccessInit();
				
				BMvEff.AttackInfoString_Set({ word=def_AISW_DoubleTechHit } );
				
				BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
				
				//BMvEff.SetBoundSt( { settime = 140 } );
			}
			
			enemy.pop();
		}
		
		BMvTbl.SetVector( { x=-4500, addx=0, flags=_Vector_Bound } );
		
		Battle_Std.CreateObjectEX({ x=0, y=-250, flags=_Position_ToolShift,datatype=1, pat="Eff_TechHit", objectflags=_ObjFlags_MoveTimeStopAll });
		Battle_Std.CreateObjectEX({ mvname="", datatype=1, pat=132, objectflags=_ObjFlags_MoveTimeStopAll });
				
		//BMvEff.CreateObject( { mvname="", datatype=1, start_pat=132, flags=0 } ); //投げぬけ音声
		
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=16, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		Battle_Std.SetCharaFlash_TechSuccessInit();
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_DoubleTechHit } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate() // 
	{
		local p_enemy = BMvCore.GetNearEnemyCharaData();
		if(p_enemy.push())
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			
			p_enemy.pop();
		}
		
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}



Std_MoveTable.Mv_Throw_F_TechWait <- //つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{	
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
		
		if( Battle_Std.ThrowTech.CheckTechImpossible() )
		{
			BMvTbl.SetFinalize(512); //投げ抜けできないフレーム中なので終わろう
		}
		else //投げぬけ失敗フレームではない投げ
		{
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット
		
		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(0); //ヒット座標につかみエフェクト表示
		
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			// BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh1:Frame:"+s.FrameID);
		if( s.MvCount>def_FL_Tech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local delay = def_FL_Tech - s.MvCount;
					if ( ( BMvTbl.GetMvStageStatus().IsTrainingBattle() && Def_Dbg_TechTimingLog==2 ) || Def_Dbg_TechTimingLog==1 ) Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				BMvCore.PopCharaData(); // 	
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
//		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );	
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
	}
}


Std_MoveTable.Mv_Throw_F_TechWait2 <- //（金投げ）つかんでから投げ抜けを待つまで〜分岐
{	
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化(一応)
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする
		Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生した音声を停止		

		if( Battle_Std.ThrowTech.CheckTechMissFrame() )
		{
			BMvTbl.SetFinalize(512); //投げ抜け失敗フレーム中なので終わろう		
		}
		else //投げぬけ失敗フレームではない投げ
		{
			//掴んだ相手側に投げられ回数を加算
			local enemy = BMvCore.GetCaptureCharaData();
			if( enemy.push() )
			{
				BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
				
				enemy.pop();
			}
			BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含める			
		}
		
		Battle_Std.ThrowTech.SetPos(); //つかむ前の自分と相手の座標を記憶する		
		
		BMvTbl.SetPattern(def_PAT_Throw_F_TechWait); //投げ抜け待機パターンに変更(ここで相手はのけぞる)
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット

		//相手のけぞってからの処理
		Battle_Std.ThrowTech.ShiftOverGamenHajiX(); //相手が画面外にいたら自分の座標ごと補正をかける	
		Battle_Std.ThrowTech.DrawThrowEffect(1); //ヒット座標につかみエフェクト表示	
		
		local enemy = BMvCore.GetCaptureCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\nTh2:Frame:"+s.FrameID);
		
		if( s.MvCount>def_FL_BoundTech )
		{
			BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
			return;
		}
		//print( "\n"+s.MvCount );
		
		if ( Battle_Std.ThrowTech.CheckTechCommand() ) //相手が投げ抜けコマンドを入れた
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.IsDone )
			{
				BMvCore.PushCharaData( enemy ); // ここから敵の処理
					local delay = def_FL_BoundTech - s.MvCount;
					// Battle_Std.DrawDebugAttackInfo("TechSafe: "+delay+"F" );
				BMvCore.PopCharaData(); // 	
			}
			
			Battle_Std.ThrowTech.DrawTechEffect(); //投げ抜け演出を表示
			Battle_Std.ThrowTech.TechRelease(); //投げ抜けされた時の開放処理
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"],[512,"Mv_Throw_F_TechMissWait"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.ThrowChara_SetCamera( 0 ); //投げているキャラをカメラ処理に含めない
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

// 投げ抜け不能フレームの時　と　行動不能を単純に掴んだ時 がある
Std_MoveTable.Mv_Throw_F_TechMissWait <- //投げ抜けされないつかみの時
{	
	function Init_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ抜けされないつかみ成功" });
		
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定

		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.TypeSE_Play({ type="ガード失敗" });
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない

			enemy.pop();
		}
		
		Battle_Std.ThrowTech.SetMuteki(); //つかみ中は自分も相手も無敵にする	
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function Update_Std() //投げぬけ猶予中
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//すぐ投げるとわかりにくいのでdef_FL_BoundTech分まつ
		if( s.MvCount>def_FL_BoundTech ) BMvTbl.SetFinalize(0); //投げ抜け猶予が終わったので終わる
		//if( s.MvCount>def_FL_Tech ) BMvTbl.SetFinalize(0); //　演出長すぎだからこうする
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Throw_F_Hit", [256,"Mv_Teched"] ); //デフォ,[code,mv]...
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

Std_MoveTable.Mv_Throw_F_Hit <- //投げ成立（以降は投げ抜け不可）
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		BMvTbl.SetMvAction( def_MVA_Throw );
		
		//相手の無敵は解除
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); // ここから敵の処理
			{
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
			}
			BMvCore.PopCharaData(); // 
		}
	
		//まず相手のGRDを減らす
		Battle_Std.GRD_AddValue({ val=def_GRD_ThrowHit, pressure=0, boundplus=1,target=1 });
		Battle_Std.TypeSE_Play({ type="投げつかみ成功" });
		
		//パターンが最後まできてれば次に進む。まだならUpdate中もチェックするからそこで。
		//local s = BMvTbl.GetMvStatus(); // ステータス取得					
		//if( s.DataPattern==def_PAT_Throw_F_TechWait && s.FrameID==0 )

		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 )
		{
			// _dp("\n 後ろ投げ");
			BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ReverseThrow );
		}
		
		Battle_Std.ThrowTech.SetThrowParam(); //エフェクト座標に相手をやられ絵でセット

		//パターンを変更
		BMvTbl.SetPattern(def_PAT_Throw_F_Hit);
		
		
		if ( ( BMvTbl.GetMvStageStatus().IsTrainingBattle() && Def_Dbg_TechTimingLog==2 ) || Def_Dbg_TechTimingLog==1 ) Battle_Std.Create_TechDelayCheckObject(); //相手の投げコマンドチェックオブジェクト生成
		
		if( enemy.push() )
		{
			// print("\n 状態クリア:"+_AsFlag_DamageEx);
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=0, flag=0 } ); // 特殊やられを消す
			
			enemy.pop();
		}
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="投げ成功" });	
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		
		//通常投げ始動は最低保証に制限をかける
		Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_NormalThrow );
		// Battle_Std.SetHosyoHosei( def_HosyoHosei_NormalThrow );
	}
}

//相手側に生成される
Std_MoveTable.Mv_Obj_CheckTechDelay <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll  } );	
		BMvEff.SetExist( { level = _Exist_NoHantei } )
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );	
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if(s.CallCount==0)
		{
			local flags = false;
			//print("\nFrame:"+s.MvCount);

			local p = BMvCore.GetPlayerCharaData(); // 情報を得る
			
			if( p.IsDone ) // 有効かどうか一応チェック
			{
				BMvCore.PushCharaData( p ); // 
					if( BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } ) ) flags = true;
				BMvCore.PopCharaData();
			}
			
			if( flags )
			{
				local frame = (s.MvCount+1);
				if ( ( BMvTbl.GetMvStageStatus().IsTrainingBattle() && Def_Dbg_TechTimingLog==2 ) || Def_Dbg_TechTimingLog==1 ) Battle_Std.DrawDebugAttackInfo("TECH LATE: "+frame+"FRAME" );
				
				// _dm("投げ抜け:"+frame+"F遅い");
				BMvTbl.SetFinalize(0);
			}
			if( s.MvCount>60 ) BMvTbl.SetFinalize(0); //とりあえず遅すぎるのは終わる
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//投げ抜けする側はBoundです
Std_MoveTable.Mv_Teched <- //投げ抜けられ（ガード絵でプルプル）
{
	function Init_Std() // 
	{
		BMvTbl.SetPattern(def_PAT_GuardS); //立ちガードの見た目でプルプルする
		//BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く
		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定 (バーストされない)
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Add } ); //カメラから切り離す
	}	
	function FrameUpdate_Std()
	{
		BMvTbl.SetMuki(_Direction_Auto); //相手の方を向く

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		//バグ対策
		if( s.MvCount > 60 )
		{
			BMvTbl.SetFinalize(0);
		}
		
		// ここからの処理なんか変な気がする
		// 座標が元から変化しないように書いてあるだけかも？なので触らないでおく
		
		if( s.MvCount%4==0 && BMvTbl.GetLP(1)==0 ) //プルプルさせる
		{
			BMvTbl.SetLP(1,1); //状態変更
			BMvTbl.SetPosition( { x=6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
			BMvTbl.Frame_Proc( 0, _ValSet ); //１枚目の絵にする
		}
		else if( (s.MvCount+2)%4==0 && BMvTbl.GetLP(1)==1 )
		{
			BMvTbl.SetLP(1,0); //状態変更
			BMvTbl.SetPosition( { x=-6, y=0, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
			BMvTbl.Frame_Proc( 1, _ValSet ); //２枚目の絵にする
		}
		
		//アニメパターンのループ処理
		if( s.MvCount%6==0 )
		{
			local frame = BMvTbl.Frame_Proc( 0, _ValAdd );
			BMvTbl.Frame_Proc( 1-frame, _ValSet ); //１枚目と２枚目でループ
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase } ); //カメラに含める
	}	
}

//投げ抜け押し返し攻撃
Std_MoveTable.Mv_Bound_0023 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		//print("\n投げ抜け攻撃！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		BMvTbl.SetLP(0,0); //投げ抜けフラグ初期化
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		BMvTbl.SetPrio( _CharaPrio_Near ); //一番手前にする
		
		BMvEff.AddSkillCount( _SkillCount_ThrowRecover ); // 履歴カウンタを加算
		Battle_Std.MoveCode.AddFlag( def_MC_NoBurst ); // 行動コード(バーストできない)を設定 
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		
		if( s.MvCount>=16 && (BMvTbl.GetLP(0)==0) )
		{
			//相手を押し返すポイント
			BMvTbl.SetLP(0,1); //投げ抜けフラグ
			
			//自分のＧＲＤにボーナス
			Battle_Std.GRD_AddValue( { val=def_GRD_ThrowTech_Success, boundplus=1 } );					
			
			//相手のＧＲＤを減らす
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				BMvEff.GRD_AddValue( { val=def_GRD_ThrowTech_Success_Enemy, pressure=0, boundplus=1 } );
				
				enemy.pop();
			}
			
			//ここで相手を強引に掴んでMv_Bound_0024で開放する？
			//print("\nここ？");
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local epos = BMvTbl.GetPosition(); // 位置取得
				
				enemy.pop();

				epos = Battle_Std.GamePos2ShiftPos( epos ); //オフセット座標に変換
				
				epos.x /= 128; //ツール座標に
				
				//epos.x += 50; //少し離す

				local ret = BMvEff.CapturePlayer( { target = enemy } );
				if( ret == 1 )
				{
					BMvEff.ThrowParam( { x=epos.x });
					BMvEff.ThrowRelease( { type=24 } );
				}
				
			}
		}
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
		
		BMvTbl.SetCommandLongDelay(2); //extend reversal buffer
	}
}

//投げ抜けられガードポーズ
Std_MoveTable.Mv_Bound_0024 <- 
{
	function Init_Std() // 
	{
		/*
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=-250, flags=_Position_ToolShift,
		datatype=1, pat="Eff_TechHit",
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする		
		
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		*/
		
		Battle_Std.BoundInit();
		//print("\n投げ抜けられガード！");
		//BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_nageX=254 } );
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=0, muteki_nageX=254 } );
		
		Battle_Std.CreateObjectEX({ x=0, y=-250, flags=_Position_ToolShift,
		datatype=1, pat="Eff_TechHit",
		objectflags=_ObjFlags_MoveTimeStopAll
		});
		
		//ヒットストップと揺らしを発生
		BMvEff.SetCamera_Quake( { time=12, type=1, } ); //横ゆれ
		BMvEff.SetStopTime( { time=12, stopme=2 } ); // 自分も停止する＆自分の停止が発生していたらそれの消去もする
		
		BMvTbl.SetPrio( _CharaPrio_Far  ); //一番後ろにする		
		
		//BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_DamageEx|_AsFlag_GuardRev, time=255, flag=_ClearFlag_ChangeMv } ); // 特殊やられ
	}
	function Update_Std()
	{
		//地上状態では符号が反転しないようにする
		if( BMvTbl.CheckPosState( _PosState_Ground  ) )
		{
			//今プラスのベクトルで、次のフレームがマイナスベクトルか？
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound });
			//print(format("\n x:%d addx:%d",vec.x, vec.addx));
			if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
			{
				BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
			}
		}
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_nageX=0 } );		
		BtlMvStd.ClearBound(); // 状態解除
		
		BMvTbl.SetCommandLongDelay(5); //extend reversal buffer
	}
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出
Std_MoveTable.Mv_SkillTeched <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//投げ抜けする側はBoundです
//コマ投げとか用の投げ抜けられ演出2(最初からガードポーズに変化している版)
Std_MoveTable.Mv_SkillTechedPatChange <- //投げ抜けられ（つかんだ絵でプルプル）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		BMvTbl.SetPattern(17); //ガードポーズを取る
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );		
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}

//
Std_MoveTable.Mv_SkillTechedRecover <- //投げ抜けられ２（復帰でよけるタイプ）
{
	function Init_Std() // 
	{
		//BMvTbl.SetMuki(_Direction_Auto); //振り向きを入れると座標変更前なので逆向いたりするよ
		//BMvTbl.SetPattern(410); //つかみポーズでプルプルする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	}	
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );		
	}	
}


//イベントとか

Std_MoveTable.Mv_Startup <- //開幕かませ
{
	function Init_Std() // 
	{
		BMvEff.CreateObject( { mvname="Mv_AuraKanriObject", datatype=0 } );
		if( Def_Dbg_LocalDebugScriptPath )
		{
			Battle_Std.DebugFunc.CallStartupDebugScript();
		}
		
		BMvTbl.SetFinalize(0);	
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}	
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Standby <- //登場演出
{
	function Init_Std() // 
	{
		BMvEff.CreateObject( { mvname="Mv_AuraKanriObject", datatype=0 } );
		
		if( Def_Dbg_LocalDebugScriptPath )
		{
			Battle_Std.DebugFunc.CallStartupDebugScript();
		}

		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Standby);
		//確認用にID見て分岐
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		if( s.FrameID == 1 ) //２パターンあった
		{
			if(BMvEff.Random_Limit(100)>=50)
			{
				BMvTbl.SetPattern(def_PAT_Standby+1);
				Battle_Std.TypeSE_Play({ type="登場２" });
			}
			else
			{
				Battle_Std.TypeSE_Play({ type="登場１" });			
			}
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="登場１" });
		}
		
		
		// ネットワーク対戦時に操作キャラに「YOU」を出す
		// MEMO:登場演出が入らないようなことがある場合、ここを通らないのでYOUは表示されない（そんなことはないはずだけど）
		local data = BMvTbl.GetMvNetworkInfo();
		if( data.NetworkVsControlType == _NetworkVsControlType_Controller )		
		{
			// ネットワーク対戦で、自分が操作キャラの場合
			local eff = BMvEff.CreateObject( { datatype=1, start_pat="sys_you", mvname="Mv_SystemHereYouAre" } );
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得	
		switch( s.DataPattern )
		{
		case def_PAT_Standby_1: //登場１
			Battle_Std.TypeSE_Play({ type="登場１_FU" });
			break;
		case def_PAT_Standby_2: //登場２
			Battle_Std.TypeSE_Play({ type="登場２_FU" });
			break;
		}
	}
	function LastUpdate_Std() //
	{
		BMvTbl.SetRoundStart(); //戦闘開始可能状態にする
	}
	function Finalize_Std() // 
	{
		//ラウンド開始準備オッケー処理？
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// アイコンは時間でも勝手に消えるが、スクリプトでも挙動を操作している
Std_MoveTable.Mv_SystemHereYouAre <-
{
	function Init_Std()
	{
		BMvTbl.SetMuki( _Direction_Right );//文字なので右向き固定
		BMvTbl.SetPosition( { y=-435*128, } );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoCamera } );
		
		BMvTbl.SetLP(0,0);//消滅開始したら1
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount>600 )//保険処理
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		if( Battle_Std.GetUpdateFrameID( mvs ) == 900 )
		{
			BMvTbl.SetLP(0,1); // 勝手に消滅まで進んだ
		}
		
		if( BMvTbl.GetLP(0)==0 )
		{
			local rs = BMvTbl.GetMvRoundStatus();
			if( rs.CharaMoveMode == _CharaMoveMode_Enable )
			{
				// _dpn("きえる");
				// キャラが動けるようになったら消す
				BMvTbl.JumpFrameID(900);
				BMvTbl.SetLP(0,1); // 消滅開始に飛んだので1
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


// どんな勝利なのかを取得
// ２回取得するからもしかしたらズレることもあるかもしれない
local get_winstatus = function()
{
	local ret_param = { wintype="ラウンド勝利", life="通常" };

	local rs = BMvTbl.GetMvRoundStatus();

	local emv = 0; //敵のMv名
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		emv = BMvTbl.GetMvName();
		
		enemy.pop();
	}
	
	local hp_ratio = BCMDTbl.GetHPRatio();
	if( hp_ratio>=70 )
	{
		ret_param.life = "圧勝";
	}
	else if( hp_ratio<=30 )
	{
		ret_param.life = "辛勝";
	}
	else
	{
		ret_param.life = "通常";
	}		
	
	if( emv!="Mv_Lose" && rs.isWinRound )
	{
		// 決着タイムアップ勝利
		ret_param.wintype = "決着タイムアップ勝利"; // タイムアップ決着
	}
	else if( rs.isWinRound )
	{
		// 決着勝利
		ret_param.wintype = "決着勝利"; // 決着
	}
	else
	{
		// ラウンド勝利
		ret_param.wintype = "ラウンド勝利";
	}
	
	return ret_param;
}

Std_MoveTable.Mv_Win <- //勝利分岐
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		//Battle_Std.PcAuraEffect_AllAuraEnd(); //オーラがあったら消す
		//BMvTbl.SetPattern(def_PAT_Win);
		
		//BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[120,999,60], type_in=3 } );		
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_WinCamera" } ); //演出開始

		local winst = get_winstatus(); // 勝利情報取得
		
		switch( winst.wintype )
		{
		case "決着タイムアップ勝利":
			BMvTbl.SetFinalize(100);
			break;
		case "決着勝利":
			BMvTbl.SetFinalize(200);
			break;
		case "ラウンド勝利":
			BMvTbl.SetFinalize(100);
			break;
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WinPattern", [100,"Mv_RoundWinPattern"], [200,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

//勝利時のカメラ注目
Std_MoveTable.Mv_WinCamera <-
{
	function Init_Std()
	{
		//開始位置は画面中央？
		local pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_DispCamera } );
		BMvTbl.SetPosition(pos);
		
		//このオブジェクトに注目する
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[45,999,60], type_in=3 } );
		
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoRender } ); //_ObjFlags_NoRender
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		BMvEff.SetCamera_FocusKeep( 999 ); // チュートリアルで長いこと放置されるので無限ループにする
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local maxlen = def_POS_GamenHajiX - (512*128);

		//操作親をホーミングしてカメラの目標にする
		local p = BMvCore.GetPlayerCharaData(); // 情報を得る
		
		if( p.IsDone ) // 有効かどうか一応チェック
		{
			BMvCore.PushCharaData( p ); // 
				local pos = BMvTbl.GetPosition( 0 );
			BMvCore.PopCharaData();

			local posst;
			local tpos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			tpos.y = 0;
			if( pos.x <= -maxlen )
			{
				tpos.x = -maxlen;
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else if(pos.x >= maxlen)
			{
				tpos.x = maxlen;				
				posst = BMvEff.GetPointStatus( { position=tpos } ); // 位置情報取得
				Battle_Std.SetMuki_CCharaPosition( tpos );
			}
			else
			{
				posst = BMvEff.GetPointStatus( { target=p } ); // 位置情報取得
				//常に親の方を向き続ける
				Battle_Std.SetMuki_PlayerPosition();				
			}
			
			if( posst.distance_x>=512 )
			{
				BMvTbl.SetVector( { x=posst.distance_x/20,} );

			}
			else
			{
				Battle_Std.InitVector();
			}
		}
		else
		{
			Battle_Std.InitVector();		
			//print("x");
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetNextMoveTable( "..." );
	}
} 


Std_MoveTable.Mv_WinPattern <- //決着勝利アニメ
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Win);
		
		local winst = get_winstatus(); // 勝利情報取得
		
		BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
	
		if( Def_Dbg_RoundStatus ) _dp1p("\nけっちゃこ勝利");
		if( Battle_Std.TypeSE_Play({ type="決着勝利" }) == 0 ) //何も再生されなかった
		{
			//残り体力を見て分岐
			switch( winst.life )
			{
			case "圧勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_圧勝" });
				BMvTbl.SetPP(def_PP_TMP0,1); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "辛勝":
				Battle_Std.TypeSE_Play({ type="決着勝利_辛勝" });
				BMvTbl.SetPP(def_PP_TMP0,2); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			case "通常":
				Battle_Std.TypeSE_Play({ type="決着勝利_通常" });
				BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
				break;
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_RoundWinPattern <- //決着勝利アニメ
{
	function Init_Std() : (get_winstatus)
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_RoundWin);
		
		local winst = get_winstatus(); // 勝利情報取得
		
		BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
		
		if( winst.wintype == "決着タイムアップ勝利" )
		{
			if( Def_Dbg_RoundStatus ) _dp("\nけっちゃこタイムアップ勝利");
			Battle_Std.TypeSE_Play({ type="タイムアップ決着勝利" });
		}
		else
		{
			if( Def_Dbg_RoundStatus ) _dp1p("\nラウンド取得");
			if( Battle_Std.TypeSE_Play({ type="ラウンド勝利" }) == 0 ) //何も再生されなかった
			{
				//残り体力を見て分岐
				switch( winst.life )
				{
				case "圧勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_圧勝" });
					BMvTbl.SetPP(def_PP_TMP0,1); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
					break;
				case "辛勝":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_辛勝" });
					BMvTbl.SetPP(def_PP_TMP0,2); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
					break;
				case "通常":
					Battle_Std.TypeSE_Play({ type="ラウンド勝利_通常" });
					BMvTbl.SetPP(def_PP_TMP0,0); // どの音声を再生したか 0:通常 1:圧勝　2:辛勝
					break;
				}
			}
		}		
	}
	function LastUpdate_Std() //
	{
		//念のため
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする
	}	
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetRoundEnd(); //戦闘終了状態にする？
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}


Std_MoveTable.Mv_TimeupLose <- //時間切れ負け
{
	function Init_Std() // 
	{
		Battle_Std.InitVector();
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_TimeupLose);
		//Battle_Std.PcAuraEffect_AllAuraEnd(); //オーラがあったら消す
		
		//確認用にID見て分岐
		local s = BMvTbl.GetMvStatus(); // ステータス取得					
		if(s.FrameID == 1 ) //２パターンあった
		{
			if(BMvEff.Random_Limit(100)>=50)
			{
				BMvTbl.SetPattern(def_PAT_TimeupLose+1);
				Battle_Std.TypeSE_Play({ type="タイムアップ敗北２" });
			}
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="タイムアップ敗北１" });
		}
	}
	function Finalize_Std() // 
	{
		//次のラウンドへの処理？
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//キャラのオーラを出す時にオーラの時間分こいつが出てる
//終了時に持続のフラグを消す
Std_MoveTable.Mv_Obj_CharaAura <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		// local PSFlag = BMvTbl.GetLP(0);
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) > 0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else
		{
			BMvTbl.SetFinalize(0); //オーラの予定されてた持続時間終了
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable(); //ばいばーい
	}
	function LastUpdate_Std()
	{
		//抜ける時にフラグをなんちゃらする
		Battle_Std.PcAuraEffect_CommonAuraEnd();
	}
}

//リバーサル時間を減らすだけのオブジェクト
Std_MoveTable.Mv_Obj_ReversalTime <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //
			local pp = BMvTbl.GetPP( def_PP_ReversalLeftTime );
			if( pp>0 ) pp--;
			BMvTbl.SetPP( def_PP_ReversalLeftTime, pp );
		BMvCore.PopCharaData();
		
		//print("\n残り:"+pp);
		
		if( pp <= 0) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト
Std_MoveTable.Mv_Obj_DelayPlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 ディレイ
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		//print(".");
		//LPを減らしていって0になったら再生する
		if( BMvTbl.GetLP(0)>0 )
		{
			BMvTbl.AddLP(0,-1);
		}
		else //タイミングがきた
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- Delay",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//ＳＥを遅らせて再生するオブジェクト2 Param0まち
Std_MoveTable.Mv_Obj_DelayParam0PlaySE <-
{
	function Init_Std()
	{
		//print("\n開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		//LP0 まつParam0
		//LP1 再生する番号
	}
	function Update_Std() //Updateじゃないと投げ関係で不具合でる
	{
		local mvs = Battle_Std.GetPlayerMvStatus();
		//print("."+mvs.Param0+"\n");
		//操作親のParam0を監視して一致したら再生
		
		if( mvs.Param0 == BMvTbl.GetLP(0) )
		{
			//再生
			local num = BMvTbl.GetLP(1);
			_vdm(format("PlaySE [%3d] -- DelayParam0",num));
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


/*
Std_MoveTable.Mv_HitMutekiLog <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}
*/

//常に持続するオブジェクト（試合が終わると消滅）
//キャラクターのオーラを管理する
Std_MoveTable.Mv_AuraKanriObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvs.CallCount!=0 ) return; // 1フレームに1回のみに変更
		
		if( mvs.MvCount%7==0 ) //気持ち軽くする AC:6 PS3:7
		{
			local noaura = Battle_Std.GetPSFlag(def_PP_PS_NoAura); //オーラは張らないフラグチェック
			if( !noaura ) Battle_Std.PcAuraEffect_AuraCheck(); //オーラが必要ならはる	
		}
	}
	function Update_Std()
	{
		//今何のオーラが出ているか？はPSフラグで管理する
		//GRDでオーラを出すなら、オーラ出ている間持続するオブジェクトを生成
		//何かで上書きされたあと、終わるタイミングでPSフラグはリセットされる
		//いつ終わるかが不明だね
		//汎用上書きオーラ呼び出し関数：オーラつけるだけ
		//汎用上書きオーラ終了関数　　：オーラ消してフラグも消す		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンド取得状態
			local endflag = ((BMvTbl.GetPP(def_PP_PlayerStatus)&def_PP_PS_AuraKanriEnd)!=0);
			
			player.pop();
			if( rs.isKo || endflag ) // 決着or終われフラグがあったら終了
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize_Std()
	{
		Battle_Std.PcAuraEffect_AllAuraEnd();
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Skill_63214SP <-
{
	function Init_Std()
	{
		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全消費
		if( isVorpal )
		{
			BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
		}
		else
		{
			BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
		}
	}
}

/*
Std_MoveTable.Mv_Skill_63214SP <-
{
	function Init()
	{
		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全消費
		if( isVorpal )
		{
			BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
		}
		else
		{
			BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
		}
		
		Battle_Std.Reversal.CheckTime_DrawInfo( 1 ); // リバーサルなら文字表示
		
		BMvTbl.ClearHitStatus(); //ヒット情報のクリア(Mv引継ぎでヒット情報残すことなんてない)
		BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
		
		BMvTbl.SetPattern("63214SP");

		Battle_Std.InitWorthSkill();
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで別の行動に移れる
		Battle_Std.TypeSE_Play({ type="Mv_Skill_63214SP_Init" }); //発動ボイス
		//_dm("?"+Voice.Init);

		
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //暗転技も慣性は残さない方向で
		
		
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_SPAction ); // 行動コード(必殺技)を設定
		Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
		

		BMvTbl.AddComboRate(); // コンボレート加算

		
		Battle_Std.AddMoveCode_CSAntenGaesiSkill(); // CSからの暗転返しで出した技ならフラグを立てる

		BMvTbl.SetMvAction( def_MVA_SPSkill );
	}
}

Std_MoveTable.Mv_Skill_J63214SP <-
{
	function Init()
	{
		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		BMvEff.GRD_UseStock( { val=stock } ); // 全消費
		if( isVorpal )
		{
			BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
		}
		else
		{
			BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
		}
		
		Battle_Std.Reversal.CheckTime_DrawInfo( 1 ); // リバーサルなら文字表示
		
		BMvTbl.ClearHitStatus(); //ヒット情報のクリア(Mv引継ぎでヒット情報残すことなんてない)
		BMvTbl.CalcHitValue(-10000);  // 攻撃回数情報のクリア
		
		BMvTbl.SetPattern("J63214SP");

		Battle_Std.InitWorthSkill();
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで別の行動に移れる
		Battle_Std.TypeSE_Play({ type="Mv_Skill_63214SP_Init" }); //発動ボイス
		//_dm("?"+Voice.Init);

		
		BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_DivKeep } ); //暗転技も慣性は残さない方向で
		
		
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_SPAction ); // 行動コード(必殺技)を設定
		Battle_Std.InitAtkSkillMv(); // 通常技や必殺技の共通初期化
		

		BMvTbl.AddComboRate(); // コンボレート加算

		
		Battle_Std.AddMoveCode_CSAntenGaesiSkill(); // CSからの暗転返しで出した技ならフラグを立てる

		BMvTbl.SetMvAction( def_MVA_SPSkill );
	}
}
*/

// コンセントレーションポーズで攻撃するタイプ
Std_MoveTable.Mv_DyingIWEAtk <-
{
	function Init_Std()
	{
		// _dp("\n Mv_DyingIWEAtk Init()");
		
		Battle_Std.MoveCode.AddFlag( def_MC_SPAction ); // 行動コード(ＳＰ)を追加
		
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Convert);	

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); // 地面にくっつける
	
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		//発動時にGRDは空になります
		local isVorpal = (BMvEff.GRD_GetJudgeResult()>0);
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );;
		BMvEff.GRD_UseStock( { val=stock } ); // 全消費
		if( isVorpal )
		{
			BMvEff.GRD_ClearVorpal( 0 ); // ヴォーパルを解除する
		}
		else
		{
			BMvEff.GRD_SetBreak( 0, def_GRDBF_IWE, def_GRDBF_IWE ); // ブレイク
			BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
		}
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWEAtk } ); //一定時間ゲージ増加に制限をかける
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); 
		
		//EXカットインと時間停止をつける　でも技はSPアクション？
		Battle_Std.Init_ExistAtkSkill(); //SPゲージ消費・カットイン呼び出し
		Battle_Std.MoveCode.AddFlag( def_MC_Skill|def_MC_EXAction ); // 行動コード(必殺技)を設定
		BMvTbl.SetMvAction( def_MVA_EXSkill );
		
		Battle_Std.TypeSE_Play({ type="IWE攻撃" });
		
		local muteki_f = 25 + def_FL_EXCutinStopTime;
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_f, muteki_dage=muteki_f, muteki_nageX=muteki_f, muteki_dageX=muteki_f } ); // ちょっと長めに無敵
		
		
		BMvTbl.SetLP(0,0); // ヒットしたかどうか
		BMvTbl.SetLP(1,0); // カットイン消去したかどうか
		
		// ループの抜け先を予約
		local stopframe = BMvEff.GetFrameIDNum( 256 );
		if( stopframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Convert, frame=stopframe, rest=8 } );
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.CallLoopEndCache_FrameID( def_PAT_Convert, 256, 10 ); // キャッシュ予約Pat, 予約FrameID, 何F毎に呼ぶか

		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		local mvcount = mvs.MvCount;
		local frameid = mvs.FrameID;
		local mode = BMvTbl.GetLP(0);
		
		if( frameid == 200 ) BMvTbl.JumpFrameID( 100 ); // 無限ループ
		if( mvs.MvCount > (65 + def_FL_EXCutinStopTime) )
		{
			BMvTbl.SetFinalize( 256 ); // 抜ける
		}
		if( mvs.MvCount > (45 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(0) == 1 )
			{
				BMvTbl.SetFinalize(512);	
			}
		}
		if( mvs.MvCount == (10 + def_FL_EXCutinStopTime ) && mvs.CallCount == 0 ) // 実際には +5Fぐらいの発生になる
		{
			local vo_eff = BMvEff.CreateObject( { x=0, y=-260, mvname="Mv_DyingIWEAtk_AtkEff", datatype=1, start_pat=99, flags=_Position_ToolShift } );
			if( vo_eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
				 
				vo_eff.pop();
			}
		}
		
		if( mvs.MvCount > (25 + def_FL_EXCutinStopTime) )
		{
			if( BMvTbl.GetLP(1) == 0 )
			{
				BMvEff.CutInProc_Erase(); //カットイン消去
				BMvTbl.SetLP(1,1); // 消した記憶
			}		
		}

	}
	function Finalize_Std() // 
	{
		local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
		if( fc != 512 ) // Mv_Skill_IWEXIST 以外
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_DyingIWEAtk_Modori"], [512,"Mv_Skill_IWEXIST"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
		if( !BMvTbl.FromFinalize() )
		{
			BMvEff.CutInProc_Erase(); //カットイン消去
		}
	}
}

//コンセントレーションの戻り
//これは行動不可にしておくとdef_PAT_Convertにキャラ差があるのでダメだよ
Std_MoveTable.Mv_DyingIWEAtk_Modori <-
{
	function Init_Std() // 
	{
		Battle_Std.JumpFrameIDEX(256, def_PAT_Convert, 0); //設定FrameID, 上書きPattern, 失敗時FinalizeCode
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); //行動可能に変更		
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_DyingIWEAtk_AtkEff <-
{
	function Init_Std()
	{
		BMvTbl.SetLP(0,0); // ズームとかは１回だけにする
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local mvs = BMvTbl.GetMvStatus();
			local effhit = BMvTbl.GetLP(0);
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetLP(0,1); // ヒット
				// _dp("\n VOeffヒット");
				
				if( effhit == 0 )
				{
					BMvEff.Slowmotion_Set( { time=60, power=6666, power_minus=10000/60 } );
					BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[8,30,15], type_in=1, type_out=2 } );
					BMvEff.SetCamera_Quake( { time=35, type=2, clear=1 } );
				}

				// 弾ヒットで本体無敵にして、ヒット後相打ちにならないようにする
				local muteki_f = 60;
				BMvEff.SetPlayerTimer( { muteki_nage=muteki_f, muteki_dage=muteki_f, muteki_nageX=muteki_f, muteki_dageX=muteki_f } ); // ちょっと長めに無敵
				
				player.pop();
				
				BMvTbl.SetLP(0,1); // effhitを1にして、玉ヒット処理したよ
			}
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				// 以降の玉とかヒットしないように玉無敵にする
				BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_FireBall, time=8, flag=0 } ); // 無敵
				BMvEff.SetPlayerTimer( { muteki_dage=8, } ); // ちょっと無敵
				
				// これをやると肝心の間違いヒットのフォローがきかない
				/*
				local bs = BtlMvStd.GetBoundStatus();
				if( bs.isBound && bs.Num == 239 ) // イグジスト浮かせがちゃんとあたってたら！
				{
				}
				*/
				
				enemy.pop();
			}
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_IWEAtk_Eff <-
{
	function Init_Std()
	{
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				BMvTbl.SetLP(0,1); // ヒット
				// _dp("\n VOeffヒット");
				
				player.pop();
			}
			
			local mvs = BMvTbl.GetMvStatus();
			//二度チェックする必要あるか？　まぁ念のため
			//（そもそもこれは相手が_MvStFlag_DangerHPDef の時だけ呼ばれるので大丈夫なはずだけど、回復されるかもしれないし…）
			//逆の状況には対応していない。発動時体力あって、ヒット時２５％未満だとダメ。
			if( mvs.flags & _MvStFlag_DangerHPAtk ) //HPが危険状態な相手を殴っている
			{
				local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
				if( player.push() )
				{
					BMvEff.CreateObject( { mvname="Mv_IWEXS_able" } );
					
					player.pop();
				}
				// BMvTbl.SetPP(def_PP_Temp,1); //着地硬直をヒット時のものにする
			}			
		}
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_DyingIWEAtk_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		if( BMvTbl.GetLP(0) == 0 ) // ヒットしてない
		{
			BMvTbl.SetMoveableFlag({ move=0, time=12, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

// 即死するIWE
Std_MoveTable.Mv_SpecialIWEXIST <-
{
	function Init_Std()
	{
		// _dp("\n★即死するIWE発動");
		BMvEff.ComboView_Set( { val=-100, type=2 } ); // 減算-200で100以上にする
		BMvEff.ComboView_Set( { val=100, type=0 } ); // 上書き100で補正100%に戻す

		BMvEff.ComboView_Set( { val=-200, type=2 } ); // 減算-200で300にする
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST" );
	}	
}

// クロスキャストヴェールオフからのIW？
// これを経由してエフェクトだしたらするのも無くはない気がする
Std_MoveTable.Mv_ComboVO_IW <-
{
	function Init_Std()
	{
		_dp("\n★コンボVOからのやつ");
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP" );
	}
}

Std_MoveTable.Mv_Liberate <- 	//リベレート　ヴェールオフ
{
	function StepMode()
	{
		//print("\nStepMode");
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
		
	}
	function Init_Std() //
	{
		local stop_time = 20;
		
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stop_time-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		
		{
			BMvEff.SetStopTime( { time=stop_time, stopme=0, bounderase=1 } );
			
			BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
			
			local eff = BMvEff.CreateObject( { x=0, y=-250, datatype=1, start_pat=270, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		
		// _dp("\n Mv_Liberate_Init()");
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSkill );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
	
		//Battle_Std.PcAuraEffect_LiberateInit(); //ヴェールオフのオーラ
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);
		
		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-64, addx=0, addy=0, flags=_Vector_Normal } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		BMvTbl.SetPP(def_PP_Temp,0); //汎用変数初期化

		BMvTbl.SetLP(0,0); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //最大タメではないヴェールオフか
		//BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		/*
		local isOverLiberate = ( BMvEff.Liberate_Get() == _SpGaugeMode_OverLiberate)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				enemyisDangar = (BCMDTbl.GetHPRatio()<=30);
			BMvCore.PopCharaData(); //
		}
		if( isOverLiberate && enemyisDangar )
		{
			BMvTbl.SetLP(3,1); //IFX可能ヴェールオフですのう
		}
		*/
		
		//BMvEff.Slowmotion_Set( { time=999, power=5000 } );
		//BMvTbl.SetLP(9,0);
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
		
		//BMvTbl.Frame_Proc( 1, _ValAdd );
		
						
								
		//BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=77, flags=_Position_ToolShift } );
		
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		//local IFX = BMvTbl.GetLP(3);
		BMvTbl.AddLP(1,1); //フレームカウント進める
	
		switch( mode ) //mode:LP0
		{
		case 0: //初期
			if( s.FrameID == 20 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}
			else if( cnt>6 ) //ver1.02:6
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				if( BMvTbl.CheckButtonHold( mask ) < 100 ) //要求と一致未満
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}

			}
			break;
		case 1: //次のタメの絵
			if( s.FrameID == 30 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}		
			else if( cnt>10 ) //ver1.02:cnt>1
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				//ためてないor前の絵でタメを解除していたら抜ける
				if( BMvTbl.CheckButtonHold( mask ) < 100 ) //要求と一致未満orタメ解除済
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
				else if( cnt>3 )
				{
					// _dm("ためきった");
					//タメきった
					BMvTbl.SetFinalize(512); //最大タメヴェールオフ
					BMvTbl.JumpFrameID(20); //この絵でもうちょいまって！
					StepMode();
				}
			}
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 2: //抜け先
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
			}
			break;
		case 3: //爆発開始
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(40);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>30 ) StepMode();
			if( cnt==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } );
				
				BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
				BMvEff.Liberate_SetType( _LiberateType_Normal ); // 通常ヴェールオフ
				BMvEff.Liberate_SetMinusValue( def_NormalVO_MinusValue );
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				local pos = 
				{
					x=0,
					y=-260,
				}
				
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					pos.x = rc.sx;
					pos.y = rc.sy;
				}
				
				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0; //

				// if( enemy_isDamage==0 ) //生発動なら
				// {
					// //発動時に体力を消費する
					// if( isOverLiberate )
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_OverLiberate } );
					// }
					// else
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_Liberate } );
					// }
				// }
				
				//92:100%生
				//93:100%コンボ
				//94:200%orタメ生
				//95:200%orタメコンボ
				//96:IWX生
				//97:IWXコンボ
				
				local usepat = 92; //ヴェールオフで使うエフェクト・判定
				if( isOverLiberate ) //200%開放の時
				{
					usepat = (enemy_isDamage)? 95 : 94; //コンボ中とそれ以外で分ける
				}
				else
				{
					usepat = (enemy_isDamage)? 93 : 92; //コンボ中とそれ以外で分ける				
				}

				local vo_eff = BMvEff.CreateObject( { x=pos.x, y=pos.y, mvname="Mv_Liberate_Eff", datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				if( vo_eff.push() )
				{
					BMvTbl.SetLP(0,enemy_isDamage);
					BMvTbl.SetLP(1,isOverLiberate);
					
					vo_eff.pop();
				}
				
				// 後ろのもやもや
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					//暗転時とかは表示しないように
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					
					eff.pop();
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす

				BMvEff.SetPlayerTimer( { muteki_nage=4, muteki_dage=4 } );
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}		
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"],[512,"Mv_MaxLiberate"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}


/*
Std_MoveTable.Mv_Liberate <- 	//リベレート　ヴェールオフ
{
	function StepMode()
	{
		//print("\nStepMode");
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
		
	}
	function Init_Std() //
	{
		// _dp("\n Mv_Liberate_Init()");
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSkill );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
	
		//Battle_Std.PcAuraEffect_LiberateInit(); //ヴェールオフのオーラ
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);
		
		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-64, addx=0, addy=0, flags=_Vector_Normal } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		BMvTbl.SetPP(def_PP_Temp,0); //汎用変数初期化

		BMvTbl.SetLP(0,0); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //最大タメではないヴェールオフか
		//BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		
		local isOverLiberate = ( BMvEff.Liberate_Get() == _SpGaugeMode_OverLiberate)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				enemyisDangar = (BCMDTbl.GetHPRatio()<=30);
			BMvCore.PopCharaData(); //
		}
		if( isOverLiberate && enemyisDangar )
		{
			BMvTbl.SetLP(3,1); //IFX可能ヴェールオフですのう
		}
		
		
		//BMvEff.Slowmotion_Set( { time=999, power=5000 } );
		//BMvTbl.SetLP(9,0);
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		//local IFX = BMvTbl.GetLP(3);
		BMvTbl.AddLP(1,1); //フレームカウント進める
	
		switch( mode ) //mode:LP0
		{
		case 0: //初期
			if( s.FrameID == 20 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}
			else if( cnt>6 ) //ver1.02:6
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				if( BMvTbl.CheckButtonHold( mask ) < 100 ) //要求と一致未満
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
			}
			break;
		case 1: //次のタメの絵
			if( s.FrameID == 30 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}		
			else if( cnt>1 ) //ver1.02:cnt>1
			{
				//ホールドチェック
				local mask = (1<<0)|(1<<1)|(1<<2);
				//ためてないor前の絵でタメを解除していたら抜ける
				if( BMvTbl.CheckButtonHold( mask ) < 100 || BMvTbl.GetLP(2)==1 ) //要求と一致未満orタメ解除済
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
				else if( cnt>12 )
				{
					// _dm("ためきった");
					//タメきった
					BMvTbl.SetFinalize(512); //最大タメヴェールオフ
					BMvTbl.JumpFrameID(20); //この絵でもうちょいまって！
					StepMode();
				}
			}
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 2: //抜け先
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
			}
			break;
		case 3: //爆発開始
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(40);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>30 ) StepMode();
			if( cnt==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } );
				
				BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
				BMvEff.Liberate_SetType( _LiberateType_Normal ); // 通常ヴェールオフ
				BMvEff.Liberate_SetMinusValue( def_NormalVO_MinusValue );
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				local pos = 
				{
					x=0,
					y=-260,
				}
				
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					pos.x = rc.sx;
					pos.y = rc.sy;
				}
				
				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0; //

				// if( enemy_isDamage==0 ) //生発動なら
				// {
					// //発動時に体力を消費する
					// if( isOverLiberate )
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_OverLiberate } );
					// }
					// else
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_Liberate } );
					// }
				// }
				
				//92:100%生
				//93:100%コンボ
				//94:200%orタメ生
				//95:200%orタメコンボ
				//96:IWX生
				//97:IWXコンボ
				
				local usepat = 92; //ヴェールオフで使うエフェクト・判定
				if( isOverLiberate ) //200%開放の時
				{
					usepat = (enemy_isDamage)? 95 : 94; //コンボ中とそれ以外で分ける
				}
				else
				{
					usepat = (enemy_isDamage)? 93 : 92; //コンボ中とそれ以外で分ける				
				}

				local vo_eff = BMvEff.CreateObject( { x=pos.x, y=pos.y, mvname="Mv_Liberate_Eff", datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				if( vo_eff.push() )
				{
					BMvTbl.SetLP(0,enemy_isDamage);
					BMvTbl.SetLP(1,isOverLiberate);
					
					vo_eff.pop();
				}
				
				// 後ろのもやもや
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.push() )
				{
					//暗転時とかは表示しないように
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					
					eff.pop();
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす

				BMvEff.SetPlayerTimer( { muteki_nage=13, muteki_dage=13 } );
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}		
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"],[512,"Mv_MaxLiberate"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

*/

Std_MoveTable.Mv_Liberate_End <- //落下部分
{
	function Init_Std()
	{
		local vec = BMvTbl.GetVector(0);
		if( vec.y <= 0 ) //まだ上昇してるようなら下げよう
		{
			Battle_Std.InitVector(); //ベクトル初期化
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=250, flags=_Vector_Normal } );
		}
		
		// 衝撃波がヒットしてたら無敵で落下
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Liberate_Land"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}

Std_MoveTable.Mv_Liberate_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		local frame = (BMvTbl.GetPP(def_PP_Temp)==1)? def_FL_LiberateHit_LandRecovery : def_FL_Liberate_LandRecovery;
		//着地パターンには進んでるだろうし、状態の移行だけ行って着地硬直を設定する
		BMvTbl.SetMoveableFlag({ move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		
		// 衝撃波がヒットしてたら行動可能になるまでを無敵にする
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=frame, muteki_dage=frame } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}

// コンボＶＯ
Std_MoveTable.Mv_ComboLiberate <- 	//リベレート　ヴェールオフ
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
		
		//【トロフィー】実戦でクロスキャストヴェールオフを使用した。
		BMvTbl.Achievement_Unlock(2);
		
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSkill );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-1800, addx=0, addy=128, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		// local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		// local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		// local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
		
		BMvTbl.SetLP(0,0); // カウンタ
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		if( stock>6 ) stock=6; //なんか多いときがある気がするので
		local isSuperChainShift = (stock>=6)? 1 : 0; //すごいチェインシフトの条件		
		
		BMvTbl.SetLP(1,isSuperChainShift);

		BMvEff.GRD_SetConvertBreak( { time=0 } );
		
		BMvEff.GRD_UseStock( { val=20 } );
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		//CVO発動時・相手が動けないタイミングで演出
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			Battle_Std.DrawInActiveEffect(); // ダメそうな演出だけ入れる
			enemy.pop();
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.FrameID != 0 )
		{
			local now_fra = BMvTbl.GetLP(0);
			if( mvs.CallCount == 0 ) BMvTbl.AddLP(0,1);
			
			// local frames = [2,2,2,2,3,3,3,3,3];
			local frames = [9,8,6,3,2,3,3,2,2];
			
			local now_total = 0;
			
			if( now_fra >= frames[ mvs.DataFrame%frames.len() ] )
			{
				BMvTbl.SetLP(0,0); // カウンタ初期化
				
				if( mvs.DataFrame+1 >= frames.len() )
				{
					BMvTbl.SetFinalize( 0 ); // 足りないのでエラー回避
					return;
				}
				else
				{
					BMvTbl.Frame_Proc( 1, _ValAdd ); // 進める
				}
			}
			
			switch( Battle_Std.GetUpdateFrameID( mvs ) )
			{
			case 10:
				BMvEff.SetStopTime( { time=28 } ); //チェインシフトの時間停止
				
				local usepat = 104;//( BMvTbl.GetLP(1) )? 76 : 82; //エフェクトのパターンを決める
				BMvEff.CreateObject( { x=0, y=-300, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				BMvEff.CutInProc_Set({ time=[3,37,10], cutin_mv="",erasetype=0, bgtype=1 });
				
				
				if( Battle_Std.TypeSE_Play({ type="クロスキャストヴェールオフ" }) )
				{
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				}
				break;
			case 20:

		
				break;
			case 40: // 開放
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="CVO" } );
				
				// 瀕死で、じゃなくて体力の割合で計算で、
				// 瀕死になっていたら共通（以前と同じ）だと、覚醒飛ばしが無くなる
				// 瀕死でのみ強いだと、一応気をつけることができる、はず

				BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Div } );
				local usepat = ( isDying )? 103 : 102;
				local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_ComboVO_HitEffect", start_pat=usepat, x=0, y=-200*128 } );
				
				BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
				BMvEff.Liberate_SetType( _LiberateType_Combo ); // コンボヴェールオフ
				
				// def_DyingComboVO_MinusValue も def_ComboVO_MinusValue も140なので意味がない
				// local useVal = ( isDying )? def_DyingComboVO_MinusValue : def_ComboVO_MinusValue;
				
				BMvEff.Liberate_SetMinusValue( def_ComboVO_MinusValue );
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす
				break;
			}
		}
		else
		{
			BMvTbl.SetFinalize(0);
		}
		if( mvs.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_ComboLiberate_End",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

Std_MoveTable.Mv_ComboLiberate_End <- //落下部分
{
	function Init_Std()
	{
		local vec = BMvTbl.GetVector(0);
		if( vec.y <= 0 ) //まだ上昇してるようなら下げよう
		{
			Battle_Std.InitVector(); //ベクトル初期化
			BMvTbl.SetVector( { x=0, y=1500, addx=0, addy=250, flags=_Vector_Normal } );
		}
		
		// 衝撃波がヒットしてたら無敵で落下
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if( mvs.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...	
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

Std_MoveTable.Mv_ComboLiberate_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		// BMvTbl.SetMoveableFlag({ move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
		
		// 行動可能なので無敵にはしない
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_ComboVO_HitEffect <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus|_ObjFlags_NoGround } );
	}
	function HitInterrupt_Std()
	{
		// ヒット時の処理をデメリット処理を書くと、コンボVO空振りが流行るので注意
		
		if( Battle_Std.CheckDamageTiming() ) //ダメージを与えた
		{
			// あてたらキャラを無敵にする
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					BMvTbl.SetLP(5,1); // ヒットしたのを伝える
					
					//CVOヒット時はEXSLimitを与える
					//CSカンニングと異なり、こっちは行動可能時にあてても効果あり
					Battle_Std.SetSpecialEXSLimit_Enemy( def_SP_CVO_EXSLimitVal );

					player.pop();
				}
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//最大タメヴェールオフ
Std_MoveTable.Mv_MaxLiberate <-
{
	function StepMode()
	{
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
	}
	function IsDying()
	{
		if( Def_Sys_DyingVeilOffShortCharge )
		{
			local s = BMvTbl.GetMvStatus(); // ステータス取得
			if( s.flags & _MvStFlag_DangerHPDef ) return 1;
		}
		return 0;
	}
	function Init_Std() //
	{
		//再度無敵にする
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
	
		//変数初期化
		BMvTbl.SetLP(0,2); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //
		
		BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		
		local isOverLiberate = (BCMDTbl.GetComboGauge() >= 20000)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				local es = BMvTbl.GetMvStatus();
				enemyisDangar = (es.flags & _MvStFlag_DangerHPDef);
			BMvCore.PopCharaData(); //
		}
		
		// FrameIDメモ
		// 10:タメ１枚目（0F目）
		// 20:タメ２枚目
		// 30:発動直前		
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //フレームカウント進める
		
		switch( mode )
		{
		case 2: //抜け先
			if( cnt>19 ) StepMode();
			if( IsDying() && cnt>0 ) StepMode();
			if( cnt==0 )
			{
				//ＭＡＸためが確定したのでバリバリする
				BSound.SE_Play( { num=74 } ); // ちりちり音
				BMvEff.CreateObject( { x=0, y=-260, mvname="", datatype=1, start_pat=77, flags=_Position_ToolShift } );						
				BMvEff.SetCamera_Quake( { type=2, time=60 } ); //画面を揺らす		

				//BMvEff.Slowmotion_Set( { time=40, power=5000 } ); //スロー演出
				
				//Battle_Std.TypeSE_Play({ type="ヴェールオフ" });		
				
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 3: //爆発開始
			if( cnt>8 ) StepMode();
			if( IsDying() && cnt>0 ) StepMode();
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>30 ) StepMode();
			if( cnt==0 )
			{
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="VO" } );
			
				BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
				BMvEff.Liberate_SetType( _LiberateType_Max ); // 最大タメヴェールオフ
				BMvEff.Liberate_SetMinusValue( def_MaxVO_MinusValue );
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				BMvTbl.JumpFrameID(40);

				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				local pos = 
				{
					x=0,
					y=-260,
				}
				
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					pos.x = rc.sx;
					pos.y = rc.sy;
				}				
				
				//最大タメの時は体力消費なし

				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0;
				
				//92:100%生
				//93:100%コンボ
				//94:200%orタメ生
				//95:200%orタメコンボ
				//96:IWX生
				//97:IWXコンボ

				//パターンをコンボ中かどうかで分ける
				local usepat = (enemy_isDamage)? 95 : 94;
				local usemv = "Mv_Liberate_Eff";

				
				local vo_eff = BMvEff.CreateObject( { x=pos.x, y=pos.y, mvname=usemv, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				if( vo_eff.IsDone )
				{
					BMvCore.PushCharaData( vo_eff );
						BMvTbl.SetLP(0,enemy_isDamage);
						BMvTbl.SetLP(1,isOverLiberate);
					BMvCore.PopCharaData();
				}				
				
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.IsDone )
				{
					BMvCore.PushCharaData( eff ); //	
						//暗転時とかは表示しないように
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					BMvCore.PopCharaData(); //
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす	
				
				
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}	
}

Std_MoveTable.Mv_Obj_LiberateTimeEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
			
		BMvEff.CutInProc_Set({ time=[0,10,10], cutin_mv="", erasetype=0, bgtype=1 });
	}
	function FrameUpdate_Std()
	{
		BMvEff.CutInProc_Set({ time=[0,10,10], cutin_mv="", erasetype=0, bgtype=1 }); //maintain the cutin
		
		local player = BMvCore.GetPlayerCharaData(); 
		if( player.push() )
		{
			local lib_type = BMvEff.Liberate_Get(); //grab player vo state
			player.pop();
			
			if( !lib_type ) 
			{
				BMvEff.GRD_SetBreak( 0, def_GRDBF_VeilOffDmg, def_GRDBF_VeilOffDmg );
				BMvTbl.SetFinalize();
			}
			
			//Battle_Std.DrawDebugAttackInfo(lib_type);
		}
		
		//BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvEff.CutInProc_Set({ time=[0,1,10], cutin_mv="", erasetype=0, bgtype=1 }); //cutin fadeout on end
	}
}


//ヴェールオフ衝撃波エフェクト
Std_MoveTable.Mv_Liberate_Eff <-
{
	function Init_Std() //
	{
		//LP0 ... 1:相手はのけぞり中に出された 0:ふうう
		//LP1 ... 0:100%開放 1:200%開放
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_ShieldWeakGRDAdd );//被シールドでGRDが多く増える攻撃
		
		BMvEff.CreateObject( { mvname="Mv_Obj_LiberateTimeEff" } );
	}
	function HitInterrupt_Std()
	{
		if( Battle_Std.CheckDamageTiming() ) //ダメージを与えた
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local enemy_is_vorpal = ( BMvEff.GRD_GetJudgeResult()>0 );
				
				enemy.pop();
				
				if( enemy_is_vorpal )
				{
					BMvTbl.Achievement_Unlock(5); // 【トロフィー】そのヴォーパル、消えるよ
				}
			}
			
			if( BMvTbl.GetLP(0)==1 ) //コンボ中に出してヒットしたヴェールオフ
			{
				// 敵のGRD状態取得 
				if( BMvEff.GRD_GetBreak( 1 ) == 0 ) // 0 ブレイクしていない 1 ブレイク 100 チェインシフト中 255 オーバーブレイク
				{
					//BMvEff.GRD_ClearVorpal( 1 ); // ヴォーパルを解除する
				}
				BMvTbl.SetPP(def_PP_Temp,1); //着地硬直をヒット時のものにする
			}
			else //生でヒットさせたヴェールオフ
			{
				//BMvEff.GRD_SetBreak( 1, def_GRDBF_VeilOffDmg, def_GRDBF_VeilOffDmg ); //相手をブレイクにする
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
				if( enemy.push() )
				{
					BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
					enemy.pop();
				}
				
				BMvTbl.SetPP(def_PP_Temp,1); //着地硬直をヒット時のものにする
			}
			
			// どっちでも
			
			// あてたらキャラを無敵にする
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					BMvTbl.SetLP(5,1); // ヒットしたのを伝える
					
					player.pop();
				}
			}
			
			// あてた相手にフラグをたてる
			Battle_Std.EnemyDamageFlag_Add( def_DF_HitedVO );//VOをあてられた
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_IWEXS_able <-
{
	function Init_Std()
	{
		// _dm("IFWXS使用可能状態開始");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=-100, flags=_Position_CaptureShift } );
		
		BMvEff.Slowmotion_Set( { time=60, power=6666, power_minus=10000/60 } );

		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //	
				BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[8,30,15], type_in=1, type_out=2 } );
			BMvCore.PopCharaData(); //
		}
		
		BMvEff.SetCamera_Quake( { time=35, type=2, clear=1 } );
		
		BMvTbl.SetPP(def_PP_IWEXS_ChgVO_Hit,1); //使用可能		
	}
	function Update_Std()
	{
		//コンボ状態が途切れたら終了
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm("."+s.MvCount);
		if( !Battle_Std.CheckEnemyisDamage() )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		// _dm("IFWXS使用可能状態終了");
		BMvTbl.SetPP(def_PP_IWEXS_ChgVO_Hit,0); //使用不可能		
		BMvTbl.SetDeleteMoveTable();		
	}
}





//チェインシフトすると生成される
//時間でGRDがSPに変換されていく
Std_MoveTable.Mv_Convert_Object <-
{
	//LP0:予約GRD消費ストック　発動時にいくつあるか
	//LP1:SPどんだけ増えたか 見た目はいい加減でもいいから数値ある程度そろえる
	
	//LP2:毎フレームいくつ増やすか
	//LP3:変換時間
	
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);	// 発動時にいくつあるかの予約
		
		local stock = BMvTbl.GetLP(0); // BMvEff.GRD_CheckStock( { val=-1 } ); // 発動時にいくつあるか取得
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local enemyisBound = Battle_Std.CheckEnemyisBound(); // 相手がやられ中かどうか

		local cs_time = stock * 25; //チェインシフト変換フレーム　個数で変化
		local sp_frameAdd = 80; //  1Fで増える量 40=4%
		
		// GRD0個でも10%ぐらいは増える。CSゲージは25Fは最低でも出現する。
		if( stock == 0 )
		{
			cs_time = 25;
			sp_frameAdd = 40;
		}

		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		
		if( isCanselCS )
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 60 / 100;
			}
			else
			{
				cs_time = cs_time * 40 / 100;
			}
			
			if( player.push() )
			{
				local use_val = def_NormalVO_MinusValue;
				switch( BMvEff.Liberate_GetType() )
				{
				case _LiberateType_Max:
					use_val = def_MaxVO_MinusValue;
					break;
				case _LiberateType_Combo:
					use_val = def_ComboVO_MinusValue;
					break;
				case _LiberateType_Normal:
				default:
					use_val = def_NormalVO_MinusValue;
					break;
				}
				
				BMvEff.Liberate_SetMinusValue( use_val/2 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		else //ノーキャン時
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 80 / 100;
			}
			else
			{
				// sp_frameAdd = sp_frameAdd * 100 / 100;
			}		
		
			if( player.push() )
			{
				BMvEff.Liberate_SetMinusValue( 0 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		// _dp("\n CS:"+stock+" cancel:"+isCanselCS+" bound:"+enemyisBound+" time:"+cs_time+" plus:"+(cs_time*sp_frameAdd)/100 );

		//記憶
		BMvTbl.SetLP(2, sp_frameAdd);
		BMvTbl.SetLP(3,cs_time);

		BMvEff.GRD_ClearBreak( 0 );
		BMvEff.GRD_SetConvertBreak( { time=cs_time } ); // 開始※なんか微妙に10Fぐらい長くなるようなのでLPで抜ける

		//発動時にGRDは空になります
		if( player.push() )
		{
			local stock = BMvEff.GRD_CheckStock( { val=-1 } );
			BMvEff.GRD_UseStock( { val=stock } ); // 全消費
			
			player.pop();
		}
		
		// 出力チェック
		//_dm( format( "チェインシフト開始[ stock:%d time:%d ]", stock, convert_time ) );		
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount<=2 ) return; //最初ちょろっとEXSが増えてしまうのを防止
		
		//
		local isconvert = 1; // 継続中かどうか
		BMvTbl.AddLP(3,-1); //残りチェインシフト時間を減らす
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	
		if( BMvTbl.GetLP(3)<0 || BMvEff.GRD_GetBreak(0) != 100 ) // チェインシフト状態でなくなる条件
		{
			if( player.push() )
			{
				local stock = BMvEff.GRD_CheckStock( { val=-1 } );
				BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
				BMvEff.GRD_ClearBreak( 0 ); // クリアはされてるけど
				
				player.pop();
			}

			BMvTbl.SetFinalize(0);
			isconvert = 0; //
			//print("\n終わり");
		}

		//チェインシフトのボーナス前にタイマーチェック
		//終了条件は一応これの前にチェックする
		local rs = BMvTbl.GetMvRoundStatus();
		//print("\nrs:"+rs.TimeUpdate);
		if( rs.TimeUpdate==0 ) //タイマーが進んでいないので
		{
			//print("\nとまれ");
			//return;
		}		

		if( isconvert ) // コンバート状態継続中
		{
			// ゲージふやし
			
			local SPadd = BMvTbl.GetLP(2); //１フレームに増やす量
			
			if( player.push() )
			{
				BMvEff.SetSpGauge( { value=SPadd } ); // ＳＰを増加
				
				player.pop();
			}
			//BMvTbl.AddLP(1,-1);
			//local lp = BMvTbl.GetLP(1);
			//if( lp<=0 ) BMvTbl.SetFinalize(0);

			//local z = BMvEff.GRD_GetBreak(0);				
			//print(format(" GB:%d %d : %d",z, s.MvCount, lp));
		}

	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( player.push() )
		{
			local use_val = def_NormalVO_MinusValue;
			switch( BMvEff.Liberate_GetType() )
			{
			case _LiberateType_Max:
				use_val = def_MaxVO_MinusValue;
				break;
			case _LiberateType_Combo:
				use_val = def_ComboVO_MinusValue;
				break;
			case _LiberateType_Normal:
			default:
				use_val = def_NormalVO_MinusValue;
				break;
			}
			
			BMvEff.Liberate_SetMinusValue( use_val ); // CS中のVOの減少割合
			
			player.pop();
		}
	}
}


//チェインシフト
Std_MoveTable.Mv_Convert <- 	//リバースコンバート
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_ChainShift ); // 履歴カウンタを加算
	
		//今のベクトルを記憶
		local vec = BMvTbl.GetVector(0);
		BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); //保存ベクトルに与える
		
		//行動不能で無敵にする
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } );			
		
		// ・時間無敵を設定する
		// ・時間停止を設定する（こうなると自分の時間無敵は時間停止中も進む）
		// ・相手も同時に時間停止を発生させる
		// ・先に自分の時間停止が終わる→時間無敵は途切れた状態で相手の時間停止状態が続く
		// という状況があるので、無敵時間は長めに入れておくこと
	
		//共通処理
		BMvTbl.SetMuki(_Direction_Auto); //振り向く
		
		//ＧＲＤの端数を削って何個もっているか取得する
		//ＧＲＤが６個以上だったらすごいチェインシフトとする
		//BMvEff.GRD_UseStock( { val=0 } ); //端数を削る　※この処理不要
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );
		if( stock>6 ) stock=6; //なんか多いときがある気がするので
		// if( stock<1 ) stock=1; //最低でも1個扱いにする？ 1個あるときのメリットが無いんだけど…
		//print("\n stock:"+stock);
		local isSuperChainShift = (stock>=6); //すごいチェインシフトの条件
		
		//print("\n isSuperChainShift:"+isSuperChainShift);

		if( isSuperChainShift ) //すごいチェインシフト
		{
			BMvTbl.Achievement_Unlock(4); // 【トロフィー】ゲージ回収120％！
			
			//補正をゆるくする（少し回復するイメージ）
			local hosei = BMvEff.ComboView_Set();
			if( hosei < def_HOSEI_ChainShiftMax )
			{
				BMvEff.ComboView_Set( { val=def_HOSEI_ChainShift, type=1 } ); // 乗算
				BMvEff.ComboView_Set( { val=def_HOSEI_ChainShiftMax, type=0 } ); // 上書き
			}
			// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_ChainShift,1,0,0,0, 0,0,0,0,0, 0,0 ]} ); //乗算１２０
			// BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_ChainShiftMax,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //上書き９０
		}
		else // 通常チェインシフト
		{
		
		}
		
		// CSによるCP回復テスト
		local par = (isSuperChainShift)? def_CPH_SuperChainShift : def_CPH_ChainShift; // チェインシフトの凄さで回復割合が変化
		Battle_Std.ComboPoint_Multi( par ); // コンボポイントを乗算
		
		//バウンド回数を回復する（３回までいってるとダメ）
		//ジャンプ回数制限もリセット
		//のけぞり修正値もクリアする
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		local enemy_is_damage = false;
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			// short BtlMvStd::MvBoundStatus::isBound
			// のけぞりベクトルがある状態かどうか（やられ状態かではない
			// 0 --- のけぞり状態でない
			// 1 --- のけぞり状態
			// 2 --- のけぞり状態でガードしている
			//print("\n bs.isBound:"+bs.isBound);
			enemy_is_damage = ( bs.isBound==1 );
			if( enemy_is_damage ) // のけぞり状態（ガードは除外するよ）
			{
				if( isSuperChainShift ) //すごいチェインシフト
				{
					if( bs.WallCount<3 )
					{
						BMvTbl.SetWallCount( 0 ); //バウンド回数をリセット
					}
					
					//のけぞり修正値をクリア
					//isBound==1の時だけにしないとガード中に発動されてハメられる
					BMvTbl.BoundCorrect_Calc( { num=-10000 } );  // 通常は10で１ヒット分、-10000の時だけクリア処理
				}
				
				BMvTbl.DamageFlag_Func( def_DF_JumpCanseled, _ValErase );// 「ジャンプキャンセルをされた」を相手から消す
				BMvTbl.DamageFlag_Func( def_DF_AerialJumpCanseled, _ValErase );// 「エリアルジャンプキャンセルをされた」を相手から消す
			}
			
			enemy.pop();
		}
		
		//アサルト回数制限をリセット
		BMvTbl.AddAirCount( def_AC_Assault, -10 ); // アサルト回数リセット

		
		local eff = BMvEff.CreateObject( { mvname="Mv_Convert_Object" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetLP(0,stock); // GRDの個数を記憶
			
			eff.pop();
		}
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local voiceType = ( isCanselCS )? "キャンセルチェインシフト" : "ノーマルチェインシフト";
		_dp("\n voiceType:"+voiceType );
		if( Battle_Std.TypeSE_Play({ type=voiceType }) )
		{
		}
		else
		{
			Battle_Std.TypeSE_Play({ type="チェインシフト" });
		}
		

		//メッセージの表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_Convert,} );
		
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();
		
		//時間停止と暗転の処理
		BMvEff.SetStopTime( { time=def_FL_ConvertStopTime } ); //チェインシフトの時間停止
		
		BMvEff.CutInProc_Set({ time=[3,def_FL_ConvertStopTime-3,10], cutin_mv="",erasetype=0, bgtype=1 });

		BMvEff.SetSpGauge( {value=def_SP_Convert_Init,} );
		
		BMvTbl.SetPattern(def_PAT_ChainShift); //パターンセット
		BMvTbl.SetPrio( _CharaPrio_Near ); //目立たせるように手前にする
		
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_DivKeep } ); //Keep以外を初期化
		BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			local usepat = ( isSuperChainShift )? 76 : 82; //エフェクトのパターンを決める
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
			local eff = BMvEff.CreateObject( { x=rc.sx, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove } );	
				BMvTbl.SetPosition( { y=0 } );
				
				eff.pop();
			}
		}
		local pos = BMvTbl.GetPosition(0);
		if( pos.y >= -64 ) //地上付近だったら出す
		{
			BMvEff.CreateObject( { x=0, y=0, datatype=1, start_pat=87, flags=_Position_ToolShift } );
		}
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		// 戻りのモーションをキャッシュにのせておく
		local cache_f = def_FL_ConvertStopTime -3; // 大体40Fぐらいだから余裕っしょ
		if( cache_f < 0 ) cache_f = 3;
		Battle_Std.CallSkillSoonCaches( [100,cache_f], [200,cache_f] ); // FrameID, rest	
	}
	function Update_Std()
	{
		//フレーム毎の増加
		BMvEff.SetSpGauge( {value=def_SP_Convert_Frame,} );
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount==1 )
		{
			// 190415 でかかりだけで処理をしたい
			// 190410 ここで処理しないとprio奥の相手の行動1F目のときに検知されない
			// 181113 CS時に相手が行動不能だったら赤く光らせよう
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				local isCancelNone = BCMDTbl.CheckCancel( _SkillType_None );
				local isBound = Battle_Std.CheckPlayerisBound();
				local isMuteki = BMvEff.GetPlayerMuteki( 0 ); // 打撃無敵
				local existKuraiHantei = 0;
				local cmdInfo = BCMDTbl.GetCmdInfoEx(0);
				
				local isInActiveMv = ( Battle_Std.MoveCode.CheckFlag(def_MC_Atk|def_MC_Skill) || Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_StdAssult|def_MC7_AirAssult|def_MC7_InActive ) )? 1 : 0;
				{
					for(local i=0; i<8; i++)
					{
						local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Kurai , i ], } );
						if( rc.sx != _Hantei_Error )
						{
							existKuraiHantei = 1; //存在した
							break;
						}
					}
				}
				if( !isCancelNone && !isBound && isMuteki==0 && existKuraiHantei && cmdInfo.GetFrame() <= 10 && isInActiveMv)
				{
					Battle_Std.SetInActiveEffect(); // 行動不能時の被CSでの演出
				}
				enemy.pop();
			}
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount>=def_FL_ConvertStopTime) BMvTbl.SetFinalize(0);
		if( s.FrameID==100 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Convert_Modori" );
	}				
	function LastUpdate_Std()
	{
		//念のため無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );	
	}
}

//チェインシフトフリーモーション
Std_MoveTable.Mv_Convert_Modori <-
{
	function Init_Std()
	{
		local enemy = BMvCore.GetNearEnemyCharaData();
		
		if( enemy.push() )
		{
			BMvTbl.SetCommandLongDelay(1); //expand the opponents post cs input buffer window
			
			enemy.pop();
		}
		
		//地上か空中かで分岐
		//超低空だったら地上にした方がいいので属性ではなく座標で分岐する
		local pos = BMvTbl.GetPosition(0);
		if( pos.y> -64 ) //地上
		{
			BMvTbl.JumpFrameID(100);
			BMvTbl.SetPosition( { y=0 } ); //地面につける
			Battle_Std.InitVector(); //地上なので保存ベクトルの再生はしないで初期化
		}
		else //空中
		{
			BMvTbl.JumpFrameID(200);
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存ベクトルを呼び出す
			
			//そのままだと空中浮遊とかかっとびすぎるとかあると思うので制限をかける
			if( vec.x> 3000 ) vec.x=3000;
			if( vec.x< -3000 ) vec.x=-3000;

			if( vec.y> 3000 ) vec.y=3000;
			if( vec.y< -3000 ) vec.y=-3000;
			
			//addxは危ない気がするので使わない
			//チェインシフトを使うことでの減速による左右二択とか発生してしまうわけだがしょうがない
			vec.addx = 0;
			
			//addyは190以上、250以下にするする
			if( vec.addy <= 190 ) vec.addy=190;
			if( vec.addy >= 250 ) vec.addy=250;
			
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy } );
			
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Keep } ); // 保存していたものを破棄
		}
		
		//行動可能で動けるようにする
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //LUでもやるけど一応こっちメイン
		
		BMvTbl.SetCommandLongDelay(1); //受付時間増加（先行入力用）
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(256); //着地へ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Convert_Modori_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Convert_Modori_Land <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern(21); //着地
		Battle_Std.InitVector();
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//共通アクションここまで	



/*
	ガード関係
*/

local set_Nagemukite_GuardModori = function()
{
	if( BMvTbl.ChangeMv_GetMoveCodeEx( 1 )&def_MC1_ShieldFailed )
	{
		_dp("\n 前が失敗シールドだったので投げ無敵無し");
		BMvEff.SetPlayerTimer( { muteki_nage=0 } ); //無敵時間は無し
	}
	else
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
	}
}

//立ちガード戻り
Std_MoveTable.Mv_Modori_GuardS <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		
		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//屈ガード戻り
Std_MoveTable.Mv_Modori_GuardC <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardC);

		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//空中ガード戻り　※141129 仕様を変更、ベースデータも落下パターンへの変化でファイナライズするように
Std_MoveTable.Mv_Modori_GuardA <- 
{
	function Init_Std() : (set_Nagemukite_GuardModori)
	{
		//BMvTbl.SetPattern(def_PAT_GuardA); //※
		// 戻りが２パターンある
		if( BMvTbl.CheckPosState( _PosState_Air ) )//空中状態でガード解除
		{
			if (BMvTbl.JumpFrameID( 120 ) == -1)
			{
				_dem("【警告】飛び先のフレームIDが無い");
				BMvTbl.SetFinalize(0);
			}
		}
		else	//地上状態でガード解除
		{
			BMvTbl.SetFinalize(200); // Mv_Modori_GuardS　へ
			return;
		}
		
		set_Nagemukite_GuardModori(); // 失敗シールドじゃなけりゃ投げ無敵を設定
		
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.TypeSE_Play({ type="ガード戻り" });
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}	
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Modori_GuardAFall", [100,"Mv_Modori_GuardAFallLand"], [200,"Mv_Modori_GuardS"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}	
}

//空中ガード戻りからの落下
//キャラによってパターンが違う…
local pat_AirGuardModoriFall = chrparam.Get( { type="空中ガードからの戻りパターン", chrnum=_ChrNo } );

Std_MoveTable.Mv_Modori_GuardAFall <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		BMvTbl.SetPattern( pat_AirGuardModoriFall ); // 空中ガードからの戻りパターンを設定
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする
		
		// ガードフロートからの戻り
		if( BMvTbl.GetLP(8) ==1 ) // 無敵をセットされていた
		{
			BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_dageX=254 } );
		}
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding )
		{
			BMvTbl.SetFinalize(100);
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Modori_GuardAFallLand"] ); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=0, muteki_dageX=0 } );
	}
}

Std_MoveTable.Mv_Modori_GuardAFallLand <- 
{
	function Init_Std() : (pat_AirGuardModoriFall)
	{
		//※パターンは多分指定してあるだろう
		Battle_Std.InitCharaVector();
		//Mv中行動可能
		BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } ); // Mv中行動可能にする				
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズはどのみち着地してからっす
	}
}



//地上やられからの戻り
Std_MoveTable.Mv_Modori_YarareS <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り・しゃがみ
Std_MoveTable.Mv_Modori_YarareC <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriYarareNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
}

//投げ抜け攻撃からの戻り
Std_MoveTable.Mv_Modori_Nagenuke <- 
{
	function Init_Std() // 
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//投げ抜けられからの戻り
Std_MoveTable.Mv_Modori_Nagenukerare <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_GuardS);
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_ModoriGuardNageMuteki, muteki_nageX=def_FL_ModoriGuardNageMuteki } ); //無敵時間を設定
		
		if (BMvTbl.JumpFrameID( 120 ) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}			
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//地上やられからの戻り
Std_MoveTable.Mv_Modori_KirimomiYarareS <- 
{
	function Init_Std() // 
	{
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

//Vectorの抜け先はだいたいこのMvになる
//Vector終了後ダウン絵のファイナライズでここにやってくる（＝完全に寝きった絵までくる瞬間にここへくる）
//ここでＫＯチェックで大丈夫か？
//ここから先はbound属性が解除されているので無敵時間とかをつけないとまずそう
Std_MoveTable.Mv_Modori_Down <- // ダウンからの起き上がり
{
	function Init_Std() // 
	{
		//ここまできたらダウン追い討ちされなかった
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		// _dp("\n rs.Round:"+rs.Round );
		if (rs.isMyKo && rs.Round != -2 ) //KO状態なら寝たきり、チュートリアルとかは除外
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } ); //起き上がり無敵時間を消去
			
			//まず起き上がり先のパターンへ進む
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 290:
			case 350:
				BMvTbl.SetPattern(293);
				break;
			case 291:
			case 352:
				BMvTbl.SetPattern(294);
				break;
			case 292:
			case 354:
			case 356:
				BMvTbl.SetPattern(295);
				break;
			default:
				_dem("【警告】おかしいところから飛んできたよ０");
				BMvTbl.SetPattern(295);
				break;		
			}
			//まず256に飛んで起き上がらないように
			//・別のMvに状態移行
			//その後一定フレーム待って、起き上がるかどうかをチェック
			//ラウンドとられただけか敗北かに飛ぶ
			if( BMvTbl.JumpFrameID(256)==-1 )
			{
				_dm("【警告】飛び先のフレームIDが無い256");
			}
			if( rs.isLoseRound )
			{
				BMvTbl.SetFinalize(def_FC_Lose);
			}
			else if( rs.WinType == -1) //自分が勝っているかどうか（KO後のみ）、0-負け 1-勝ち -1-引き分け
			{
				//引き分け（勝敗ポイントが両者に入る時）は敗北Mvにして起き上がらないようにする
				//TODO:Ｍｖ見て何かしているものがあるとちょっと都合が悪いかも
				BMvTbl.SetFinalize(def_FC_Lose);			
			}
			else
			{
				BMvTbl.SetFinalize(def_FC_RoundLose);
			}
		}
		else //KOされてないので寝っぱなしへ、もしくはKOされたけどチュートリアル内
		{
			//まずは寝ている絵まで進めよう　※同じパターンを２回やる
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 290:
			case 350:
				BMvTbl.SetPattern(290);
				break;
			case 291:
			case 352:
				BMvTbl.SetPattern(291);
				break;
			case 292:
			case 354:
			case 356:
				BMvTbl.SetPattern(292);
				break;
			default:
				_dem("【警告】おかしいところから飛んできたよ０");
				BMvTbl.SetPattern(292);
				break;		
			}
			BMvTbl.SetFinalize(0); // ねっぱへ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neppa", [def_FC_RoundLose,"Mv_RoundLose"], [def_FC_Lose,"Mv_Lose"] ); //デフォ,[code,mv]...
	}
}


Std_MoveTable.Mv_Neppa <- // ダウンからの寝っぱなし状態　次に起き上がりへ移行
{
	function Init_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		// 0〜10 ボタン受け身受付 11〜29:寝てる 30:起き上がる
		local mask = (1<<0)|(1<<1)|(1<<2)|(1<<3); // Dも含む
		local push_button = BMvTbl.CheckButtonHold( mask );
		if( mvs.MvCount >= 20 )
		{
			BMvTbl.SetFinalize(0); // 起き上がりへ進む
		}
		else if( mvs.MvCount <= 10 )
		{
			if( push_button ) BMvTbl.SetFinalize(100); // 受け身へ進む
		}
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Okiagari", [100,"Mv_NeppaRecover"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Okiagari <- // 寝っぱなしからの起き上がり
{
	function Init_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254, muteki_dageX=254, muteki_nageX=254 } ); //無敵時間を設定
		BMvTbl.TM_SetDownStatus(); // ダウン状態待機。トレモリバーサル技呼び出し用。
		
		//まず起き上がり先のパターンへ進む
		local s = BMvTbl.GetMvStatus();
		switch(s.DataPattern)
		{
		case 290:
			BMvTbl.SetPattern(293);
			BMvCore.CallEntryBCCachePreTransfer( { pat=296, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		case 291:
			BMvTbl.SetPattern(294);
			BMvCore.CallEntryBCCachePreTransfer( { pat=297, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		case 292:
			BMvTbl.SetPattern(295);
			BMvCore.CallEntryBCCachePreTransfer( { pat=298, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			break;
		default:
			_dem("【警告】おかしいところから飛んできたよ１");
			BMvCore.CallEntryBCCachePreTransfer( { pat=298, frame=0, rest=10 } ); // フリーモーション１Ｆ目予約
			BMvTbl.SetPattern(295);
			break;		
		}			
		
		//起き上がりのボイス分岐
		if( Battle_Std.RoundisEnd() ) // 決着ついた後はボイスを無くす
		{
		
		}
		else
		{
			local s = BMvTbl.GetMvStatus();
			switch(s.DataPattern)
			{
			case 293:
				if( Battle_Std.TypeSE_Play({ type="起き上がり" }) == 0 )
				{
					Battle_Std.TypeSE_Play({ type="あお向け起き上がり" });
				}
				break;
			case 294:
				if( Battle_Std.TypeSE_Play({ type="起き上がり" }) == 0 )
				{
					Battle_Std.TypeSE_Play({ type="うつ伏せ起き上がり" });
				}
				break;
			case 295:
				Battle_Std.TypeSE_Play({ type="重傷起き上がり" });
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_OkiagariFreeMotion" );
	}	
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_dageX=0, muteki_nageX=0 } ); //この２つは怖いので消しておく
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}		
}


//決着敗北で寝たきり
//このMvの名前を見て勝利ポーズは分岐してるよ
//引き分けの時は両者このmvになるよ
Std_MoveTable.Mv_Lose <-
{
	function Init_Std() // 
	{
		// if( Def_Dbg_RoundStatus ) _dp(" -> Mv_Lose");
		if( BMvTbl.JumpFrameID( 1024 ) == -1 )
		{
			_dm("【警告】飛び先のフレームIDが無い 1024");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetRoundEnd();
	}
	function Finalize_Std() // 
	{
		_dem("【警告】へんなファイナライズ");
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//発生しないはず
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}
}

//ラウンド敗北で起き上がる
//引き分けの時はここにこないよ
Std_MoveTable.Mv_RoundLose <-
{
	function Init_Std() // 
	{
		_dm("ラウンドの続きがあるので起きる");
		if (BMvTbl.JumpFrameID( 512 ) == -1)
		{
			_dm("【警告】飛び先のフレームIDが無い512");
		}
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Add } ); //重なり判定無し
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		BMvTbl.SetRoundEnd(); //ラウンド終了命令を入れる
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvTbl.SetLP(1,0); //音声再生フラグ		
	}
	function FrameUpdate_Std()
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める		

		//しばらくは起き上がらない
		if( s.MvCount<120 && s.FrameID==512)
		{
			BMvTbl.JumpFrameID(512); //512の寝た絵で固まってて
		}

		//120F後にラウンド敗北音声を再生する
		if( s.MvCount>=120 && BMvTbl.GetLP(1)==0 )
		{
			BMvTbl.SetLP(1,1); //再生済みフラグ（再生失敗してもフラグはたつ）
			
			//カメラ矩形外に自分がいるかチェック
			local inCamera = true; //カメラ内かどうか
			
			//今のカメラ矩形を取得（ゆれや注目の影響を受けるカメラ位置）
			local pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera } );

			//自分の座標を取得
			local my_pos = BMvTbl.GetPosition(0);
			if( my_pos.x < pos.sx || my_pos.x > pos.ex ) inCamera = false;
			
			//結果
			if( inCamera )
			{
				_dm("○　カメラ内なのでボイスを再生");
				Battle_Std.TypeSE_Play({ type="ラウンド敗北" });
			}
			else
			{
				_dm("×　カメラ外なのでボイスは再生しない");
			}
		}
	}	
	function Finalize_Std() // 
	{
		_dem("【警告】へんなファイナライズ");
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//発生しないはず
	}
	function LastUpdate_Std()
	{
		BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定消去戻し
	}	
}


Std_MoveTable.Mv_OkiagariFreeMotion <- // 起き上がりのフリーモーション
{
	function Init_Std() // 
	{
		//_dm("起き上がりフリー");
				
		//まず起き上がり先のフリーモーションへ進む
		local s = BMvTbl.GetMvStatus();
		switch(s.DataPattern)
		{
		case 293:
			BMvTbl.SetPattern(296);
			break;
		case 294:
			BMvTbl.SetPattern(297);
			break;
		case 295:
			BMvTbl.SetPattern(298);
			break;
		default:
			_dem("【警告】おかしいところから飛んできたよ");
			BMvTbl.SetPattern(298);
			break;		
		}
		//ここに1F無敵がナイトリバサ必殺技がでないデス
		//ってのは無くなったデス
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間を設定
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );	//ファイナライズ
	}
}	

	
	

//登場タイミングで呼ばれて
// 行動文字列を返す、行動が存在しないまたは""が返されると Mv_Neutral が呼ばれる
Std_MoveTable.GetEntranceMvName <- function()
//function Std_MoveTable::GetEntranceMvName()
{
	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	// print("\n::GetEntranceMvName" + p.Round + "," + p.isMyKo + "," + p.WinType );

//	if( p.Round < 0 ) return ""; // トレーニング -1？0未満だと
	if( p.Round < 0 ) return "Mv_Startup"; // トレーニング -1？0未満だと
	
	if( BMvTbl.TalkScript_IsDone() ) return "Mv_Startup"; // 会話があったらトレーニングと同じ開始状態にする
	
	if( p.Round == 0 ) // ラウンド１
	{
		return "Mv_Standby";
	}
	else if( p.Round >= 0 ) // ラウンド２以降
	{
		return "Mv_Startup";
	}

	return "";
}

//登場タイミングで呼ばれる関数
/*
function Std_MoveTable::Startup()
{
	//
	print("\nStartup");
}
*/

//「勝利キャラの」終了タイミングと、タイムアップ時に両者で呼ばれて、
// 行動文字列を返す、行動が存在しないまたは""が返されるとなにもしない
Std_MoveTable.GetResultMvName <- function()
//function Std_MoveTable::GetResultMvName()
{
	//_dem("終了:GetResultMvName");
	Battle_Std.PcAuraEffect_AllAuraEnd(); //勝利キャラorタイムアップの両者はこのタイミングでオーラを消す

	local p = BMvTbl.GetMvRoundStatus(); // これで判別
	//print("\n::GetResultMvName" + p.Round + "," + p.isMyKo + "," + p.WinType + " : " + p.isWinRound );

	//if( p.Round < 0 ) return ""; // トレーニング
	if( p.isMyKo )
	{
		// KOされたら倒れているのでポーズを取らない
		//ここにはいってくることはないのではないか？だぶるＫＯでも入ってこない
		//_dem("敗北")
		return "";
	}
	else
	{
		// 起きている、勝ち以外はタイムアップ
		if( p.WinType == 1 ) // 勝ち
		{
			if( Def_Dbg_RoundStatus ) _dm("勝利orタイムアップ勝利");
			return "Mv_Win";
		}
		else
		if( p.WinType == 0 ) // 負け
		{
			if( Def_Dbg_RoundStatus ) _dm("タイムアップ敗北");
			return "Mv_TimeupLose";
		}
		else
		{
			// タイムアップドロー
			if( Def_Dbg_RoundStatus ) _dm("タイムアップドロー");
			return "Mv_TimeupLose";
		}
	}
	return "";
}

//腹吹き飛び系統
//（キャラの向きとベクトル向きが一致していないとダメなもの）
//Mv_Boundと同じ処理＋Battle_Std.SetMuki_BoundVectorMuki();
Std_MoveTable.Mv_Bound_0009 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		Battle_Std.SetMuki_BoundVectorMuki();
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}
}

Std_MoveTable.Mv_Bound_0017 <- Std_MoveTable.Mv_Bound_0009; //小腹吹き飛び
Std_MoveTable.Mv_Bound_0018 <- Std_MoveTable.Mv_Bound_0009; //小腹吹き飛び
Std_MoveTable.Mv_Bound_0094 <- Std_MoveTable.Mv_Bound_0009; //超腹吹き飛び大壁バウンド
Std_MoveTable.Mv_Bound_0148 <- Std_MoveTable.Mv_Bound_0009; //再帰超斜め上吹き飛び
Std_MoveTable.Mv_Bound_0227 <- Std_MoveTable.Mv_Bound_0009; //超ゆっくり腹吹き飛び
Std_MoveTable.Mv_Bound_0228 <- Std_MoveTable.Mv_Bound_0009; //超斜め上吹き飛び

// コンボVO浮き
Std_MoveTable.Mv_Bound_0238 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit();
		
		BMvTbl.SetLP(0,0); // 補正をかけたかどうか
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();
	}
	function FrameUpdate_Std()
	{
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });
		
		if( BMvTbl.GetLP(0) == 0 )
		{
			// バウンドの時に補正をかける
			local bs = BtlMvStd.GetBoundStatus();
			// bs.VecCount 0:空中ヒット〜着地まで
			if( bs.isBound && bs.VecCount==1 )
			{
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					// Battle_Std.SetHosyoHosei( def_HosyoHosei_ComboVO );
					Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_ComboVO );
					BMvEff.ComboView_Set( { val=90, type=1 } ); // ダメージ補正
					Battle_Std.ComboPoint_Multi( 90 ); // コンボポイント補正
					
					enemy.pop();
					
					_dp("\n コンボVO着地での補正");
					BMvTbl.SetLP(0,1); // 補正をかけたことを記憶
				}
			}
		}
		
		
	}
	function Finalize_Std() // 
	{
		//抜け先が無いかも？
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize();
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}
}

local makemv_BoundSirimoti = function( frame1=9, frame2=15, frame3=25 )
{
	local retmv = {};
	retmv.Init_Std <- function() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット

		//やられ絵とベクトル向きが絶対に等しくないとおかしいので
		Battle_Std.SetMuki_BoundVectorMuki(); //向きをベクトルの向きに合わせる
			
		//LP0 しりもちの状態　0:ヒット直後〜　1：しりもち着地〜　2：復帰モーション〜　(3:終わり)
		BMvTbl.SetLP(0,0); //変数初期化
		BMvTbl.SetLP(1,0); //カウント
	}
	retmv.FrameUpdate_Std <- function() : (frame1, frame2, frame3)
	{
		local s = BMvTbl.GetMvStatus();
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		BMvTbl.AddLP(1,1); //カウントアップ
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	

		switch( mode )
		{
		case 0:
			if( s.MvCount>frame1 )
			{
				BMvTbl.SetLP(0,1); //状態移行
				BMvTbl.SetLP(1,0); //カウンタリセット
			}
			if( cnt==0 )
			{
				//食らった直後

				//しりもちやられ状態なのをセット(解除は自動)
			}
			break;
		case 1:
			if( s.MvCount>frame2 )
			{
				BMvTbl.SetLP(0,2); //状態移行
				BMvTbl.SetLP(1,0); //カウンタリセット
			}
			if( cnt==0 )
			{
				//尻から着地するところ
				BMvTbl.JumpFrameID(100);
				
				BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Bound } );
				
				//バウンドエフェクト・効果音呼び
				// callLandEffect(); // 着地エフェクト ここはうるさいので使わない
				BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
				BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
				BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ				
			}
			break;
		case 2:
			if( s.MvCount>frame3 )
			{
				BMvTbl.SetLP(0,3); //状態移行
				BMvTbl.SetLP(1,0); //カウンタリセット
			}
			if( cnt==0 )
			{
				//復帰の絵開始
				BMvTbl.JumpFrameID(256);
				
				BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Bound } );				
			}
			break;		
		}
	}
	retmv.Finalize_Std <- function() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize(); //パターンが変化する
		// print("\nMv_Bound Finalize()");
	}
	retmv.LastUpdate_Std <- function() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
	return retmv;
}

//しりもち（作り直し）
//ヒルダの椅子処理でこの番号決め打ちしているので注意
Std_MoveTable.Mv_Bound_0197 <- makemv_BoundSirimoti( 7, 12, 20 ); // しりもち弱
Std_MoveTable.Mv_Bound_0198 <- makemv_BoundSirimoti( 8, 14, 22 ); // しりもち中
Std_MoveTable.Mv_Bound_0201 <- makemv_BoundSirimoti( 9, 15, 25 ); // しりもち

/*
//しりもち叩きつけ（作り直し）
Std_MoveTable.Mv_Bound_0200 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//やられ絵とベクトル向きが絶対に等しくないとおかしいので
		Battle_Std.SetMuki_BoundVectorMuki(); //向きをベクトルの向きに合わせる
		
		//LP0 しりもちの状態　0:ヒット直後〜　1：しりもち着地〜　2：復帰モーション〜　(3:終わり)
		BMvTbl.SetLP(0,0); //変数初期化
		BMvTbl.SetLP(1,0); //カウント
	}
	function Update_Std() // 
	{
		//print("\nMv_Bound Update()");
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		//ベクトルテーブルの特定のところだけの処理する
		local bs = BtlMvStd.GetBoundStatus();
		// bs.VecCount 0:空中ヒット〜着地まで
		// bs.VecCount 1:しりもち着地〜
		if( bs.isBound && bs.VecCount==1 )
		{
			local mode = BMvTbl.GetLP(0);
			local cnt = BMvTbl.GetLP(1);
			BMvTbl.AddLP(1,1); //カウントアップ
			local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
			Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	

			switch( mode )
			{
			case 0:
				if( s.MvCount>10 )
				{
					BMvTbl.SetLP(0,1); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//食らって着地した直後
					BMvTbl.JumpFrameID(100);

					//しりもちやられ状態なのをセット(解除は自動)
					
					//バウンドエフェクト・効果音呼び
					BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
					BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
					BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ				
					
					BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Bound } );
				}
				break;
			case 1:
				if( s.MvCount>20 )
				{
					BMvTbl.SetLP(0,2); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//復帰の絵開始
					BMvTbl.JumpFrameID(256);
					
					BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Bound } );				
				}
				break;
			}
		}		
	}
	function Finalize_Std() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize(); //パターンが変化する
		// print("\nMv_Bound Finalize()");
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
}// 基本動作テーブル

Std_MoveTable.Mv_Bound_0199 <- Std_MoveTable.Mv_Bound_0200;
Std_MoveTable.Mv_Bound_0196 <- Std_MoveTable.Mv_Bound_0200;
//しりもち叩きつけ系処理
*/

local makemv_BoundAirSirimoti = function( type=0 )
{
	local retmv = {};
	
	local mvparam =
	{
		xvec = -1000,
		xadd = 100,
	}
	
	switch( type )
	{
	case 0:
		break;
	case 1:
		mvparam.xvec = -3000;
		mvparam.xadd = 200;
		break;
	default:
		break;
	}
	
	retmv.Init_Std <- function() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//やられ絵とベクトル向きが絶対に等しくないとおかしいので
		Battle_Std.SetMuki_BoundVectorMuki(); //向きをベクトルの向きに合わせる
		
		//LP0 しりもちの状態　0:ヒット直後〜　1：しりもち着地〜　2：復帰モーション〜　(3:終わり)
		BMvTbl.SetLP(0,0); //変数初期化
		BMvTbl.SetLP(1,0); //カウント
	}
	
	
	retmv.FrameUpdate_Std <- function() : (mvparam)
	{
		local s = BMvTbl.GetMvStatus();
		
		//ベクトルテーブルの特定のところだけの処理する
		local bs = BtlMvStd.GetBoundStatus();
		// bs.VecCount 0:空中ヒット〜着地まで
		// bs.VecCount 1:しりもち着地〜
		if( bs.isBound && bs.VecCount==1 )
		{
			local mode = BMvTbl.GetLP(0);
			local cnt = BMvTbl.GetLP(1);
			BMvTbl.AddLP(1,1); //カウントアップ
			local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
			Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	

			switch( mode )
			{
			case 0:
				if( s.MvCount>10 )
				{
					BMvTbl.SetLP(0,1); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//食らって着地した直後
					BMvTbl.JumpFrameID(100);

					//しりもちやられ状態なのをセット(解除は自動)
					
					//バウンドエフェクト・効果音呼び
					BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
					BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
					BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ				
					
					BMvTbl.SetVector( { x=mvparam.xvec, y=0, addx=mvparam.xadd, addy=0, flags=_Vector_Bound } );
				}
				break;
			case 1:
				if( s.MvCount>20 )
				{
					BMvTbl.SetLP(0,2); //状態移行
					BMvTbl.SetLP(1,0); //カウンタリセット
				}
				if( cnt==0 )
				{
					//復帰の絵開始
					BMvTbl.JumpFrameID(256);
					
					BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Bound } );				
				}
				break;
			}
		}		
	}
	retmv.Finalize_Std <- function() // 
	{
		//状態の移行だけ行う
		BtlMvStd.SetBoundFinalize(); //パターンが変化する
		// print("\nMv_Bound Finalize()");
	}
	retmv.LastUpdate_Std <- function() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
	
	return retmv;
}// 基本動作テーブル


Std_MoveTable.Mv_Bound_0199 <- makemv_BoundAirSirimoti( 0 );
Std_MoveTable.Mv_Bound_0200 <- makemv_BoundAirSirimoti( 0 );
Std_MoveTable.Mv_Bound_0196 <- makemv_BoundAirSirimoti( 1 );
Std_MoveTable.Mv_Bound_0193 <- makemv_BoundAirSirimoti( 1 );


//しりもちからの戻り・レバガチャチェック
//312のID100から
Std_MoveTable.Mv_Modori_SirimotiCheck <- 
{
	function Init_Std() // 
	{
		BMvTbl.SetMuki(_Direction_Auto);
		Battle_Std.InitVector(); // ベクトル初期化
		if (BMvTbl.JumpFrameID(100) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}		
		BMvTbl.SetVector( { x=-1000, y=0, addx=100, addy=0, flags=_Vector_Div } );
		//バウンドエフェクト・効果音呼び
		BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } );		
		BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
		BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ
	}
	function FrameUpdate_Std()
	{
		//レバガチャ判定？
		//とりあえず特定フレームで抜ける
		local s = BMvTbl.GetMvStatus();
		if (s.MvCount>10)
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_Sirimoti" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		if( !BMvTbl.FromFinalize() )
		{
			BtlMvStd.ClearBound(); // 状態解除
		}
		//print("\nMv_Bound LastUpdate()");
	}
}// 基本動作テーブル

//しりもちからの復帰（レバガチャ部分以外）
Std_MoveTable.Mv_Modori_Sirimoti <- 
{
	function Init_Std() // 
	{
		Battle_Std.InitVector(); // ベクトル初期化
		if (BMvTbl.JumpFrameID(256) == -1)
		{
			_dem("【警告】飛び先のフレームIDが無い");
			BMvTbl.SetFinalize(0);
		}		
	}
	function FrameUpdate_Std()
	{
		//とりあえず特定フレームで抜ける
		local s = BMvTbl.GetMvStatus();
		if (s.MvCount>10)
		{
			BMvTbl.SetFinalize(0);
		}
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}		
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Modori_YarareC" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
		//print("\nMv_Bound LastUpdate()");
	}	
}// 基本動作テーブル


//12 14 27
//きりもみ転等 333
Std_MoveTable.Mv_Bound_0012 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
	}
	function Update_Std()
	{
		Battle_Std.BoundUpdate();	
	}
	function FrameUpdate_Std() // 
	{
	
		//ベクトルが↓向いたら落下パターンへ
		local s = BMvTbl.GetMvStatus();
		if (s.FrameID==100) //落下チェックID中なら
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Bound }); //ベクトル取得
			if (vec.y >= 0)
			{
				if (BMvTbl.JumpFrameID(256) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
			}
		}
		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}
}
Std_MoveTable.Mv_Bound_0014 <- Std_MoveTable.Mv_Bound_0012; //きりもみ小吹き飛び
Std_MoveTable.Mv_Bound_0019 <- Std_MoveTable.Mv_Bound_0012; //きりもみ壁吹き飛び
Std_MoveTable.Mv_Bound_0021 <- Std_MoveTable.Mv_Bound_0012; //きりもみ中壁
Std_MoveTable.Mv_Bound_0027 <- Std_MoveTable.Mv_Bound_0012; //きりもみ転倒
Std_MoveTable.Mv_Bound_0029 <- Std_MoveTable.Mv_Bound_0012; //きりもみ低転倒
Std_MoveTable.Mv_Bound_0095 <- Std_MoveTable.Mv_Bound_0012; //超きりもみ大壁バウンド
Std_MoveTable.Mv_Bound_0132 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ吹き飛び
Std_MoveTable.Mv_Bound_0133 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ垂直吹き飛び
Std_MoveTable.Mv_Bound_0137 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ転倒
Std_MoveTable.Mv_Bound_0139 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ低転倒
Std_MoveTable.Mv_Bound_0189 <- Std_MoveTable.Mv_Bound_0012; //きりもみ横吹き飛び
Std_MoveTable.Mv_Bound_0192 <- Std_MoveTable.Mv_Bound_0012; //即落きりもみ吹き飛び
Std_MoveTable.Mv_Bound_0209 <- Std_MoveTable.Mv_Bound_0012; //きりもみ垂直浮き
Std_MoveTable.Mv_Bound_0210 <- Std_MoveTable.Mv_Bound_0012; //きりもみ垂直浮き
Std_MoveTable.Mv_Bound_0225 <- Std_MoveTable.Mv_Bound_0012; //きり吹飛小壁

Std_MoveTable.Mv_Bound_0142 <- Std_MoveTable.Mv_Bound_0012; //きりもみ中壁
Std_MoveTable.Mv_Bound_0149 <- Std_MoveTable.Mv_Bound_0012; //きりもみ落下
Std_MoveTable.Mv_Bound_0195 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下

Std_MoveTable.Mv_Bound_0237 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0055 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0056 <- Std_MoveTable.Mv_Bound_0012; //再帰きりもみ落下
Std_MoveTable.Mv_Bound_0057 <- Std_MoveTable.Mv_Bound_0012; //
Std_MoveTable.Mv_Bound_0058 <- Std_MoveTable.Mv_Bound_0012; //
Std_MoveTable.Mv_Bound_0059 <- Std_MoveTable.Mv_Bound_0012; //
//きりもみ系統は同じ処理

// 凍結落下
Std_MoveTable.Mv_Bound_0118 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		BMvTbl.SetLP(0,0); // カウント
	}
	function FrameUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 ) // 落下中
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		}
		else if( bs.isBound && bs.VecCount==1 ) // 着地後
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
			
			local cnt = BMvTbl.GetLP(0);
			BMvTbl.AddLP(0,1);
			if(cnt==0)
			{
				//バウンドエフェクト・効果音呼び
				BMvEff.CreateObject( { datatype=1, start_pat=20 } ); //砂煙
				BMvEff.SetCamera_Quake( { time=12, type=0, clear=0, } ); //揺らし
				BSound.SE_Play( { type=_SeType_Normal, num=37 } ); //_SeType_Normal ---汎用 _SeType_Player ---キャラ	
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		//共通
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_BoundLockEff <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// スタン系
Std_MoveTable.Mv_Bound_0120 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Wag ) //相手
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
				if( enemy.push() )
				{
					// 相手が生成
					local eff = BMvEff.CreateObject( { start_pat="stun_hamon", mvname="Mv_BoundLockEff"} );
					if( eff.push() )
					{
						Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
						
						eff.pop();
					}
					
					enemy.pop();
				}
				BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 4, time = 255 } );			
			}
		}
	}
	function FrameUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		
			//定期的に何か出すとか…
			local mvs = BMvTbl.GetMvStatus();
			
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			local enemy = BMvCore.GetNearEnemyCharaData();
			if( enemyChrNo==Def_ChrNo_Wag ) //相手が
			{
				//
				if( mvs.MvCount%25==0 )
				{
					if( enemy.push() )
					{
						// 相手が生成
						local eff = BMvEff.CreateObject( { start_pat="stun_hit", mvname="Mv_BoundLockEff" } );
						if( eff.push() )
						{
							Battle_Std.SetPos_MarkingEnemy(); // ワーグナーから見て敵にくっつける
							
							eff.pop();
						}
						enemy.pop();
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		local enemyChrNo = Battle_Std.GetEnemyCharaNo();
		if( enemyChrNo == Def_ChrNo_Wag )
		{
			local bs = BtlMvStd.GetBoundStatus();
			if( bs.isBound && bs.VecCount==0 )
			{
				//フェードで抜ける
				BMvEff.SetCharaColor( { color = 0x2856A2, type = 0, intime = 10, time = 10 } );
			}
			else
			{
				//初期化？
				BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
			}
		}

		//共通
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0119 <- Std_MoveTable.Mv_Bound_0120; // 微弱
Std_MoveTable.Mv_Bound_0121 <- Std_MoveTable.Mv_Bound_0120; // 中
Std_MoveTable.Mv_Bound_0122 <- Std_MoveTable.Mv_Bound_0120; // 強

Std_MoveTable.Mv_Bound_0125 <- Std_MoveTable.Mv_Bound_0120; // 崩れ弱
Std_MoveTable.Mv_Bound_0126 <- Std_MoveTable.Mv_Bound_0120; // 崩れ中
Std_MoveTable.Mv_Bound_0127 <- Std_MoveTable.Mv_Bound_0120; // 崩れ強
Std_MoveTable.Mv_Bound_0128 <- Std_MoveTable.Mv_Bound_0120; // 崩れ特大
Std_MoveTable.Mv_Bound_0129 <- Std_MoveTable.Mv_Bound_0120; // 崩れ超大



// ウェブやられ
local webeff_size = chrparam.Get( { type="ウェブやられエフェクトサイズ", chrnum=_ChrNo } );

// ビャクヤから生成されるウェブエフェクト
Std_MoveTable.Mv_WebLockEffect <-
{
	function Init_Std()
	{
		BMvTbl.SetPattern( "web_lock" );
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
		
		BMvTbl.SetLP(0,0); // 終わりかどうか
		// _dp("\n ウェブやられ開始");
		
		// 別キャラ同士の時は、レイヤー0を使う
		// 同キャラ戦の時、1Pならレイヤー0、2Pならレイヤー1を使う
		local norender_layer = (1<<1); // 非表示にするレイヤー
		if( Battle_Std.IsDouakyara() && BMvTbl.GetPlayerSide()==1 )
		{
			norender_layer = (1<<0); // 非表示にするレイヤー
		}
		BMvTbl.SetHan6LayerMask( {  val = norender_layer } ); // ビットを立てたレイヤーが非表示になる		
	}
	function FrameUpdate_Std()
	{
		// 相手にくっつく
		// 相手の行動が変わったら消える
		if( BMvTbl.GetLP(0)==0 ) // ロックしている時の処理
		{
			// _dp("\n ロック中");
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
			if( enemy.push() )
			{
				local pl_pos = BMvTbl.GetPosition(0);
				local pl_kasanari = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ] } );
				local set_posy = pl_pos.y+(-150<<7); // 基本値
				if( pl_kasanari.sx != _Hantei_Error )
				{
					set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * 6 / 10 );
				}
				local bs = BtlMvStd.GetBoundStatus();
				enemy.pop();

				BMvTbl.SetPosition( { x=pl_pos.x, y=set_posy } ); // とりあえず座標をセット
				
				if( bs.isBound && ( bs.Num == 235 || bs.Num == 236 ) && bs.VecCount == 0 ) // アニメ停止するのはここだけ
				{
				}
				else
				{
					// _dp("\n ウェブやられおわり:"+bs.Num );
					BMvTbl.SetLP(0,1); // ロック終わり
					BMvTbl.JumpFrameID( 900 ); // 消滅アニメへ進む
				}
			}
			else
			{
				BMvTbl.SetFinalize( 0 );
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_Bound_0235 <- 
{
	function Init_Std() : (webeff_size)
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Bya )
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // ビャクヤ側からの処理
				if( enemy.push() )
				{
					local eff =BMvEff.CreateObject( { mvname="Mv_WebLockEffect" });
					if( eff.push() )
					{
						// _dp("\n サイズ変更:"+webeff_size[0]+", "+webeff_size[1] );
						BMvTbl.SetScale( { x=webeff_size[0]*100, y=webeff_size[1]*100 } );
						eff.pop();
					}
					
					enemy.pop();
				}
			}
			BMvEff.SetCharaColor( { color = 0x808080, type = 4, intime = 4, time = 254 } );			
		}
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std() // 
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める

		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//フェードで抜ける
			BMvEff.SetCharaColor( { color = 0x808080, type = 0, intime = 10, time = 10 } );
		}
		else
		{
			//初期化？
			BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
		}
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0236 <- Std_MoveTable.Mv_Bound_0235;
// ※↑のベクトル番号キメうちでエフェクト処理しているので注意

//呪縛固定浮き
Std_MoveTable.Mv_Bound_0247 <- 
{
	function Init_Std() // 
	{
		Battle_Std.BoundInit(); //ベクトル初期化・やられ状態セット
		
		//ベクトルテーブルの最初だけ処理する
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			local enemyChrNo = Battle_Std.GetEnemyCharaNo();
			if( enemyChrNo==Def_ChrNo_Set ) //相手がセトなら？
			{
				local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
				if( e.IsDone )
				{
					BMvCore.PushCharaData( e ); //
						local pos = Battle_Std.GetNearEnemyToolShiftPosition();
						Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
						pat="Spell_Hit", FrameID=[1,2], angle="rand" });
						
						Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
						pat="Spell_Biribiri", FrameID=[1,2,3], angle="rand" });
					BMvCore.PopCharaData(); //						
				}
			}
			BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 4, time = 254 } );			
		}
		
		
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function FrameUpdate_Std() // 
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める

		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//とりあえず一枚目の絵で固定する
			local frame = BMvTbl.JumpFrameID( 0, _ValAdd );
			BMvTbl.Frame_Proc( frame, _ValSet  );
		
			//定期的に何か出すとか…
			local s = BMvTbl.GetMvStatus();
			//print("\nフレーム:"+s.MvCount);
			
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報をかえる
			if( enemy.IsDone )
			{
				local enemyChrNo = Battle_Std.GetEnemyCharaNo();
				//print("\n番号："+enemyChrNo);
				if( enemyChrNo==Def_ChrNo_Set ) //相手がセトなら？
				{
					if (mvcnt%2==0 && mvcnt<=4 ) //数フレに１回
					{
						BMvCore.PushCharaData( enemy ); //
							local pos = Battle_Std.GetNearEnemyToolShiftPosition();
							Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
							pat="Spell_Hit", FrameID=[1,2], angle="rand" });
						BMvCore.PopCharaData(); //
					}
					if( mvcnt%10==0 )
					{
						BMvCore.PushCharaData( enemy ); //
							local pos = Battle_Std.GetNearEnemyToolShiftPosition();
							Battle_Std.CreateObjectEX({ x=pos.x, y=pos.y-200, flags=_Position_ToolShift,
							pat="Spell_Biribiri", FrameID=[1,2,3], angle="rand" });
						BMvCore.PopCharaData(); //
					}
				}
			}
		}
	}
	function Finalize_Std() // 
	{
		BtlMvStd.SetBoundFinalize();
	}
	function LastUpdate_Std() // 
	{
		//BMvEff.SetCharaColor( { color = 0x2856A2, type = 4, intime = 1, time = 1 } );
		local bs = BtlMvStd.GetBoundStatus();
		if( bs.isBound && bs.VecCount==0 )
		{
			//フェードで抜ける
			BMvEff.SetCharaColor( { color = 0x2856A2, type = 0, intime = 10, time = 10 } );
		}
		else
		{
			//初期化？
			BMvEff.SetCharaColor( { color = 0xFFFFFF, type = 0, intime = 0, time = 0 } );
		}
		BtlMvStd.ClearBound(); // 状態解除
	}
}

Std_MoveTable.Mv_Bound_0248 <- Std_MoveTable.Mv_Bound_0247;

//空攻撃浮きのベクトル終了先
//地面についた（しりもち）なのか、空中なのかで分岐する
Std_MoveTable.Mv_Modori_Uki <- 
{
	function Init_Std()
	{
		if( BMvTbl.CheckPosState( _PosState_Ground ) ) //既に着地していた
		{
			BMvTbl.SetFinalize( 256 ); //しりもちからの復帰へＧＯ
		}
		else
		{
			BMvTbl.SetFinalize(0); //自動復帰へ
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_AutoRecover", [256,"Mv_Modori_UkiSirimoti"] ); //デフォ,[code,mv]...
	}
}

//攻撃がヒットするとよばれる
//相手のDamageImpactと同時
Std_MoveTable.AttackImpact <- function( info )
//function Std_MoveTable::AttackImpact( info )
{
	Battle_Std.AttackImpact_StdFunc(info);
	
	//local pos = BMvEff.GetAttackHitPos();
	//print("座標:x"+pos.x+" y:"+pos.y);
	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nAttackImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
}




//攻撃を受けるとよばれる
//相手のAttackImpactと同時
Std_MoveTable.DamageImpact <- function( info )
//function Std_MoveTable::DamageImpact( info )
{
	Battle_Std.DamageImpact_StdFunc(info);

	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nDamageImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
}

//ＫＯされた瞬間呼ばれて少しすると消滅するＭｖ
//ＫＯボイスの再生に使っている
//キャラ別に書き換えたければこれをいじろう
Std_MoveTable.Mv_KOImpact_Object <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		//LP0 : ＫＯ音声を再生したかどうか
		BMvTbl.SetLP(0,0); // 初期化
	}
	function FrameUpdate_Std()
	{
		//1F後に操作親のパターンを見て分岐
		local s = BMvTbl.GetMvStatus();
		if( BMvTbl.GetLP(0)==0 && s.MvCount>2  )
		{
			BMvTbl.SetLP(0,1);

			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			if( p.IsDone )
			{
				if( BMvCore.PushCharaData( p ) )
				{
					local rs = BMvTbl.GetMvRoundStatus();
					// _dp("\n ラウンド:"+rs.Round );
					if( rs.Round != -2 ) // チュートリアル以外
					{
						local oya_s = BMvTbl.GetMvStatus();
						//_dm("s:"+oya_s.DataPattern);
						//ひざくずれとは言うがリンネの投げでも同様にやらないとまずそうなので290も含める
						local isHizakuzure = ( oya_s.DataPattern==327 || oya_s.DataPattern==290 ); //パターンで膝崩れかどうかをチェックしてるｗ
						if( rs.isLoseRound )
						{
							local seplay = 0; // 定義してあって再生されたら1
							if( isHizakuzure )
							{
								seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_膝崩れ" });
							}
							else
							{
								seplay = Battle_Std.TypeSE_Play({ type="決着ＫＯ_通常" });
							}
							if( seplay==0 ) Battle_Std.TypeSE_Play({ type="決着ＫＯ" });
						}
						else
						{
							local seplay = 0; // 定義してあって再生されたら1
							if( isHizakuzure )
							{
								seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_膝崩れ" });
							}
							else
							{
								seplay = Battle_Std.TypeSE_Play({ type="ラウンドＫＯ_通常" });			
							}
							if( seplay==0 ) Battle_Std.TypeSE_Play({ type="ラウンドＫＯ" });
						}
					}
				}
				BMvCore.PopCharaData();
			}
		}
		if( s.MvCount>60 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}







//skill


Std_MoveTable.Mv_DebugPause <- 
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //ゲージ増加
			case 3: //トレモ向け
			{
				btl_debPrint2("【デバッグ】ゲージ増加");
				local exs = BCMDTbl.GetComboGauge();
				BMvEff.SetSpGauge( { value=5000, correct=0 } );
				BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
				
				//満タンっぽかったら空にする
				if( exs==20000 || exs==40000 )
				{
					BMvEff.SetSpGauge( { value=-40000, correct=0 } );
				}
				
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				break;
			}
			case 2: //相手のみ時間停止
			{
				btl_debPrint2("【デバッグ】相手だけ時間停止");
				BMvEff.SetStopTime( { time=999, stopme=0 } );			
				BMvTbl.SetPattern( 0 ); //立ちポーズに戻る
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } );
				//BMvTbl.SetFinalize(0);
				break;
			}
			case 7: // ステージ確認
			{
				Battle_Std.InitVector();
				BMvTbl.SetMoveableFlag( { move=1, time=254, flag=_ClearFlag_ChangeMv } );
				local pos = BMvTbl.GetPosition();
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
					
					enemy.pop();
				}
				BMvTbl.SetFinalize(0);
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 登場
				break;
			}
		}
	}
	function FrameUpdate_Std()
	{
		// Eを押している間継続
		if( BMvTbl.CheckButtonHold( (1<<4) ) == 0 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		// 押している間の処理
		if( BMvTbl.CheckStickHold( (1<<2) ) )
		{
			// EXSを空にする
			BMvEff.SetSpGauge( { value=-40000, correct=0 } );
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_Standby"] ); //デフォ,[code,mv]...
	}	
}

Std_MoveTable.Mv_DebugButton_4 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=-def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=-500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_RoundWinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_6 <-
{
	function Init_Std()
	{
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				{
					BMvEff.SetSpGauge( { value=2500, correct=0 } );
				}			
				BMvTbl.SetFinalize(0);
				break;
			}			case 3: //
			{
				local muki = BMvTbl.GetMuki();
				BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						BMvTbl.SetPosition( { x=def_POS_GamenHajiX*muki, y=0 } );
						BMvEff.SetSpGauge( { value=-50000, correct=0 } );
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 7:
			{
				BMvTbl.SetPosition( { x=500, flags=_Position_ChangeMuki|_Position_Add|_Position_CaptureShift } );
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(100); // 勝利
				break;
			}			
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [100,"Mv_WinPattern"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_DebugButton_2 <-
{
	function Init_Std()
	{
		//BMvTbl.ClearCommand();
		switch( Def_Dbg_DebugButtonMode )
		{
			case 1: //
			case 2: //
			{
				BMvTbl.SetFinalize(0);
				break;
			}
			case 2: // 
			{
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.push() )
				{
					BMvEff.SetSpGauge( { value=-5000, correct=0 } );

					enemy.pop();
				}			
				BMvTbl.SetFinalize(0);
				break;
			}
			case 3: //
			{
				btl_debPrint2("【デバッグ】相手のゲージ増加");
				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
				if( enemy.IsDone )
				{
					if( BMvCore.PushCharaData( enemy ) )
					{
						local exs = BCMDTbl.GetComboGauge();
						BMvEff.SetSpGauge( { value=5000, correct=0 } );
						BMvEff.Liberate_End(); //ヴェールオフ状態だったら終了する
						
						//満タンっぽかったら空にする
						if( exs==20000 || exs==40000 )
						{
							BMvEff.SetSpGauge( { value=-50000, correct=0 } );
						}
					}
					BMvCore.PopCharaData(); //
				}
				BMvTbl.SetPattern("DUkemi_0"); //これで安心
				Battle_Std.InitVector();
				BMvTbl.SetVector( { y=-1000, addy=190, flags=_Vector_Normal } );				
				BMvTbl.SetFinalizeCode(0);
				break;
			}
			case 6:
			{
				BMvTbl.SetFinalize(0);
				break;			
			}
			case 8:
			{
				BMvTbl.SetFinalize(512); // 勝利
				break;
			}				
			case 9:
			{
				BMvTbl.SetFinalize(256); // イグジスト
				break;
			}				
		}
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_SpecialIWEXIST"], [512,"Mv_TimeupLose"] ); //デフォ,[code,mv]...
	}
}

	
//投げ抜け猶予＆投げ抜け失敗フレーム管理
Std_MoveTable.Mv_Obj_TechHit_FrameManager <- 
{
	function Init_Std()
	{
		//_dm("FM:投げ抜けチェックきたよ");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		//BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local end_manage = 0;//管理終了する？
		local techman_frame = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
		// 0 : 投げor投げ抜けをそもそも入れていないか、入力してからかなり経過した
		// 1〜40 : 投げ抜けを入力して何フレーム経過したか
		//def_FL_Tech					= 11;	//つかまれてからの投げ抜け猶予フレーム
		//def_FL_TechSenkou			= 5;		//投げコマンド入力してからの投げ抜け猶予フレーム　このフレームまでは投げ抜け		
		//def_FL_TechMiss				= 30;	//投げを入れてからの投げ抜け失敗フレーム　このフレームまでは投げ抜けミス		
		if (techman_frame<def_FL_TechMiss)
		{
			techman_frame++;
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, techman_frame ); //失敗フレームになるまでは時間をしまっておこう
		}
		else
		{
			end_manage = 1; // 終了
		}
		
		/*
		//ガード中に投げ抜けを入れて、硬直後のダッシュ投げとかでも解除されてしまうのはおかしい…ので一旦戻す
		//投げつかみの処理が行動可能かどうかを見て赤投げ判断してるので、ここも同じ条件じゃないとおかしい
		if( Battle_Std.CheckPlayerisMovable() )
		{
			end_manage = 1; // 終了
		}
		*/
		
		if( end_manage )
		{
			BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //終了
			BMvTbl.SetFinalize(0);
		}
		//_dp(format("\n投げ抜け：%d",BMvTbl.GetPP( def_PP_TechHit_FrameManager ) ))
	}
	function Finalize()
	{
		//_dm("FM:ばいばい");
		BMvTbl.SetDeleteMoveTable();
	}
}

//親のMvが変化or特定フレームで投げ属性を消去する
Std_MoveTable.Mv_Obj_SetAutoThrowMv <-
{
	function Init()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );//これは時間停止の影響を受けます
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		//LP0 ::指定フレーム
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		local frame = BMvTbl.GetLP(0); //何フレーム後に消すのか
		local end_flag = ( s.MvCount>frame);
		if( end_flag) BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		//print("\nフラグけすお");
		BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
	}
}

Std_MoveTable.Mv_Obj_DelThrowMv <-
{
	function Init_Std()
	{
		//_dm("次のフレームにフラグを消去");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
//		BMvTbl.SetPP( def_PP_TechHit_FrameManager, 0 ); //投げ抜けチェック
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update()
	{
		local s = BMvTbl.GetMvStatus();	
		if( s.MvCount>2) BMvTbl.SetFinalize(0)
	}
	function Finalize()
	{
		Battle_Std.DelPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを削除
		BMvTbl.SetDeleteMoveTable();
	}
}


local func_douji_update = function( pp )
{
	//操作親がやられかガード状態だったら終わる
	//Boundベクトルがきてたら
	if( Battle_Std.CheckPlayerisBound() )
	{
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);
		return;
	}

	//操作親が必殺技だったら終わる
	//でも同時押し許可技なら通す
	local check_skillmv = 0;
	local check_doujiokmv = 0;
	local check_doujingatk = 0;
	local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
	if( player.push() )
	{
		check_skillmv = Battle_Std.MoveCode.CheckFlag( def_MC_Skill );
		check_doujiokmv = Battle_Std.MoveCode.CheckFlag( def_MC_DoujiCanselOK );
		check_doujingatk = Battle_Std.MoveCode.CheckFlag( def_MC_DoujiCanselNG_NormalAtk );
		
		player.pop();
	}

	// 必殺技（同時押しＯＫじゃない） or 同時押しＮＧ通常技
	if( (check_skillmv && !check_doujiokmv) || check_doujingatk )
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n  ... 必殺技（同時押しＯＫじゃない） or 同時押しＮＧ通常技");
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);		
		return;
	}
	
	//残り猶予フレームを取得
	local i = BMvTbl.GetPP( pp );
	
	if( i<=0 ) //もう猶予がない
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p( "\n  ... "+pp+"の猶予切れ");
		BMvTbl.SetPP( pp, 0 ); //終了
		BMvTbl.SetFinalize(0);
		return;
	}
	else
	{
		i--; //1F減らす
		BMvTbl.SetPP( pp, i ); //同時押しズレ猶予受付中
	}
}

Std_MoveTable.Mv_NoneDouji <-
{
	function Init_Std()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_NoneDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender| _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_NoneDouji, def_FL_NoneDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_NoneDouji);
	}
	function Finalize()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_NoneDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_SpecialDouji <-
{
	function Init_Std()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_SpecialDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_SpecialDouji, def_FL_SpecialDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_SpecialDouji);
	}
	function Finalize()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_SpecialDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}

Std_MoveTable.Mv_ExSpecialDouji <-
{
	function Init_Std()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_ExSpecialDouji Init()");
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPP( def_PP_ExSpecialDouji, def_FL_ExSpecialDoujiCheck+2 ); //同時押し猶予フレーム設定
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
	}
	function Update() : (func_douji_update)
	{
		func_douji_update(def_PP_ExSpecialDouji);
	}	
	function Finalize()
	{
		// if( Def_Dbg_DoujiDelayLog ) _dp1p("\n Mv_ExSpecialDouji Finalize()");
		BMvTbl.SetDeleteMoveTable();
	}
}


// Std_MoveTableに特殊技関係をガーッと追加する関数
local Add_EXAtks = function( stdmv ) : (ground_atk_init, air_atk_init, set_AirAtkLandStatus, set_AirAtk_LandMoveableFrame)
{
	//関数内関数
	local makemv_GroundEXAtk = function( param={} ) : (ground_atk_init)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local nextmv = param.NextMv;
		local movecode = param.MoveCode;
		local ground_atk_flags = ( "AtkFlags" in param )? param.AtkFlags : 0;
		
		retmv.Init_Std <- function() : ( ground_atk_init, limit, pat, movecode, ground_atk_flags )
		{
			ground_atk_init( ground_atk_flags ); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
		}
		
		retmv.HitInterrupt_Std <- function()
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
		}	

		retmv.Finalize_Std <- function() : (nextmv)
		{
			BMvTbl.SetNextMoveTable( nextmv );
		}
		return retmv;
	}


	local makemv_AirEXAtk = function( param={} ) : (air_atk_init, set_AirAtkLandStatus)
	{
		local retmv = {};
		
		local limit = param.ComboLimit;
		local pat = param.Pattern;
		local movecode = param.MoveCode;
		local atkLv = param.AtkLv;
		
		retmv.Init_Std <- function() : ( air_atk_init, limit, pat, movecode )
		{
			air_atk_init(); //通常攻撃共通Init
			
			if( movecode )
			{
				// 行動コード追加
				// _dp("\n 追加:"+movecode);
				Battle_Std.MoveCode.AddFlag( movecode );
			}			

			Battle_Std.SetStatus_AirAtkStatus(); //ジャンプ攻撃の各種フラグをリセット＋立てる
		
			BMvTbl.SetComboLimit( limit );
			BMvTbl.SetPattern( pat );
		}

		local fu_voice = param.FUVoice;

		retmv.FrameUpdate_Std <- function() : (set_AirAtkLandStatus, fu_voice)
		{
			Battle_Std.TypeSE_Play({ type=fu_voice });
			local s = BMvTbl.GetMvStatus();
			if( s.isLanding )
			{
				set_AirAtkLandStatus(); // def_PP_AirAtkStatus に着地情報を入れる
				BMvTbl.SetFinalize(9999); //着地したらLandへ
			}
			Battle_Std.CheckAirAtkFsiki(); // 切り替え中段は上段に変更
		}
		
		retmv.HitInterrupt_Std <- function() : (atkLv)
		{
			Battle_Std.MvRule_Atk_HitInterrupt();
		}	

		local landmv = param.LandMv;
		retmv.Finalize_Std <- function() : ( landmv )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [9999,landmv] ); //デフォ,[code,mv]...
		}
		
		retmv.GetFinalizeCode_Std <- function() : (landmv)
		{
			return [ [0,"Mv_Neutral"], [9999,landmv] ];//XXX:9999はやめる
		}

		return retmv;
	}

	local makemv_AirEXAtkLand = function( param={} ) : (set_AirAtk_LandMoveableFrame)
	{
		local retmv = {};
		
		switch( param.AtkLv )
		{
		case "A":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirA_LandRecovery,			//空振りした
				def_FL_AtkAirA_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirA_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirA_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirA_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirA_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirA_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirA_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "B":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirB_LandRecovery,			//空振りした
				def_FL_AtkAirB_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirB_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirB_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirB_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirB_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirB_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirB_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		case "C":
			retmv.Init_Std <- function() : (set_AirAtk_LandMoveableFrame)
			{
				set_AirAtk_LandMoveableFrame(			//着地硬直を設定
				def_FL_AtkAirC_LandRecovery,			//空振りした
				def_FL_AtkAirC_LandRecovery_Shielded,	//シールドされた
				def_FL_AtkAirC_LandRecovery_Damage,		//ダメージを与えた
				def_FL_AtkAirC_LandRecovery_Guard,		//ガードされた
				def_FL_AtkAirC_LandRecovery_Assault		//アサルトから出して空振りした
				def_FL_AtkAirC_LandRecovery_AssaultShielded,	//アサルトから出してシールドされた
				def_FL_AtkAirC_LandRecovery_AssaultDamage,		//アサルトから出してダメージを与えた
				def_FL_AtkAirC_LandRecovery_AssaultGuard		//アサルトから出してガードされた
				);
			}
			break;
		}
		
		retmv.Finalize_Std <- function()
		{
			BMvTbl.SetNextMoveTable( "Mv_Neutral" );
		}
		
		return retmv;
	}




	local std_atk_list = [
		["Mv_Atk_Std6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Std6B", "6B", DEF_BS_CL_ATK6B, "Mv_Atk_Std6B_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std6C", "6C", DEF_BS_CL_ATK6C, "Mv_Atk_Std6C_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std4A", "4A", DEF_BS_CL_ATK4A, "Mv_Atk_Std4A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Std4B", "4B", DEF_BS_CL_ATK4B, "Mv_Atk_Std4B_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std4C", "4C", DEF_BS_CL_ATK4C, "Mv_Atk_Std4C_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Std3A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Std3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Std3B_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Std3C_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Std1A_FU", "Mv_Neutral", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Std1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Std1B_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_Std1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Std1C_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_6B_6B", "6B_6B", DEF_BS_CL_ATK6B_6B, "Mv_Atk_6B_6B_FU", "Mv_Neutral", 0, 0 ],
		["Mv_Atk_A_A", "A_A", DEF_BS_CL_ATKA_A, "Mv_Atk_A_A_FU", "Mv_Neutral", def_MC_GRDLowBreak, (1<<0) ],
		["Mv_Atk_B_B", "B_B", DEF_BS_CL_ATKB_B, "Mv_Atk_B_B_FU", "Mv_Neutral", 0, (1<<0) ],
		["Mv_Atk_C_C", "C_C", DEF_BS_CL_ATKC_C, "Mv_Atk_C_C_FU", "Mv_Neutral", 0, (1<<0) ],
		
		["Mv_Atk_Cro3A", "3A", DEF_BS_CL_ATK3A, "Mv_Atk_Cro3A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Cro3B", "3B", DEF_BS_CL_ATK3B, "Mv_Atk_Cro3B_FU", "Mv_Crouch_Wait", 0, 0 ],
		["Mv_Atk_Cro3C", "3C", DEF_BS_CL_ATK3C, "Mv_Atk_Cro3C_FU", "Mv_Crouch_Wait", 0, 0 ],
		["Mv_Atk_Cro1A", "1A", DEF_BS_CL_ATK1A, "Mv_Atk_Cro1A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, 0 ],
		["Mv_Atk_Cro1B", "1B", DEF_BS_CL_ATK1B, "Mv_Atk_Cro1B_FU", "Mv_Crouch_Wait", 0, 0 ],
		["Mv_Atk_Cro1C", "1C", DEF_BS_CL_ATK1C, "Mv_Atk_Cro1C_FU", "Mv_Crouch_Wait", 0, 0 ],
		["Mv_Atk_2A_2A", "2A_2A", DEF_BS_CL_ATK2A_2A, "Mv_Atk_2A_2A_FU", "Mv_Crouch_Wait", def_MC_GRDLowBreak, (1<<0) ],
		["Mv_Atk_2B_2B", "2B_2B", DEF_BS_CL_ATK2B_2B, "Mv_Atk_2B_2B_FU", "Mv_Crouch_Wait", 0, (1<<0) ],
		["Mv_Atk_2B_2B_2B", "2B_2B_2B", DEF_BS_CL_ATK2B_2B_2B, "Mv_Atk_2B_2B_2B_FU", "Mv_Crouch_Wait", 0, (1<<0) ],
		["Mv_Atk_2C_2C", "2C_2C", DEF_BS_CL_ATK2C_2C, "Mv_Atk_2C_2C_FU", "Mv_Crouch_Wait", 0, (1<<0) ],
	];
	
	for( local i=0; i<std_atk_list.len(); i++ )
	{
		local param = std_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local nextmv = param[4];
		local movecode = param[5];
		local atkflags = param[6];
		
		stdmv[mv] <- makemv_GroundEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, NextMv=nextmv, MoveCode=movecode, AtkFlags=atkflags } );
	}
	
	/*
	local cro_atk_list = [
		["Mv_Atk_Cro6A", "6A", DEF_BS_CL_ATK6A, "Mv_Atk_Std6A_FU" ],
		
	];

	for( local i=0; i<cro_atk_list.len(); i++ )
	{
		local param = cro_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		
		stdmv[mv] <- makemv_CroEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se } );
	}
	*/

	local air_atk_list = [
		["Mv_Atk_Air2A", "J2A", DEF_BS_CL_ATKJ2A, "Mv_Atk_Air2A_FU", "A", "Mv_Atk_Air2A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air2B", "J2B", DEF_BS_CL_ATKJ2B, "Mv_Atk_Air2B_FU", "B", "Mv_Atk_Air2B_Land", 0 ],
		["Mv_Atk_Air2C", "J2C", DEF_BS_CL_ATKJ2C, "Mv_Atk_Air2C_FU", "C", "Mv_Atk_Air2C_Land", 0 ],
		["Mv_Atk_Air4A", "J4A", DEF_BS_CL_ATKJ4A, "Mv_Atk_Air4A_FU", "A", "Mv_Atk_Air4A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air4B", "J4B", DEF_BS_CL_ATKJ4B, "Mv_Atk_Air4B_FU", "B", "Mv_Atk_Air4B_Land", 0 ],
		["Mv_Atk_Air4C", "J4C", DEF_BS_CL_ATKJ4C, "Mv_Atk_Air4C_FU", "C", "Mv_Atk_Air4C_Land", 0 ],
		["Mv_Atk_Air6A", "J6A", DEF_BS_CL_ATKJ6A, "Mv_Atk_Air6A_FU", "A", "Mv_Atk_Air6A_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_Air6B", "J6B", DEF_BS_CL_ATKJ6B, "Mv_Atk_Air6B_FU", "B", "Mv_Atk_Air6B_Land", 0 ],
		["Mv_Atk_Air6C", "J6C", DEF_BS_CL_ATKJ6C, "Mv_Atk_Air6C_FU", "C", "Mv_Atk_Air6C_Land", 0 ],
		["Mv_Atk_JA_JA", "JA_JA", DEF_BS_CL_ATKJA_JA, "Mv_Atk_JA_JA_FU", "A", "Mv_Atk_JA_JA_Land", def_MC_GRDLowBreak ],
		["Mv_Atk_JB_JB", "JB_JB", DEF_BS_CL_ATKJB_JB, "Mv_Atk_JB_JB_FU", "B", "Mv_Atk_JB_JB_Land", 0 ],
		["Mv_Atk_JC_JC", "JC_JC", DEF_BS_CL_ATKJC_JC, "Mv_Atk_JC_JC_FU", "C", "Mv_Atk_JC_JC_Land", 0 ],
	];

	
	for( local i=0; i<air_atk_list.len(); i++ )
	{
		local param = air_atk_list[i];
		local mv = param[0];
		local pat = param[1];
		local limit = param[2];
		local fu_se = param[3];
		local land_lv = param[4];
		local land_mv = param[5];
		local movecode = param[6];
		
		stdmv[mv] <- makemv_AirEXAtk( { ComboLimit=limit, Pattern=pat, FUVoice=fu_se, LandMv=land_mv, MoveCode=movecode, AtkLv=land_lv } );
		if( land_mv in stdmv )
		{
			// 既にあるのでスキップ
		}
		else
		{
			stdmv[land_mv] <- makemv_AirEXAtkLand( { AtkLv=land_lv } );
		}
	}
}

Add_EXAtks( Std_MoveTable );


// ここから自動生成無し

// A+B
Std_MoveTable.Mv_Atk_StdAandB <-
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKAANDB);
		BMvTbl.SetPattern("A+B");
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

Std_MoveTable.Mv_Atk_CroAandB <-
{
	function Init_Std() : (ground_atk_init)
	{
		ground_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCAANDB);
		BMvTbl.SetPattern("2+A+B");
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}	
}

Std_MoveTable.Mv_Atk_AirAandB <-
{
	function Init_Std() : (air_atk_init)
	{
		air_atk_init(); //通常攻撃共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJAANDB);
		BMvTbl.SetPattern("JA+B");
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirAandB_FU" });
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
}

local grd_action_init = function()
{
	// GRD消費
	if( Def_Rule_ForceFunction_UseGRD )
	{
		// Battle_Std.UseGRDStock( 1, 10000 ); // 消費GRD数, 相手増加GRD値(単位違注意)
	}
	
	// 消費予約を行う
	local useval = ( BMvEff.GRD_GetJudgeResult() > 0 )? def_PP_GAU_VORPALUse : def_PP_GAU_NormalUse;
	BMvTbl.SetPP( def_PP_GRDAction_UseGRD, useval ); // 初期化（フラグ処理だけど、初期化＋設定なので上書きでOK）
	_dp("\n GRD消費予約:"+useval );
	
	// アナウンス表示
	// BMvEff.AttackInfoString_Set({ word=def_AISW_GRDAction,} );	
	
	BMvTbl.SetMvAction(def_MVA_EXAtk);
}

local grd_action_useGRD = function()
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	// 消費済みor消費しないフラグがあったらやらない
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) )
	{
		if( grd_st&def_PP_GAU_VORPALUse )
		{
			// １つ無くてもＯＫで、自分が0.5減る
			Battle_Std.GRD_AddValue( { val= -5000, boundplus=1 } );

			Battle_Std.PP_AddFlag( def_PP_GRDAction_UseGRD, def_PP_GAU_Used ); // 減らしたフラグを追加
		}
		else if( grd_st&def_PP_GAU_NormalUse )
		{
			// １つ減って、１つ無いと相手が１つ増える
			Battle_Std.UseGRDStock( 1, 10000 ); // 消費GRD数, 相手増加GRD値(単位違注意)

			Battle_Std.PP_AddFlag( def_PP_GRDAction_UseGRD, def_PP_GAU_Used ); // 減らしたフラグを追加
		}
	}
}

local grd_action_update = function() : (grd_action_useGRD)
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) && !(grd_st&def_PP_GAU_NoUpdateUse) )
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount == 4 && mvs.CallCount==0 )
		{
			grd_action_useGRD();
		}
	}
}

local grd_action_lastupdate = function() : (grd_action_useGRD)
{
	local grd_st = BMvTbl.GetPP( def_PP_GRDAction_UseGRD );
	// 消費済みor消費しないフラグがあったらやらない
	if( !(grd_st&def_PP_GAU_Used) && !(grd_st&def_PP_GAU_NoUse) )
	{
		// 除外条件
		if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_DoujiEndYoyaku ) && !Battle_Std.CheckPlayerisBound() )
		{
			_dp("\n 同時押しで移った行動＆やられじゃないので処理しない");
		}
		else
		{
			grd_action_useGRD(); // GRD消費処理
		}
	}
}

// B+C
Std_MoveTable.Mv_Atk_StdBandC <-
{
	function Init_Std() : (ground_atk_init, grd_action_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		//通常技と必殺技の間の子でいろいろ都合が悪いのでコンボリミットは両方立つ
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKBANDC);
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCBANDC);
		BMvTbl.SetPattern("B+C");
		
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_Init" });		
		
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_StdBandC_FU" });
		
		grd_action_update();
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}
}

Std_MoveTable.Mv_Atk_CroBandC <-
{
	function Init_Std() : (ground_atk_init, grd_action_init)
	{
		ground_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		//通常技と必殺技の間の子でいろいろ都合が悪いのでコンボリミットは両方立つ
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKBANDC);
		BMvTbl.SetComboLimit(DEF_BS_CL_ATKCBANDC);
		BMvTbl.SetPattern("2+B+C");

		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_Init" });
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_CroBandC_FU" });
		
		grd_action_update();
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Crouch_Wait" );
	}
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}	
}

Std_MoveTable.Mv_Atk_AirBandC <-
{
	function Init_Std() : (air_atk_init, grd_action_init)
	{
		air_atk_init(); //通常攻撃共通Init
		grd_action_init(); // GRDアクション共通Init

		BMvTbl.SetComboLimit(DEF_BS_CL_ATKJBANDC);
		BMvTbl.SetPattern("JB+C");
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_Init" });
	}
	function FrameUpdate_Std() : (grd_action_update)
	{
		Battle_Std.TypeSE_Play({ type="Mv_Atk_AirBandC_FU" });
		
		grd_action_update();
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}	
	function LastUpdate_Std() : (grd_action_lastupdate)
	{
		grd_action_lastupdate();
	}
}

//空中投げ
Std_MoveTable.Mv_Throw_A <- 
{
	function Init_Std()
	{
		BMvTbl.SetPattern("Throw_A");
		BMvTbl.ClearHitStatus();

		Battle_Std.MoveCode.AddFlag( def_MC_Throw ); // 行動コード(投げ)を設定
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_InActive );
		
		// コンボレート加算
		// 地上版にはない。地上版につけると連キャンの当て投げが安くなる
		BMvTbl.AddComboRate(); // コンボレート加算
		
		// 空中浮遊しないようにベクトル設定
		local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
		if( vec.addy < 190 )
		{
			BMvTbl.SetVector( { addy=190, flags=_Vector_Normal } );
		}
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_FU" });
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetFinalize(512); //着地したらLandへ
		}		
	}
	function HitInterrupt_Std()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}	
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Throw_A_Hit"],[512,"Mv_Throw_A_Land"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Throw_A_Land <-
{
	function Init_Std()
	{
		BMvTbl.SetVector( { y=0 } ); //Yベクトル初期化
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_Throw_A_Hit <- 
{
	function Init_Std() // 
	{
		//逆投げだったらここで反転
		if( BMvTbl.GetPP(def_PP_TechReverse) == 1 ) BMvTbl.SetMuki(_Direction_Reverse);	//逆投げなんで反転		
		Battle_Std.InitVector(); //慣性削除		

		//反転後にパターン設定
		BMvTbl.SetPattern("Throw_A_Hit");
		
		Battle_Std.PassHitMoveCodes(); // ヒット分岐でのMvCode引継ぎ
		
		BMvTbl.SetMvAction( def_MVA_Throw );
	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Mv_Throw_A_Hit_FU" });
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}		
}

// 同時押しダッシュで生成される
// 
Std_MoveTable.Mv_DoujiDash_F_HoldCheckObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		BMvTbl.SetLP(0,0); // ボタンを離したかどうか
		BMvTbl.SetLP(1,0); // ボタンを離したあと何フレーム経過したか。これが2になるとオブジェクトが消滅する。（lastdelay対策）
		// 6+A+B → 1Fでニュートラル →　とすると、このオブジェクトが消えて技制限が消えるが、6+A+Bのキーは残っているのでlastdelayで受け付けているものがあると出てた
	}
	function Update_Std()
	{
		if( BMvTbl.GetLP(0) == 1 ) // ボタンを離した
		{
			local frame = BMvTbl.AddLP(1,1); // 経過したフレームを記憶
			//_dp("\n frame:"+frame);
			if( frame >= 2 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local button_release = (BMvTbl.CheckButtonHold( (1<<0)|(1<<1) ) == 0)? 1 : 0;
			player.pop();

			if( s.MvCount>6 )
			{
				BMvTbl.SetFinalize(0); //長すぎ
			}
			if( button_release )
			{
				BMvTbl.SetLP(0,1); // ボタンを離したことを記憶
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		BMvTbl.SetPP(def_PP_CmdStatus, BMvTbl.GetPP(def_PP_CmdStatus)&~def_PP_CS_DoujiDash_F ); //フラグを消す
	}
}


_dp1p( "\n>>> [btl_UkemiFunc]" );

//受け身開始で共通やること
local recover_init = function()
{
	Battle_Std.GRD_AddValue({ val=def_GRD_Recover }); //受身で増加	
	
	if( Battle_Std.RoundisEnd() == false ) // 決着ついた後はボイスを無くす
	{
		Battle_Std.TypeSE_Play({ type="受け身" });
	}
	BMvEff.CreateObject( { mvname="Mv_RecoverInitObject_Mask" } ); //121015追加
	
	Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	
	if( _isDebugModeExe )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.CreateObject( { mvname="Mv_Obj_RecoverLateCombo", datatype=1, start_pat=999 } );	
		}
		BMvCore.PopCharaData(); //
	}
}

//Mv_RecoverInitObjectの将来的にはこっちに統一したい版
//全てのボタンをチェックする、各ボタンごとにクールタイムがある
Std_MoveTable.Mv_RecoverInitObject_Mask <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠す
		
		//入ってきたときに押しっぱなしにしていたボタンをチェックして
		//ボタン開放したらクールタイムセットして
		//なくなったら消滅
		//バティスタのボタンおしっぱなし離しの技が受け身のボタンで出ないようにするための処理
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);
		
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る

		local button = 0;
		BMvCore.PushCharaData( p ); //
			for( local i=0; i<=3; i++ )
			{
				if( BMvTbl.CheckButtonHold( (1<<i) ) )
				{
					button = button|(1<<i);
				}
			}
		BMvCore.PopCharaData(); //
		
		BMvTbl.SetPP(def_PP_RecoverHoldMask,button);
		
		// 入ってきたときに押しっぱなしのボタンをPPに記憶
		// 離されたらPPを更新
		
		BMvTbl.SetLP(0,0); //Aボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(1,0); //Bボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(2,0); //Cボタンのクールタイムとか LP>1:クールタイム中
		BMvTbl.SetLP(3,0); //Dボタンのクールタイムとか LP>1:クールタイム中
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		//local button = BMvTbl.GetLP(0);
		local checkbutton = 0;
		for( local i=0; i<=3; i++ )
		{
			if( (BMvTbl.GetPP(def_PP_RecoverHoldMask)&(1<<i)) !=0 ) //最初に押してたやつかどうか
			{
				BMvCore.PushCharaData( p ); //
					checkbutton = BMvTbl.CheckButtonHold( (1<<i) );
				BMvCore.PopCharaData(); //
				
				if( checkbutton==0 && BMvTbl.GetLP(i)==0 ) //ボタン離してた
				{
					BMvTbl.SetLP(i,16); // 離したら10を入れる
					//print("\n 離した:"+i)
				}
				if( BMvTbl.GetLP(i)>0 ) //無条件でLPに値があったら減らしていく
				{
					if( BMvTbl.GetLP(i)<=1 ) //減りきったら
					{
						BMvTbl.SetPP(def_PP_RecoverHoldMask,( BMvTbl.GetPP(def_PP_RecoverHoldMask)&~(1<<i)) );	 //フラグを消す
						//print("\n 終了:"+i);
					}
					else
					{
						//print("\n 減らす:"+i);
						BMvTbl.AddLP(i,-1); //減らしていく					
					}
				}
			}
		}
		
		//print("\nret:"+ret+" button:"+button);
		if( BMvTbl.GetPP(def_PP_RecoverHoldMask)==0 )
		{
			//print("\n全部離した");
			BMvTbl.SetFinalize(0); //消える
		}
			
		if( s.MvCount>120 ) BMvTbl.SetFinalize(0); //長すぎ(120Fに変更)
	}
	function Finalize_Std()
	{
		//_dm("さよなら");
		BMvTbl.SetPP(def_PP_RecoverHoldMask,0);		
		BMvTbl.SetDeleteMoveTable();
	}
}

//あと何フレはやければ追撃されそうだったのか測定するだけ
//最大10F
Std_MoveTable.Mv_Obj_RecoverLateCombo <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=0, flags=_Position_CaptureShift } );

	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();

		//これいじょう長く測定しても調整には影響しねぇべ
		if( s.MvCount>10 )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local e = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e ); //	
				local e_pc = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourPc   } );
				local e_obj = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_FavourObj   } );
			BMvCore.PopCharaData(); //
			
			if( e_pc.IsDone || e_obj.IsDone )
			{
				local frame = s.MvCount + 1;
				if( Def_Dbg_ComboChanceLog )
				{
					if( e.push() )
					{
						_dp1p(format("\nあと%dF早ければ追撃可かも",frame));
						
						e.pop();
					}
				}
				BMvTbl.SetFinalize(0);
				return;			
			}
			
		}
		else
		{
			BMvTbl.SetFinalize(0);
			return;			
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// 空中受け身分岐
// 空中受身
Std_MoveTable.Mv_Recover <- 
{
	function Init() : (recover_init) // 
	{
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		BMvTbl.SetMuki( _Direction_Auto ); //見た目を変更（ベクトル入れる前に変更してもＯＫになった）
		
		local check_rst = rst.Type; //判定に使う受身ステータス
		//rst.Type 受け身入力時のレバー方向　※相手依存になった
		//0:ニュートラル
		//1:前
		//2:後ろ
		//3:下
		
		//寝ている状態からの復帰もここ
		//Y座標が0なら多分そうなので下受身はできないようにだけしておく
		local pos_factor = -45*128;
		
		local pos = BMvTbl.GetPosition(0);
		if( pos.y >= pos_factor ) //ダウン受け身の時
		{
			check_rst = 10;
			
			BMvTbl.SetPosition( { y=0 } );
		}
		else // 空中受身の時
		{
			if( check_rst==3 ) check_rst=0; //下受け身を廃止・ニュートラル受け身に書き換える
		}
		if( Def_Rule_AirRecover_ClearAirJumpCount ) // 受け身時に二段ジャンプの回数をリセットする
		{
			BMvTbl.AddAirJumpCount( -10 ); // 0回以下にはならないので多めに引く
		}
		BMvTbl.SetPattern("DUkemi_0");
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る		
		
		BMvTbl.SetFinalize(check_rst);
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Recover_N", [1,"Mv_Recover_F"], [2,"Mv_Recover_B"], [10,"Mv_GroundRecover"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_RecoverBarrier <- 
{
	function Init()
	{
		BMvTbl.SetLP(0,0); // 消える命令入ったかどうか
	}
	function FrameUpdate()
	{
		if( BMvTbl.GetLP(0) == 0 )
		{
			// オブジェクト側から呼び出し
			if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				// プレイヤーが自分自身発生させた行動中
			}
			else
			{
				// プレイヤーが自分自身発生させた行動中でない
				BMvTbl.SetLP(0,1);
				BMvTbl.JumpFrameID(900); // 消えるアニメへ
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


local val_RecoverBarrierType = chrparam.Get( { type="空中受け身バリアタイプ", chrnum=_ChrNo } ); 

//空中受け身Ｍｖ作成
local makemv_recover = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */, landmv="Mv_RecoverLand_N") : (val_RecoverBarrierType)
{
	local ret_tmpl = {};
	
	local param = 
	{
		vec = { x=-500, y=-3500, addx=0, addy=250 },
		muteki = 254,
	}
	
	switch( type ) /* 0:ニュートラル 1:前 2:後ろ */
	{
		case 0: //ニュートラル
			param.vec.x = -500;
			param.vec.y = -2800;
			param.muteki = def_FL_N_RecoverMuteki;
			break;
		case 1: //前
			param.vec.x = 1800;
			param.muteki = def_FL_F_RecoverMuteki;
			break;
		case 2: //後ろ
			param.vec.x = -1800;
			param.muteki = def_FL_B_RecoverMuteki;
			break;
	}
	
	ret_tmpl.Init <- function() : (param, val_RecoverBarrierType)
	{
		BMvTbl.SetVector( { x=param.vec.x, y=param.vec.y, addx=param.vec.addx, addy=param.vec.addy } );
		BMvEff.SetPlayerTimer( { muteki_nage=param.muteki, muteki_dage=param.muteki, muteki_dageX=param.muteki, muteki_nageX=param.muteki  } );
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		Battle_Std.TypeSE_Play({ type="空中受け身" });
		
		BMvTbl.SetLP(0,0); //着地まで進んだかどうか
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		
		if( val_RecoverBarrierType == 0 )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
			}
		}
		else
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=6, flags=_Position_ToolShift } );
				local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="Mv_RecoverBarrier", datatype=1, start_pat="RecoverBarrier", flags=_Position_ToolShift } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_EraseParentDamage } );
					eff.pop();
				}
			}		
		}		
	}
	
	ret_tmpl.FrameUpdate <- function()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			BMvTbl.SetLP(0,1); //着地まで進んだ
			BMvTbl.SetFinalize(256); // 着地によるファイナライズ
		}	
	}
	
	ret_tmpl.Finalize <- function() : (landmv)
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,landmv]); //デフォ,[code,mv]...
	}
	
	ret_tmpl.LastUpdate <- function()
	{
		//着地経由せずに万が一抜けるような時は無敵を消しておく（ないはずだけど）
		if( BMvTbl.GetLP(0)==0 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0 } );
		}
	}
	
	
	return ret_tmpl;

}

//空中受け身の着地ｍｖ作成　受け身状態ではない
local makemv_recoverland = function( type=0 /* 0:ニュートラル 1:前 2:後ろ */ )
{
	local ret_tmpl = {};
	
	ret_tmpl.Init <- function()
	{
		//着地したら時間の無敵は解除
		Battle_Std.InitVector(); // ベクトル初期化
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } ); //起き上がり無敵時間
		
		BMvTbl.SetMoveableFlag( { move=1, time=64, flag=_ClearFlag_ChangeMv } ); //着地後は行動可能に
		BMvTbl.SetLP(0,1); //着地まで進んだ
		
		BMvTbl.SetCommandLongDelay(2); //address buffer inconsistency between air and ground tech land states
	}
	
	ret_tmpl.Finalize <- function()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
	
	return ret_tmpl;

}

//空中前受け身
Std_MoveTable.Mv_Recover_N <- makemv_recover(0,"Mv_RecoverLand_N");
Std_MoveTable.Mv_Recover_F <- makemv_recover(1,"Mv_RecoverLand_F");
Std_MoveTable.Mv_Recover_B <- makemv_recover(2,"Mv_RecoverLand_B");

Std_MoveTable.Mv_RecoverLand_N <- makemv_recoverland(0);
Std_MoveTable.Mv_RecoverLand_F <- makemv_recoverland(1);
Std_MoveTable.Mv_RecoverLand_B <- makemv_recoverland(2);


Std_MoveTable.Mv_GroundRecover <- 
{
	function Init() : (recover_init, val_RecoverBarrierType) // 
	{
		BMvTbl.SetMuki( _Direction_Auto );

		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		Battle_Std.TypeSE_Play({ type="地上受け身" });
		
		BMvTbl.SetPattern("GUkemi_4"); // 新追加
		Battle_Std.InitVector();
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254, muteki_dageX=254, muteki_nageX=254 } ); //	受け身中は無敵
		Battle_Std.TypeSE_Play({ type="跳ね受け身" });
		
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身
		}			
		//btl_debPrint( format( "\nMv_GroundRecover::Init :%d", rst.Type ) );
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		
		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に
		
		// レバーが後ろに入っていたら後ろに滑る受身を取る
		local rst = BMvTbl.GetRecoverStatus(); // 受け身ステータスの取得
		
		// _dp("\n Mv_GroundRecover:Stick:"+rst.Stick+" Type:"+rst.Type );
		
		// rst.Stick は 前回の地上受身のが入っている。トレモの時は何となくレバーが入っているらしい。
		if( BMvTbl.CheckStickHold( (1<<4) ) || ( rst.Stick == 4 ) ) // レバー後ろならまず成功（プレイヤーor緊急受身はこれ）、Stickが4でも成功（COMの地上受身の設定）
		// if( rst.Stick == 4 || BMvTbl.CheckStickHold( (1<<4) ) ) // 後ろ ※これだとクイックリカバリーで入ってこない（寝てるMvから直接飛ぶからそりゃそうだ感）
		// if( BMvTbl.CheckStickHold( (1<<4) ) ) // 後ろ
		{
			BMvTbl.SetLP(0,1); // 受け身タイプ記憶
			BMvTbl.SetVector( { x=-1800, y=-2400, addx=0, addy=200, flags=_Vector_Normal } );
			
			//GRD減少
			Battle_Std.GRD_AddValue({ val=def_GRD_BackGroundRecover, pressure=0, boundplus=0,target=0 });						
		}
		else
		{
			BMvTbl.SetLP(0,0); // 受け身タイプ記憶
			BMvTbl.SetVector( { x=-200, y=-2400, addx=0, addy=200, flags=_Vector_Normal } );
		}
		
		if( BMvTbl.ChangeMv_GetMvName()=="Mv_NeppaRecover" )
		{
			// _dp("\n 緊急受け身");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_GenFlag ); // 緊急受け身
		}
		
		//着地先を予約
		Battle_Std.CallAddSkillCache( "GUkemi_N", 15 ); // 着地先１を予約
		//後ろ受身の方
		Battle_Std.CallAddSkillCache( "GUkemi_B", 15 ); // 着地先２を予約
	}
	function FrameUpdate() : (callLandEffect)// フレーム更新処理
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		if( mvs.isLanding )
		{
			local ukemitype = BMvTbl.GetLP(0);
			Battle_Std.InitCharaVector();
			// 地上受け身番号から
			switch( ukemitype )
			{
			case 0: //伏せ受身
				BMvTbl.SetFinalize(10); // 着地後動けていい
				break;
			case 1: //滑り受身
				BMvTbl.SetFinalize(20); // 着地後動けていい
				break;
			}
			
			callLandEffect(); // 着地エフェクト
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[10,"Mv_GroundRecoverN_Land"],[20,"Mv_GroundRecoverB_Land"] ); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
	}
}

Std_MoveTable.Mv_GroundRecoverN_Land <-
{
	function Init() // 
	{
		BMvTbl.SetPattern("GUkemi_N");
		Battle_Std.InitCharaVector();
		BMvTbl.SetVector( { x=-500, y=0, addx=100, addy=0, flags=_Vector_Div } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		Battle_Std.MoveCode.AddFlag( _MoveCode0_NoMoveBasicAction ); // 行動コード(歩き・しゃがみ移行不可)を設定
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 10 )
		{
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_GroundRecoverB_Land <-
{
	function Init() // 
	{
		BMvTbl.SetPattern("GUkemi_B");
		Battle_Std.InitCharaVector();
		BMvTbl.SetVector( { x=-2500, y=0, addx=200, addy=0, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=1, time=254, flag=_ClearFlag_ChangeMv }); //Mv内行動可能

		Battle_Std.MoveCode.AddFlag( _MoveCode0_NoMoveBasicAction ); // 行動コード(歩き・しゃがみ移行不可)を設定

		/*
		// 必殺ＣのみだとＶＯとか出せない
		// 投げ無敵がきれて行動不能なので投げが確定する
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		BMvTbl.SetMoveableFlag({ move=0, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動不能
		BMvTbl.SetAsFlag( { as_flags=_AsFlag_GuardRev, time=30, flag=_ClearFlag_ChangeMv } ); // 行動不能だけどガードは出来る
		BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=30, flag=_ClearFlag_ChangeMv } ); // 必殺Ｃのみ可能
		*/
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function FrameUpdate()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 20 )
		{
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
}


//無敵状態の移行だけを行う
Std_MoveTable.Mv_GroundRecover_Modori <-
{
	function Init() // 
	{
		BMvTbl.SetMoveableFlag({ move=1, time=30, flag=_ClearFlag_ChangeMv }); //Mv内行動可能
		
		//Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定　ここは戻りなので設定しない
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

Std_MoveTable.Mv_NeppaRecover <-
{
	function Init()
	{
		BMvEff.AttackInfoString_Set({ word=def_AISW_NeppaRecover,} );
		BMvTbl.SetFinalize(0);
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_GroundRecover" );
	}
}

// 壁受け身
Std_MoveTable.Mv_WallRecover <- 
{
	function Init() : (recover_init) // 
	{	
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("GUkemi_0");
		Battle_Std.TypeSE_Play({ type="壁受け身" });

		//壁受身エフェクトを表示
		BMvEff.CreateObject( { x=0, y=-200, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身エフェクト		
		
		recover_init(); //受け身処理
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る

		//はりつき中は無敵
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_WallRecoverMuteki, muteki_dage=def_FL_WallRecoverMuteki, muteki_dageX=def_FL_WallRecoverMuteki, muteki_nageX=def_FL_WallRecoverMuteki  } );		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		
		if( s.MvCount>=def_FL_WallRecoverWaitMax )
		{
			_dm("壁受身から自動で復帰");
			if( BMvTbl.CheckStickHold( (1<<1) | (1<<2) | (1<<3) )==1)
			{
				BMvTbl.SetFinalize(def_FC_WallRecover_Sita); //下受身
			}
			else
			{
				BMvTbl.SetFinalize(0); //普通受身			
			}
		}
	}
	function LastUpdate()
	{
		//無敵解除
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0, muteki_dageX=0, muteki_nageX=0  } );		
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_WallRecover_Jump", [def_FC_WallRecover_Sita,"Mv_WallRecover_Jump_Sita"] ); //デフォ,[code,mv]...
	}
}// 

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump <- 
{
	function Init() // 
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("DUkemi_0");
		BMvTbl.SetVector( { x=1600, y=-3500, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}	
	}	
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}

//とりあえずこれでバグらんようにしとこ
Std_MoveTable.Mv_WallRecover_Jump_Sita <- 
{
	function Init() // 
	{
		BMvTbl.SetMuki( _Direction_Auto );
		BMvTbl.SetPattern("DUkemi_0");
		BMvTbl.SetVector( { x=0, y=1000, addx=0, addy=250 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_RecoverMuteki, muteki_dage=def_FL_F_RecoverMuteki, muteki_dageX=def_FL_F_RecoverMuteki, muteki_nageX=def_FL_F_RecoverMuteki  } );

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定		
	}
	function FrameUpdate()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			//着地したら時間の無敵は解除
			Battle_Std.InitVector(); // ベクトル初期化
			BMvEff.SetPlayerTimer( { muteki_nage=def_FL_OkiagariNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_OkiagariNageMuteki } );		
		}
	}
	function Finalize() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" ); //共通落下をはさむので地上でいい
	}
}




//オートリカバー共通処理
//受け身共通処理と重ねて呼ばれる
local autorecover_init = function()
{
	local combotime_pos = 0;
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.IsDone )
	{
		if( BMvCore.PushCharaData( enemy ) )
		{
			combotime_pos = BMvEff.SpGauge_GetPlusCorrect_ComboTimePos();
		}
		BMvCore.PopCharaData(); // 
	}

	//コンボの長さレベルからリカバリーボーナスを変更
	local combotime_lv = 3 - combotime_pos; //最後にダメージ受けた時点でのコンボの長さレベル
	//print("\ncombotime_lv:"+combotime_lv);
	local exsplus = 1000; //増加させるＥＸＳ量基本値
	local grdplus = def_GRD_AutoRecoverLv1; //増加させるＧＲＤ基本値
	if( combotime_lv >= 3 ) //３段階以降(x2.0)なら
	{
		exsplus = def_SP_AutoRecoverLv3;
		grdplus = def_GRD_AutoRecoverLv3;
	}
	else if( combotime_lv == 2 ) //２段階目(x1.5)なら
	{
		exsplus = def_SP_AutoRecoverLv2;
		grdplus = def_GRD_AutoRecoverLv2;
	}
	else if( combotime_lv == 1 ) //１段階目(x1.0)なら
	{
		exsplus = def_SP_AutoRecoverLv1;
		grdplus = def_GRD_AutoRecoverLv1;
	}
	else if( combotime_lv == 0 ) //０段階目（x0.5）なら
	{
		exsplus = def_SP_AutoRecoverLv0;
		grdplus = def_GRD_AutoRecoverLv0;
	}
	BMvEff.SetSpGauge( { value=exsplus, limitval=1.0, correct=0 } ); //ＥＸＳを増加させる
	Battle_Std.GRD_AddValue({ val=grdplus }); //受身でＧＲＤをより増加させる
}

//自動復帰
//浮きやられ復帰の空中状態。地上状態での復帰は別Ｍｖになった。Mv_Modori_UkiSirimoti
Std_MoveTable.Mv_AutoRecover <- 
{
	function Init_Std() : (recover_init, autorecover_init) // 
	{
		local vec = BMvTbl.GetVector(0);
		//print(format("\nvec x:%d y:%d",vec.x, vec.y));
	
		//Battle_Std.TypeSE_Play({ type="自動受け身" });
	
		BMvTbl.SetPattern("UUkemi_1");
		BMvTbl.SetVector( { addy=150, flags=_Vector_Normal } ); //ふんわり浮きにする
		BMvTbl.SetVector( { y=-1000,  flags=_VecFlag_Add } ); //ふんわり浮きにする
		
		BMvTbl.SetMoveableFlag( { move=0, time=254, flag=_ClearFlag_ChangeMv } ); //Mv中は行動不能に

		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		}			
		
		//ログ追加
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );		
		
		recover_init(); //受け身処理
		autorecover_init(); //オートリカバー処理
		BMvEff.SetPlayerTimer( { muteki_dage=254, muteki_nage=254 } ); //無敵時間を設定
		BMvTbl.SetMuki(_Direction_Auto);
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus();
		if( s.isLanding )
		{
			Battle_Std.InitVector(); // ベクトル初期化
			BMvTbl.SetFinalize(256); //着地終了
		}
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_AutoGroundRecover"] ); //デフォ,[code,mv]...
	}
}



//自動復帰中の着地
Std_MoveTable.Mv_AutoGroundRecover <- 
{
	function Init_Std()
	{
		Battle_Std.InitVector(); // ベクトル初期化
		//BMvTbl.SetPattern("GUkemi_2");
		BMvTbl.SetPattern("GUkemi_1");
		Battle_Std.TypeSE_Play({ type="地上受け身" });
		Battle_Std.TypeSE_Play({ type="跳ね受け身" });
		Battle_Std.TypeSE_Play({ type="自動受け身" });
		
		Battle_Std.SetCharaFlash_Ukemi(); //受身で光る
		BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0 } );
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_F_GroundRecoverMuteki, muteki_dage=def_FL_F_GroundRecoverMuteki, muteki_dageX=def_FL_F_GroundRecoverMuteki, muteki_nageX=def_FL_F_GroundRecoverMuteki } ); //	
		
		BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=23, flags=_Position_ToolShift } ); //受身

		Battle_Std.MoveCode.AddFlag( def_MC_Recovery ); // 行動コード(受け身)を設定
	}
	function FrameUpdate() // フレーム更新処理
	{
		local s = BMvTbl.GetMvStatus();
		switch( Battle_Std.GetUpdateFrameID( s ) )
		{
		case 100:
			//ID100にきた時のフレームからベクトルを計算する
			local vecx = 20000/(15-s.MvCount);
			local vecaddy = (1000/(15-s.MvCount))*2;

			_dm(format("vecx:%d mvcount:%d",vecx,s.MvCount))
			BMvTbl.SetVector( { x=-vecx, y=-1000, addx=0, addy=vecaddy } );
			break;
		case 150: //メルカヴァ用移動開始　※未使用
			BMvEff.StdCall( { type=6, no=12, param=[ -156,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 151: //メルカヴァ用移動開始
			BMvEff.StdCall( { type=6, no=12, param=[ -50,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 250: //メルカヴァ用着地
			BMvEff.StdCall( { type=6, no=12, param=[ -80,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;
		case 255: //メルカヴァ用着地
			BMvEff.StdCall( { type=6, no=12, param=[ -26,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); // 受身移動
			break;				
		case 200: //汎用着地
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=20, flags=_Position_ToolShift } ); //着地				
			break;
		case 210: //ワレン用着地
			BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=290, flags=_Position_ToolShift } ); //着地				
			break;
		}
		if( s.MvCount > def_FL_GroundRecoverHane_Recovery )
		{
			BMvTbl.SetFinalize(256);
		}
		if( BCMDTbl.CheckCancel()==255)
		{
			_dm("行動可能になったので受身状態解除");
			BMvTbl.SetFinalize(256);
		}
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_GroundRecover_Modori"]); //デフォ,[code,mv]...
	}
	function LastUpdate()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_GroundRecoverModoriNageMuteki, muteki_dage=0, muteki_dageX=0, muteki_nageX=def_FL_GroundRecoverModoriNageMuteki } );
		Battle_Std.Reversal.SetTime(); //リバーサル受付＋判定オブジェクト生成
		// BMvEff.SetExist( { level=_Exist_NoKasanariHantei, mode=_ExistMode_Erase } ); //重なり判定を復活
	}	
}


//空攻撃のけぞり着地（しりもち）からの復帰
Std_MoveTable.Mv_Modori_UkiSirimoti <- 
{
	function Init_Std() : (recover_init, autorecover_init)
	{
		Battle_Std.InitVector(); // ベクトル初期化

		BtlMvStd.ClearBound(); // 状態解除　もうやられ状態ではなくす
		
		BMvTbl.SetFinalize(0);

		local eff = BMvEff.CreateObject( { x=0, y=-250, mvname="", datatype=1, start_pat=7, flags=_Position_ToolShift } );
		if( eff.IsDone )
		{
			BMvCore.PushCharaData( eff );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			BMvCore.PopCharaData();
		}
		
		BMvEff.AttackInfoString_Set({ word=def_AISW_AutoRecover,} );

		recover_init(); //受け身処理
		autorecover_init(); //オートリカバー処理

		local useval = (BMvEff.GRD_GetJudgeResult()>0)? def_GRD_BoundFU_Vorpal: def_GRD_BoundFU;
		Battle_Std.GRD_AddValue({ val=useval, pressure=0, boundplus=1 });	
	}
	function Finalize_Std() // 
	{
		BMvTbl.SetNextMoveTable( "Mv_AutoGroundRecover" );	//ファイナライズ
	}
	function LastUpdate_Std() // 
	{
		BtlMvStd.ClearBound(); // 状態解除
	}	
}


// 後から暗転するEX技の監視オブジェクト


Std_MoveTable.Mv_DelayExCutinObj <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );		
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	}
	function FrameUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local vanish = 0;
			local stopframe = def_FL_EXCutinStopTime;
			// 特殊判定１を監視して、見つかったらカットイン処理へ
			local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc0.sx != _Hantei_Error ) // 存在するか
			{
				Battle_Std.SetEXCutinCameraFocus( stopframe );
				Battle_Std.SetEXCutinGrp();
				vanish = 1;
			}
			player.pop();
			
			if( vanish ) BMvTbl.SetFinalize( 0 ); // 終わり
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


// Battle_Std.CSAntenGaesi_DamageHosei から呼ばれる
// CSでのキャンセルならうんたん、それ以外ならキツいダメージ補正をかける
// 要するにCSでないと追撃不能、という処理だと弱体化が激しいので
// CSでないとダメージ低い、という調整をするためのもの
Std_MoveTable.Mv_Null_CSHoseiChecker <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
		// BMvTbl.SetLP(0,0); // 上書き補正
		// BMvTbl.SetLP(0,0); // 乗算補正
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount > 60 )
		{
			BMvTbl.SetFinalize( 0 );
			// lastupdateからmv変更まで60fもかかることはないと思うのでここで抜ける
		}
		
		// Mv名を監視する
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) == 0 )
		{
			// 別のMvに変わったようだよ
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local mvname = BMvTbl.GetMvName();

				player.pop();
				
				if( mvname=="Mv_Convert" )
				{
					// CSで抜けた
					_dp("\n CSキャンセルだったね");
					BMvTbl.SetFinalize( 100 );
					return;
				}
			}
			
			BMvTbl.SetFinalize( 200 );
			local uwagaki = BMvTbl.GetLP(0);
			local zyozan = BMvTbl.GetLP(1);
			if( uwagaki ) BMvEff.ComboView_Set( { val=uwagaki, type=0 } ); // 上書き補正
			if( zyozan ) BMvEff.ComboView_Set( { val=zyozan, type=1 } ); // 乗算補正
			_dp("\n ★補正適用 上書き:"+uwagaki+" 乗算:"+zyozan );
			return;
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}


//暗転されると生成されて、自分が暗転後動けるようになると消えるオブジェクト
//相手から生成を呼ばれるので注意
Std_MoveTable.Mv_Null_AntenStopObject <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
	}
	function FrameUpdate_Std()
	{
		local anten_stop = 1;
		
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 2 )
		{
			anten_stop = 0; // このフレームまできたらもう暗転終わってる
		}
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			if( anten_stop )
			{
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnemyAntenStop );
			}
			else
			{
				Battle_Std.MoveCodeEx.DelFlag( 2, def_MC2_EnemyAntenStop );
			}
			player.pop();
		}
		if( anten_stop != 1 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//次のフレームに暗転キャラに打撃無敵をつける
//EX必殺技専用
Std_MoveTable.Mv_Null_SetNextMutekiObject <-
{
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);// 生成時にセットされる暗転時間
	}
	function FrameUpdate_Std()
	{
		//暗転〜生成までに間に攻撃されたりした場合はすぐに消す
		if( Battle_Std.CheckPlayerisBound() )
		{
			BMvTbl.SetFinalize(0);
			return;
		}
		
		local anten_frame = (BMvTbl.GetLP(0) - 1); // 1F後なので暗転フレームも-1される

		local mvs = BMvTbl.GetMvStatus();
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local pmvs = BMvTbl.GetMvStatus();
			
			local is_ex_skill = ( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) && Battle_Std.MoveCode.CheckFlag( def_MC_EXAction ) );
			//基本的にはmvs.MvCount >= 1でOKだが、別のMvを0F経由してから出た技の場合、このオブジェクト自体の生成が1F遅れてしまう仕様がある
			//そのため、保険の意味もかねてプレイヤーのMvCountもチェックしている

			local set_muteki = ( mvs.MvCount >= 1 || pmvs.MvCount >= 2 );
			// _dpn("Frame:"+mvs.MvCount+" p:"+pmvs.MvCount+" set:"+set_muteki );
			
			if( set_muteki && is_ex_skill )
			{
				BMvEff.SetPlayerTimer( { muteki_dage=anten_frame, muteki_dageX=anten_frame } );
			}
			player.pop();
			
			if( set_muteki )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//次のフレームにカメラを追従カメラにくっつける
Std_MoveTable.Mv_Null_NextFrameResetViewCamera <-
{
	function Init_Std()
	{
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			BMvEff.ResetViewCamera();
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//1F経由しないとヒットした瞬間にダメージフラグが設定できないのでこうしている
Std_MoveTable.Mv_Null_EnemyDamageFlag_DelayAdd <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		// BMvTbl.SetLP(0,0);//フラグを親から受け取る
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.MvCount >= 1 )
		{
			_dpn("フラグセット");
			Battle_Std.EnemyDamageFlag_Add( BMvTbl.GetLP(0) );
			BMvTbl.SetFinalize(0);
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

//InActive検知のあと相手が行動可能になるまで継続する
//これが生きている間に殴ると相手のゲージ増加量が減る
Std_MoveTable.Mv_Null_KeepInActive <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		Battle_Std.GS_AddFlag( def_PP_GS_KeepInActive );
		
		// BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_Std()
	{
		local player_is_movable = Battle_Std.CheckPlayerisMovable();
		if( player_is_movable )
		{
			BMvTbl.SetFinalize(0);
			Battle_Std.GS_DelFlag( def_PP_GS_KeepInActive );
		}
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		Battle_Std.GS_DelFlag( def_PP_GS_KeepInActive );
	}
}


_dp1p("\n btl_UkemiFunc.....OK");
//Battle_Std.SetVector <- ukemi_tbl.SetVector;

	
Std_MoveTable.Mv_Taunt <- //se doesnt work in the custom for some reason
{
	function Init_Std()
	{
		local taunt_pat_num = BMvEff.GetPatternNum( { datatype=0, pat="Taunt" } );
		if( taunt_pat_num != -1 ) //if we have a custom taunt pattern, let the character handle taunt script
		{
			BMvTbl.SetPattern(taunt_pat_num);
			
			Battle_Std.TypeSE_Play({ type="Taunt_Init" });
		}
		else
		{
			BMvTbl.SetPattern(def_PAT_Neutral);
			BMvTbl.JumpFrameID( 512 );
				
			Battle_Std.InitCharaVector(); //慣性を残したベクトル初期化
			
			BMvTbl.SetMoveableFlag( { move=0, time=1024, flag=_ClearFlag_ChangeMv } );
			
			if( Battle_Std.TypeSE_Play({ type="Taunt_Init" }) ) //play assigned taunt se if available
			{
				
			}
			else
			{
				Battle_Std.TypeSE_Play({ type="挑発" });
			}
			
			BMvTbl.SetMuki(_Direction_Auto);
			
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_ExCancel, time=1024, flag=_ClearFlag_ChangeMv } );
		}
		

	}
	function FrameUpdate_Std()
	{
		Battle_Std.TypeSE_Play({ type="Taunt_FU" });
	}
	function Update_Std() // 
	{
		Battle_Std.GRD_AddValue({ val=50, boundplus=1, target=0 }); 
		if( Battle_Std.GetUpdateFrameID()==5000 ) BMvTbl.SetFinalize(0);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Furimuki_S"] ); //デフォ,[code,mv]...
	}
}

Std_MoveTable.Mv_Obj_Aka_EnemyDummy <- //required for akatsuki iw abk ee
{
	function Init_After()
	{
		BMvTbl.SetPrio( _CharaPrio_GaugeCombo_P1 );
		BMvTbl.SetPattern(331);
		
		//Battle_Std.DrawDebugAttackInfo( "e_dum" );
	}
	function FrameUpdate_After()
	{
		local s = BMvTbl.GetMvStatus();	
		if(s.MvCount > 1)  BMvTbl.SetFinalize(0);
	}
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

local file = "./script/CustomMv.txt";
if( BtlMvStd.IsFileAlive( file ) )
{
	__dofile__( file )
	
	Std_MoveTable = merge_mvtbl(Std_MoveTable); //merge a custom stdmvtable with the current one
}

//定義したテーブルを返す
return Std_MoveTable;

}//end

// 壁激突やられベクトルを返す
function Battle_Std::GetWallBoundVector()
{
	return 255; // 文字列でも大丈夫
}

btl_debPrint2( "\n>>> [btl_MvFunc]" );

Battle_Std.AddToolShift_NoSurinuke_FU <- function( param=0, flag=0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate )
	{
		local param_val = BMvTbl.GetFrameParam( param );
		if( param_val >> 0 )
		{
			if(param_val > 127)
			{
				param_val = param_val - 256;
			}
			
			Battle_Std.AddToolShift_NoSurinuke( param_val, flag );
		}
	}
}

Battle_Std.SetEnemyBoundSt <- function( boundst_param )
{
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		if( enemy.push() )
		{
			BMvEff.SetBoundSt( boundst_param );
			enemy.pop();
		}
	}
}

Battle_Std.GetEnemyBoundStatus <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus(); 
			enemy.pop();
			
			return bs;
		}
	}
}

Battle_Std.DebugFunc <- {};


Battle_Std.DebugFunc.Test <- function()
{
	Battle_Std.DrawDebugAttackInfo( "btlfunc works" );
}



Battle_Std.DebugFunc.CallDebugUpdate <- function()
{
	local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle()==1;
	if( Def_Dbg_HboxTrainingModeOnly==0 || isTraining )
	{
		//if(Def_Dbg_DrawHitBox) BMvEff.CreateObject( { mvname="Mv_InitCheckHitbox" } );
	}
}

Battle_Std.DebugFunc.CallAtkInitScript <- function()
{
	
	local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle()==1;
	
	if( Def_Dbg_TrainingModeOnly==0 || isTraining )
	{
			
		if( Def_Dbg_AltFrameCheck == 0 )
		{
			local e = BMvEff.CreateObject( { mvname="Mv_Obj_CheckStarupFrame_Debug", datatype=1, start_pat=999 } );
			BMvCore.PushCharaData( e ); //	
				BMvTbl.SetLP(0,1); //1F測定を遅らせる
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus } );
			BMvCore.PopCharaData(); //
		}
			
		if( ( isTraining && Def_Dbg_StateChecker==2 ) || Def_Dbg_StateChecker==1 )
		{
			local a = BMvEff.CreateObject( { mvname="Mv_Obj_CheckState_Debug", datatype=1, start_pat=999 } );
			BMvCore.PushCharaData( a ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus } );
			BMvCore.PopCharaData(); //
		}
		
		if( ( isTraining && Def_Dbg_CancelChecker==2 ) || Def_Dbg_CancelChecker==1 )
		{
			local b = BMvEff.CreateObject( { mvname="Mv_Obj_CheckCancel_Debug", datatype=1, start_pat=999 } );
			BMvCore.PushCharaData( b ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus } );
			BMvCore.PopCharaData(); //
		}
		
		if( ( isTraining && Def_Dbg_CheckInvuln==2 ) || Def_Dbg_CheckInvuln==1 )
		{
			local b = BMvEff.CreateObject( { mvname="Mv_Obj_CheckInvuln_Debug", datatype=1, start_pat=999 } );
			BMvCore.PushCharaData( b ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus } );
			BMvCore.PopCharaData(); //
		}	
		
	}
}
	
Battle_Std.DebugFunc.CallStartupDebugScript <- function()
{
	
	local isTraining = BMvTbl.GetMvStageStatus().IsTrainingBattle()==1;
	
	if( isTraining && Def_Dbg_TrainingModeOnly ) Battle_Std.DrawDebugAttackInfo("training debug mode enabled");
	
	if( !Def_Dbg_TrainingModeOnly || isTraining )
	{
		local e = BMvEff.CreateObject( { mvname="Mv_ErrorCheckObject" } );
		
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
				BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } ); //隠すｗ			
			BMvCore.PopCharaData();
		}
		
		if( ( isTraining && Def_Dbg_AltFrameCheck == 2 ) || Def_Dbg_AltFrameCheck == 1 )
		{
			local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckStartupFrameAlternate_Debug", datatype=1, start_pat=999 } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop|_ObjFlags_FromParentStop|_ObjFlags_ToParentHitBack|_ObjFlags_ToParentHitStatus } );
				
				BMvTbl.SetLP(0,-1);
				BMvTbl.SetLP(1,0);
				BMvTbl.SetLP(2,0);
				BMvTbl.SetLP(3,-1);
				BMvTbl.SetLP(4,0);
				BMvTbl.SetLP(5,0);
				
				eff.pop();
			}
		}
		
		if( ( isTraining && Def_Dbg_CheckInvulnMode2==2 ) || Def_Dbg_CheckInvulnMode2 == 1 )
		{
			local b = BMvEff.CreateObject( { mvname="Mv_Obj_CheckInvulnAlt" } );
			BMvCore.PushCharaData( b ); //	
				BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop | _ObjFlags_NoGround | _ObjFlags_NoRender | _ObjFlags_MoveTimeStopAll } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvCore.PopCharaData(); //
		}
		
		if ( ( isTraining && Def_Dbg_DrawComboMeter==2 ) || Def_Dbg_DrawComboMeter==1 )
		{
			local eff1 = Battle_Std.DrawRect({ mvname="Mv_Obj_ComboMeter_Debug", width=100, height=6, y=-150, x=-180, color=0x00ff00 });
			if(eff1.push())
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
				eff1.pop();
			}
			
			local eff2 = Battle_Std.DrawRect({ mvname="Mv_Obj_ComboDmgMeter_Debug", width=100, height=6, y=-120, x=-180, color=0x00ff00 });
			if(eff2.push())
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
				eff2.pop();
			}
			
			local eff3 = Battle_Std.DrawRect({ mvname="Mv_Obj_ComboMinHosei_Debug", width=100, height=6, y=-90, x=-180, color=0x00ff00 });
			if(eff3.push())
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
				eff3.pop();
			}
		}
		
		if ( ( isTraining && Def_Dbg_DrawComboMeterDisplay==2 ) || Def_Dbg_DrawComboMeterDisplay==1 )
		{
			for( local i=0, b=-180; i<3; i++, b+=15 )
			{
				local eff1 = BMvEff.CreateObject( { datatype=1, mvname="Mv_Obj_ComboMeterDisplay_Debug", start_pat="dbg_obj_number", y=-160*128, x=( (b)*128 )*BMvTbl.GetMuki() } );
				if(eff1.push())
				{
					BMvTbl.SetLP(0,i);
					
					BMvTbl.SetLP(1,b);
					
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
					
					BMvTbl.SetMuki( _Direction_Right );
					
					BMvTbl.SetScale( { x=10000/3, y=10000/3 } );
					
					eff1.pop();
				}
			}
		}
		
		if ( ( isTraining && Def_Dbg_DrawComboMeterDmgDisplay==2 ) || Def_Dbg_DrawComboMeterDmgDisplay==1 )
		{
			for( local i=0, b=-180; i<3; i++, b+=15 )
			{
				local eff1 = BMvEff.CreateObject( { datatype=1, mvname="Mv_Obj_ComboMeterDmgDisplay_Debug", start_pat="dbg_obj_number", y=-130*128, x=( (b)*128 )*BMvTbl.GetMuki() } );
				if(eff1.push())
				{
					BMvTbl.SetLP(0,i);
					
					BMvTbl.SetLP(1,b);
					
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
					
					BMvTbl.SetMuki( _Direction_Right );
					
					BMvTbl.SetScale( { x=10000/3, y=10000/3 } );
					
					eff1.pop();
				}
			}
		}
		
		if ( ( isTraining && Def_Dbg_DrawComboMeterMinHoseiDisplay==2 ) || Def_Dbg_DrawComboMeterMinHoseiDisplay==1 )
		{
			for( local i=0, b=-180; i<3; i++, b+=15 )
			{
				local eff1 = BMvEff.CreateObject( { datatype=1, mvname="Mv_Obj_ComboMinHoseiDisplay_Debug", start_pat="dbg_obj_number", y=-100*128, x=( (b)*128 )*BMvTbl.GetMuki() } );
				if(eff1.push())
				{
					BMvTbl.SetLP(0,i);
					
					BMvTbl.SetLP(1,b);
					
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll } );
					
					BMvTbl.SetMuki( _Direction_Right );
					
					BMvTbl.SetScale( { x=10000/3, y=10000/3 } );
					
					eff1.pop();
				}
			}
		}
		/*
		if( ( isTraining && Def_Dbg_DrawCharaMarker==2 ) || Def_Dbg_DrawCharaMarker==1 )
		{
			Battle_Std.DrawPoint({});
		}
		*/
		
				
		if( ( isTraining && Def_Dbg_DebugFunctions==2 ) || Def_Dbg_DebugFunctions==1 )
		{
			local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_DebugFunctions_Debug" } );
			if(eff.isdone())
			{
				if(eff.push())
				{
					//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll  } );
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
					eff.pop();
				}
			}		
		}
	}
	
}



//投げ抜け関係の共通処理
Battle_Std.ThrowTech <- {};
//local TechFunc = Battle_Std.ThrowTech; //めんどいので

Battle_Std.ThrowTech.SetMuteki <- function() //つかみ中は自分も相手も無敵にする
{
	//つかみ中は自分も相手も無敵にする
	BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかみ中は無敵にする
	
	//相手も無敵に
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } ); //つかまれ中は無敵にする
		
		enemy.pop();
	}
}

//Battle_Std.ThrowTech.SetPos
//type=0:通常投げ 1:必殺技とか？
Battle_Std.ThrowTech.SetPos <- function(type=0) //つかむ前の自分と相手の座標を記憶する
{
	local ppos = BMvTbl.GetPosition(0);				//自分の座標
	BMvTbl.SetPP( def_PP_PlayerPosX, ppos.x );		//自分の座標を記憶

	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	BMvTbl.SetPP( def_PP_EnemyPosX, epos.x ); 		//相手の座標を記憶
	
	if( type==1 ) //type:1 必殺技の投げ
	{
		BMvTbl.SetPP( def_PP_TechReverse, 0 ); //とりあえず逆向き開放は無いってことで
	}
}

// この関数は投げで掴む瞬間にしか呼んではいけない(GetMvHitStatusを見るので)
Battle_Std.ThrowTech.CheckTechImpossible <- function( _setCharaFlash = 1 ) //相手が投げ抜けできない状態かチェックして演出を入れるまとめ処理
{
	//相手が行動不能かどうかチェック
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	local enemy_isMovable = true; //敵が行動可能かどうか
	local mvhs = BMvTbl.GetMvHitStatus();
	local throw_counter = 0;
	
	if( enemy.push() )
	{
		// if( BCMDTbl.CheckCancel( _SkillType_None )!=255 ) // 行動不能中 ※投げでMv_BoundCaptureになるとスクリプト操作が1Pだけ消える
		if( mvhs.isMoveable != 1 ) // 相手が行動可能じゃなかった
		{
			// if( Def_Dbg_TechHitLog ) _dm("行動不能中を掴まれた");
			
			if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
			{
				// if( Def_Dbg_TechHitLog ) _dm("投げモーション中の行動不能でした");
			}
			else
			{
				//print("\n乙");
				enemy_isMovable = false;
				if( _setCharaFlash )
				{
					throw_counter = 1;
					Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
					Battle_Std.SetTechMissStatus(); //投げ抜け不能にする
				}
			}
		}
		else
		{
			//行動可能中
		}
		enemy.pop();
		
		if( throw_counter )
		{
			Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_ThrowCounter );//投げで硬直を掴んだ
		}
		
		if(!enemy_isMovable)
		{
			return true;
		}
	}
	return false;
}

Battle_Std.ThrowTech.ShiftOverGamenHajiX <- function() //相手が画面端だったら埋まらないようにつかみ側と記憶してた座標をズラす
{
	local epos = Battle_Std.GetEnemyPosition();		//相手の座標		
	local sa_x = 0;
	//_dm("座標:"+epos.x);
	if( epos.x > def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - def_POS_TechOverGamenHajiX;
	}
	else if( epos.x < -def_POS_TechOverGamenHajiX )
	{
		sa_x = epos.x - -def_POS_TechOverGamenHajiX;
	}
	//_dm("差："+sa_x);
	if( sa_x != 0 )
	{
		BMvTbl.SetPosition( { x=-sa_x, flags=_Position_Add } );
		local pposx = BMvTbl.GetPP( def_PP_PlayerPosX ); //保存してある自分の座標を取得
		pposx -= sa_x; //こっちもズラす
		BMvTbl.SetPP( def_PP_PlayerPosX, pposx );		//自分の座標を更新		
	}
}

//通常投げ成立時に呼ばれる
//特殊判定の座標にやられ絵にする
Battle_Std.ThrowTech.SetThrowParam <- function()
{
	if( Def_Rule_SetThrowType )
	{
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			if( Def_Rule_SetThrowType == 1 )
			{
				BMvEff.ThrowParam( { pattern=304, x=rc.sx, y=0, } );
			}
			else if( Def_Rule_SetThrowType == 2 )
			{
				BMvEff.ThrowParam( { x=rc.sx, y=rc.sy, pattern=320, hantei_rect=[ _Hantei_Etc, 10 ] } );
			}
		}
	}
}

//投げエフェクトよびだし
//通常投げ・必殺技共通 typeは強引の投げかどうか
Battle_Std.ThrowTech.DrawThrowEffect <- function(type=0) //ヒット座標につかみエフェクトを表示
{
	//_dm("DrawThrowEffect");
	//ヒット座標につかみエフェクト出す？足元に出たりするから…
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange|_HanteiFlag_Tool } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		if( type==0 ) //通常の投げ
		{
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=55,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
		}
		else if( type==1 ) //強引の投げ
		{
			//つかみ座標に出すタイプ
			/*
			Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
			datatype=1, pat=58,
			objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
			});
			*/
			
			//重なりを見て出すタイプ
			local enemy = BMvCore.GetCaptureCharaData(); // 敵情報を得る
			if(enemy.IsDone)
			{
				local epos = BMvTbl.GetPosition( { flags=_Position_CaptureChara } ); //掴みキャラなので

				//つかみ相手の重なり判定を取得
				BMvCore.PushCharaData( enemy ); // 
					local erc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange } );
				BMvCore.PopCharaData(); // 

				if( erc.sx != _Hantei_Error ) // 存在するか
				{
					//敵側から出す
					BMvCore.PushCharaData( enemy ); // 
						Battle_Std.CreateObjectEX({ x=0, y=(erc.sy*65/100),
						datatype=1, pat=58,
						objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoGround
						});		
					BMvCore.PopCharaData(); // 					
				}
				else
				{
					//重なりが無いなら今までどおりつかみ側の特殊判定のところに出す
					Battle_Std.CreateObjectEX({ x=rc.sx, y=rc.sy, flags=_Position_ToolShift,
					datatype=1, pat=58,
					objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround 
					});				
				}
			}
		}
	}
	else
	{
		local hitpos = BMvEff.GetAttackHitPos();		
		local y_min = -250*128; //最低高さ値
		if( hitpos.y > y_min ) hitpos.y = y_min;
		Battle_Std.CreateObjectEX( { setx=hitpos.x, sety=hitpos.y,
		datatype=1, start_pat=55,
		objectflags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround
		});
		// _dem("Mv_Throw_F_TechWait:掴み位置指定の特殊矩形が無い");
	}
	//画面揺らしを発生
	BMvEff.SetCamera_Quake( { time=7, type=1, } ); //横ゆれ	
}

Battle_Std.ThrowTech.DrawTechEffect <- function() //投げ抜け演出を表示
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		if( def_AISW_TechHit ) BMvEff.AttackInfoString_Set({ word=def_AISW_TechHit,} );
		Battle_Std.SetCharaFlash_TechSuccessInit(); //投げ抜け成功発光
		BMvEff.CreateObject( { mvname="", datatype=1, start_pat=132, flags=0 } ); //投げぬけ音声
		Battle_Std.TypeSE_Play({ type="投げ抜け" });
		
		//【トロフィー】実戦で投げ抜けを成功させた。
		BMvTbl.Achievement_Unlock(1);
		
		enemy.pop();
	}
}

Battle_Std.ThrowTech.TechRelease <- function() //投げ抜けされた時の開放処理
{
	//投げ前の座標に戻す処理
	local pos_x = BMvTbl.GetPP(def_PP_PlayerPosX); //予定している戻すＸ座標
	//画面外とかありえない数値だとヤバいので補正をかけよう
	if( pos_x >= def_POS_GamenHajiX )
	{
		pos_x = def_POS_GamenHajiX;
	}
	else if( pos_x <= -def_POS_GamenHajiX )
	{
		pos_x = -def_POS_GamenHajiX;
	}
	BMvTbl.SetPosition( { x = pos_x, y=0 } ); //自分の座標を戻す(Yは地面固定)
	
	local sa = (BMvTbl.GetPP(def_PP_EnemyPosX) - BMvTbl.GetPP(def_PP_PlayerPosX))/128;
	sa = ((sa >= 0)?  sa : -sa);
	
	//一度でも殴られていないとのけぞりを返す相手がいないので
	//つかみ中の相手は操作親に一度殴られたことにする
	local enemy = BMvCore.GetCaptureCharaData(); // 投げている相手を取得
	if( enemy.isdone() )
	{
		BMvCore.SetLastDamageCharaData(enemy); // 殴られたことに
	}
	
	//相手を投げ抜け押し返しのモーションで解放し、自分も	Mv_Techedに移動
	BMvEff.ThrowParam( { x=sa+64, y=0 } ); //ツール座標（これは座標補正がかかるからそのままで大丈夫だろ）
	BMvEff.ThrowRelease( { type="投げ抜け押し返し" } ); //適当
}

//投げ抜けMVのUpdateで呼ばれて、投げ抜けをチェックする
Battle_Std.ThrowTech.CheckTechCommand <- function() //投げ抜け入力をされたかチェック
{
	local enemyistech = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	
	if( Battle_Std.CharaisKO() ) return false; // 誰かがＫＯ状態なら常に失敗

	//ＫＯ状態でない時
	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone ) // かつて投げ抜けを入れてた
		{
			if( ts.isTechOK )
			{
				enemyistech = true;			
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜けを入れて通ったぜ");
			}
			else
			{
				enemyistech = false;			
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜け失敗フレーム中でした");
			}
		}
		else // 入れてないなら手動も受け付ける
		{
			local check = 0;
			if( Def_Rule_GroundThrowType == 0 ) // 投げスカりあり
			{
				check = BMvTbl.CheckCommandString( { command=["A+D"], lastdelay=1 } );
			}
			else // 投げスカリなし
			{
				check = BMvTbl.CheckCommandString( { command=["4+C","6+C"] } );
			}
			if( check )
			{
				enemyistech = true;
				// if( Def_Dbg_TechHitLog ) _dm("投げ抜けしたお"); //しゃがグラとかがこの辺
			}
		}
		enemy.pop();
	}
	return enemyistech;
}

//Battle_Std.SetThrowHitFinalize()　で呼ばれる用の関数
Battle_Std.ThrowTech.CheckTechMissFrame <- function() //投げ抜け失敗フレームなのかチェック
{
	local enemyistechmiss = false; //敵が投げ抜けコマンドを入れたかどうかフラグ
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る

	if( enemy.push() )
	{
		local ts = Battle_Std.GetTechStatus(); //投げ抜けステータス取得
		if( ts.isDone && ts.isTechOK == false )
		{
			enemyistechmiss = true;			
			// if( Def_Dbg_TechHitLog ) _dm("投げ抜け失敗フレーム中でした！ばいばい！");
			Battle_Std.SetCharaFlash_TechMiss(); //投げ抜け不能による発光
		}
		enemy.pop();
	}
	return enemyistechmiss;
}


//1F後に投げ属性フラグを消去する
Battle_Std.ThrowTech.DelThrowMvFlag_NextFrame <- function()
{
	BMvEff.CreateObject( {  mvname="Mv_Obj_DelThrowMv" } ); //1F後にフラグを消すMvを作成
}

Battle_Std.ThrowTech.SetThrowMvFlag <- function()
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
}

//投げ属性モーションを設定し、一定時間orMvの変更により自動で属性を消す
Battle_Std.ThrowTech.SetThrowMvFlag_AutoDel <- function( frame=0 )
{
	Battle_Std.SetPSFlag( def_PP_PS_isThrowMv ); //投げ属性モーションを設定
	
	local eff = BMvEff.CreateObject( {  mvname="Mv_Obj_SetAutoThrowMv" } );
	if( eff.push() )
	{
		BMvTbl.SetLP( 0, frame );
		
		eff.pop();
	}
}



Battle_Std.Reversal <- {};

Battle_Std.Reversal.SetTime <- function( frame=1 )
{
	//実際の関数は1F早く進んでしまうのでtime=frame+1となる
	local time = frame+1;
	//print("\nここではいってくるー");
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		BMvTbl.SetCommandLongDelay(time); //リバーサルを一定時間受け付ける
		BMvTbl.SetPP( def_PP_ReversalLeftTime, time+1 ); //このオブジェクトはさらに先に1F減っちゃうので+1Fする
		//さらにのこり時間を減らすオブジェクトを生成する
		BMvEff.CreateObject( {  mvname="Mv_Obj_ReversalTime" } ); //1F後にフラグを消すMvを作成
		
		player.pop();
	}
}

Battle_Std.Reversal.GetTime <- function()
{
	return( BMvTbl.GetPP( def_PP_ReversalLeftTime ) );
}

//リバーサルの残り時間があったら１を返して文字列表示
Battle_Std.Reversal.CheckTime_DrawInfo <- function( _drawinfo = 1 )
{
	if( GetTime() > 0 )
	{
		if( _drawinfo ) BMvEff.AttackInfoString_Set({ word=def_AISW_Reversal,} ); //リバサ必殺技だと思う
		
		BMvTbl.SetPP( def_PP_ReversalLeftTime, 0 ); // リバーサル表示はもう出さない
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_Reversal ); // リバサ状態のMvなのを記憶
		
		return 1;
	}
	return 0;
}


//よくやるJumpFrameIDをまとめる
//設定FrameID, 上書きPattern, 失敗時FinalizeCode
Battle_Std.JumpFrameIDEX <- function( _frameID, _pat=-1, _code=-1 )
{
	if( _pat!=-1 )
	{
		Battle_Std.SetPattern_NotEqual(_pat); //パターンが違っていたら変える
	}
	if( BMvTbl.JumpFrameID(_frameID)==-1 ) //飛び先FrameIDが無かったらもうFinalizeしちゃう
	{
		if( _code!=-1 )
		{
			BMvTbl.SetFinalize(_code);
			//_dm("FrameIDが無いんだけど…");
		}
	}
}

//パターンセット（既に同じパターンだったらやらないおまじない的なもの）
Battle_Std.SetPattern_NotEqual <- function(_pat)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.DataPattern!=_pat )
	{
		//_dm("PATが違うようだ"+_pat+" 今:"+mvs.DataPattern);
		BMvTbl.SetPattern(_pat); //違うのでパターンセット
		return 1;
	}
	//_dm("ＯＫ牧場");
	return 0; //同じなので特に変更しない
}

//調整用のデバッグメッセージ
Battle_Std.DrawDebugAttackInfo <- function(str)
{
	//return; //見られるとアレなので
	if( Def_Dbg_LocalAnnounce )
	{
		BMvEff.AttackInfoString_Set({ word=str,} );		
	}
}

Battle_Std.Create_TechDelayCheckObject <- function( delay=0 )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		//ここから相手の投げコマンドチェックオブジェクト生成
		BMvEff.CreateObject( { mvname="Mv_Obj_CheckTechDelay", } ); //
		
		enemy.pop();
	}
}

local array_find = function(array,find)
{
	foreach( index, num in array )
	{
		//Battle_Std.DrawDebugAttackInfo("e "+num);
		if(num == find) return index;
	}
	return -1;
}

//ちょっと適当に分離
local play_se = function( info ) : (array_find)
{
	local targetar = info.selist.common; // 使うSEListの配列

	local enemy = BMvCore.GetEnemyCharaData(); // 敵の情報を得る			
	
	local selected_color = BMvTbl.GetSelectColor();
	if( enemy.push() )
	{
		//_dm("TypeSE_Play 相手がいた")
		local es = BMvTbl.GetMvStatus(); // ステータス取得
		
		enemy.pop();
		
		if(es.CharaNo in info.selist)
		{
			targetar = info.selist[es.CharaNo];
		}
		else if( "common_combo" in info.selist && Battle_Std.CheckEnemyisDamage() )
		{
			targetar = info.selist.common_combo;
		}
	}
	
	if("color" in info)
	{	
		if( array_find(info.color,selected_color)==-1 ) return 0;
	}
	
	
//			local targetar = (es.CharaNo in info.selist)? info.selist[es.CharaNo] : info.selist.common;
//			local targetar = info.selist.common;
	if( targetar.len()==0 ) return 0; //ないじゃん
	
	if( "Param0" in info )
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		//print("\n "+s.Param0);
		if( !s.isFrameUpdate ) return 0; //最初の１Ｆだけだよ
		if( s.Param0 != info.Param0 ) return 0; //ないじゃん
	}

	if( "LastSE" in info )
	{
		if( Def_DbgMes_PlaySE )
		{
			// _dm("Lastチェック：info:"+info.LastSE+" PP:"+BMvTbl.GetPP(def_PP_LastPlaySound));
		}
		if( info.LastSE != BMvTbl.GetPP(def_PP_LastPlaySound) ) return 0; //最後に再生したのじゃなかった
	}	
	
	//再生するファイルが確定
	local num = targetar[BMvEff.Random_Limit(targetar.len())] //抽選	
	
	if( !( Battle_Std.PlayerisKO() && ((("dying" in info)? info.dying : 0 )==0) ) )
	{
		// 「KO状態かつ"dying"が無い」ではない時の処理（再生する条件）
		if( BMvEff.Random_Limit(100) < (("average" in info)? info.average : 100) )
		{
			if( num in info )
			{
				//再生個別チェック
				if( "checkfunc" in info[num] )
				{
					if( info[num].checkfunc()!=1 ) return 0;
				}

				//再生が確定
				if( "delayframe" in info[num] )
				{
					//ディレイ再生が登録されていた
					//_dm("ディレイ再生！");
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_DelayPlaySE" } );
					if( eff.push() )
					{
						BMvTbl.SetLP(0,info[num].delayframe);
						BMvTbl.SetLP(1,num);						
						
						eff.pop();
					}
					return 1;
				}
				else if( "delayParam0" in info[num] )
				{
					//ディレイParam0再生が登録されていた
					//_dm("ディレイParam0再生！");
					local eff = BMvEff.CreateObject( { mvname="Mv_Obj_DelayParam0PlaySE" } );
					if( eff.push() )
					{
						BMvTbl.SetLP(0,info[num].delayParam0);
						BMvTbl.SetLP(1,num);						
						
						eff.pop();
					}
					return 1;
				}
			}
			if( Def_DbgMes_PlaySE )
			{
				local name = Battle_Std.GetPlayerMvName();
				_vdm(format("PlaySE [%3d] -- %s",num,name));
			}
			Battle_Std.PlayerSE_Play( num ); //_SeType_Playerのnumを再生して記憶
			return 1;
		}
	}
	return 0;
}

//キャラクターＳＥの再生と記憶
Battle_Std.PlayerSE_Play <- function( num=0 )
{
	BSound.SE_Play( { type=_SeType_Player, num=num } );
	BMvTbl.SetPP(def_PP_LastPlaySound, num); //最後に再生したのを記憶
}

//直前に再生したＳＥを停止する
Battle_Std.PlayerSE_StopLastPlaySound <- function( _checkMyKo = 0 )
{
	// KOした後はこの処理を行わない
	// ヒルダの文鎮KOみたいな、KO後に投げ判定があたると音声がとまってしまうので
	if( _checkMyKo )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		if( rs.isMyKo ) return;
	}
	
	BSound.SE_Stop( { type=_SeType_Player, num=BMvTbl.GetPP(def_PP_LastPlaySound) } );
}

//種類で定義されてるのを再生する
//何か再生した 1
//定義されていないか何かで再生しなかった 0
Battle_Std.TypeSE_Play <- function(tbl) : (play_se)
{	
	if( "type" in tbl )
	{
		//print("\n:"+tbl.type);
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		//print(" CharaNo:"+mvs.CharaNo)
		
		local SeTbl = Battle_Std.SeTable[mvs.CharaNo];
		//print(" SeTbl:"+SeTbl)
		
		if( tbl.type in SeTbl ) //この種類のSeが定義されてた
		{
			//print(" .");
			local info = SeTbl[tbl.type];
			
			if( typeof info=="array")
			{
				for(local i = 0; i < info.len(); i++)	
				{
					local ctbl = info[i];
					play_se( ctbl );
				}
			}
			else
			{
				return play_se( info )
			}
		}
		else
		{
			return 0;
		}
	}
	return 0;
}

//通常投げのコマンドを入れると呼び出される
//必殺技のでかかりを投げ抜けコマンドにするのにも使う
//Battle_Std.CreateTechObject(0);
Battle_Std.CreateTechObject <- function(frame=0,gouin=0)
{
	//コマンドがきたら投げ抜け管理を生成する
	if( BMvTbl.GetPP( def_PP_TechHit_FrameManager ) <=0 )
	{
		//投げ抜け管理を生成
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間セット
		BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_TechHit_FrameManager" } );
		//_dm("生まれる"+frame+" : "+gouin);
	}
	else if( gouin==1)
	{
		BMvTbl.SetPP( def_PP_TechHit_FrameManager, frame ); //投げ抜け時間更新
		//_dm("更新"+frame);
	}
	
	// 投げ抜けを仕込んだMvであることを記憶
	Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_TechOP );
}



//投げ抜けステータステーブルを取得
//投げコマンドを入力するとMv_Obj_TechHit_FrameManagerが生成されフレームを管理する
Battle_Std.GetTechStatus <- function()
{
	local ret = {
		isDone = false, // 投げ抜けを入れていたら有効
		isTechOK = false, //投げ抜け成功フレーム中（投げ抜けできるはず）
		frameType = 0, // 0:先行投げ抜けしてない 1:投げ抜け猶予あり 2:投げ抜け失敗フレーム中　※デバッグ用
	};
	
	local techframe_man = BMvTbl.GetPP( def_PP_TechHit_FrameManager );
	
	// i:0 投げor投げ抜けを入れていないか、入力してから結構時間がたった
	// i:1〜 投げor投げ抜けを入力してから何フレーム経過したか
	
	if( techframe_man == 0 ) // 先行投げ抜けすらしてない
	{
		// _dp("\n 先行投げ抜けすらしてない");
		ret.frameType = 0;
	}
	else if( techframe_man<def_FL_TechSenkou )	// 投げ抜け猶予が残ってる
	{
		// _dp("\n 投げ抜け猶予が残ってる");
		ret.isDone = true;
		ret.isTechOK = true;
		ret.frameType = 1;
	}
	else if( techframe_man<def_FL_TechMiss ) // 投げ抜け失敗フレーム中である
	{
		// _dp("\n 投げ抜け失敗フレーム中である:"+techframe_man);
		ret.isDone = true;
		ret.isTechOK = false;
		ret.frameType = 2;
	}
	
	return ret;
}

//投げ抜け不能フレームまで進める
Battle_Std.SetTechMissStatus <- function()
{
	Battle_Std.CreateTechObject( (def_FL_Tech+1), 1 );
}


//キャラ番号
//敵のキャラクターナンバーを取得
Battle_Std.GetEnemyCharaNo <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.push() )
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		
		enemy.pop();
		return mvs.CharaNo;
	}
	return -1; //取得できなかったら
}

//自分と相手のキャラクターナンバーを取得
Battle_Std.GetEachCharaNo <- function()
{
	local ret = { player=0, enemy=0 };
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		ret.player = BMvTbl.GetMvStatus().CharaNo;
		player.pop();
	}
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret.enemy = BMvTbl.GetMvStatus().CharaNo;
		enemy.pop();
	}
	return ret;
}

//操作親と敵のキャラナンバーが同じか(true/false)
Battle_Std.IsDouakyara <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報

	if( player.IsDone && enemy.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local p_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //			

		BMvCore.PushCharaData( enemy ); //
			local e_s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //	
		
		return (p_s.CharaNo==e_s.CharaNo)
	}
	return false; //取得できなかったら違う扱い
}

//プレイヤーがＫＯ状態で寝ているか(true/false)
Battle_Std.PlayerisKO <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		BMvCore.PopCharaData(); //			
		
		if (rs.isMyKo)
		{
			//print("\n自分死んでるわ");
			return true;
		}
	}
	return false; //取得できなかったら生きてることにするｗ
}

//敵がＫＯ状態で寝ているか(true/false)
Battle_Std.EnemyisKO <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // プレイヤーの情報を得る
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //
			local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得		
		BMvCore.PopCharaData(); //			
		
		if (rs.isMyKo)
		{
			//print("\n相手死んでるわ");
			return true;
		}
	}
	return false;
}

//操作親と敵のどっちかKO済みか(true/false)
Battle_Std.CharaisKO <- function()
{
	if(Battle_Std.PlayerisKO() || Battle_Std.EnemyisKO() )
	{
		return true;
	}
	return false;	
}


// ＫＯ済みorタイムアップとかで決着がついて操作不能になった
Battle_Std.RoundisEnd <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local rs = BMvTbl.GetMvRoundStatus(); //ラウンドステータス取得
		
		player.pop();
		
		if( rs.isKo ) return true;
	}
	return false;
}




//操作親がつかまれてるか(true/false)
Battle_Std.PlayerisCapture <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.IsDone )
	{
		BMvCore.PushCharaData( player ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //				
		
		return( bs.isCapture!=0 );
	}
	return false;
}

//攻撃が触れたときの共通関数
Battle_Std.AttackImpact_StdFunc <- function(info)
{

	// info は BMvTbl::MvHitImpactInfo クラス
	//print( format( "\nAttackImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );

	//リベレート中だったらGRDが増加する
	if( Def_Sys_VeilOff_GRDPlus )
	{
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local ls = BMvEff.Liberate_Get();
			
			player.pop();

			//ダメージ時のみGRDをもりもり増やす
			if( info.type&_HitType_Damage  )
			{
				switch( ls )
				{
				case _SpGaugeMode_Liberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_Liberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				case _SpGaugeMode_OverLiberate:
					Battle_Std.GRD_AddValue({ val=def_GRD_OverLiberate_AttackImpactInit, pressure=0, boundplus=1 });		
					break;
				}
			}
		}
	}
	
	Battle_Std.EnemyDamageFlag_Del( def_DF_MarkingBound );//触れるたびに相手の印を消す
	
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local Yarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard);
	
	//Battle_Std.DrawDebugAttackInfo("t "+info.type+" f "+info.flags ); 

	local Syodan = (!Yarare);
	local Nage = (info.atk_throw!=0); //投げ判定かどうか
	local GRDBreak = ( ( Syodan || Nage ) && info.grd_break!=0); //攻撃を受けるか食らうかしてブレークになった	
	//local GRDBreak = (info.grd_break!=0); //攻撃を与えてブレイクさせた
	
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
	
	local isVorpal = ( BMvEff.GRD_GetJudgeResult() > 0 );
	
	// _dp("\n Syodan:"+Syodan+" Nage:"+Nage+" info.dmg:"+(info.type & _HitType_Damage) )
	
	// ファーストアタック処理
	if( info.flags&_ImpactFlag_IsFirstAttack )
	{
		// ファーストアタックのボイス再生
		// BSound.SE_Play( { type=_SeType_Normal, num=134 } );
		
		// アナウンス表示
		BMvEff.AttackInfoString_Set({ word=def_AISW_FirstAttack,} );
	}

	if( Syodan )
	{
		//ガード時も入ってくるので注意
		
		if( isVorpal && info.type & _HitType_Damage )
		{
			_dpn("★★VPでコンボ始動★★")
			Battle_Std.EnemyDamageFlag_DelayAdd( def_DF_Vorpaled );
		}
		// アサルト攻撃はヒット時の補正を色々つける
		// 処理を相手側に移動（何が殴ったかの取得がいい加減だったから、でもこっちでもいいんじゃ…）
		/*
		if( (airatk_st&def_PP_AAS_inAssault) ) // アサルトから出したジャンプ攻撃…を経由した何かなら通る
		{
			if( GRDBreak ) // ブレイクさせた攻撃
			{
				// 無補正
			}
			else if( info.counterhit ) // カウンターヒットした攻撃
			{
				// 無補正
			}
			else // それ以外
			{
				// _dp("\n アサルトによる補正");
				Battle_Std.ComboPoint_Multi( def_CPH_AssaultHit ); // コンボポイントを乗算
				BMvEff.ComboView_Set( { val=def_HOSEI_AssaultHit, type=1 } ); // 補正を乗算
			}
		}
		*/
		// カウンターヒットしたら
		if( info.counterhit )
		{
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CounterHit ); // カウンターヒット記録
			
			local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
			if( lowbreak )
			{
				Battle_Std.ComboPoint_Multi( def_CPH_LowCounterHit ); // コンボポイントを乗算
			}
			else
			{
				Battle_Std.ComboPoint_Multi( def_CPH_CounterHit ); // コンボポイントを乗算
			}
			
			// _dp("\n カウンターヒット回数加算");
			// tDDC.Jem_AddCount( _JemCheckType_Ex + 4 ); // カウンターヒット回数加算
			
			/*
			if( !Nage )
			{
				BMvEff.Slowmotion_Set( { time=10, power=6666 } );
				local pos = BMvEff.GetAttackHitPos();
				
				local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
				local g_pos = (pos.x - center_pos.x)/8;
		
				BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.050, x=center_pos.x+g_pos, y=pos.y+( (200*128)*1.5 ), time=[5,10,10], type_in=3, type_out=2 } );
				
				BMvTbl.SetCommandLongDelay(1);
			}
			*/
		}
		
		// 投げ判定ではない打撃判定が、つかみ中の相手にヒットした場合は始動ではない
		// つかみ中の相手＝すでにつかみで始動になっているはずなので…

		// 投げヒット後の打撃判定かどうか
		local nageHitDageki = ( !Nage && Battle_Std.CheckEnemyisCapture() );
		if( info.type & _HitType_Damage && !nageHitDageki )
		{
			_dp("\n 始動でヒットした");
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
			
			local enemy_is_in_active = Battle_Std.EnemyGS_CheckFlag( def_PP_GS_KeepInActive );
			if( enemy_is_in_active )
			{
				// _dpn("相手、硬直中");
				Battle_Std.SetSpecialEXSLimit_Enemy( def_SP_CSCheat_EXSLimitVal );
			}
			
			// 孫まで見る（無限は怖いので、かつ軽くしたいので適当でいいよ）
			local oya = BMvCore.GetParentCharaData();
			if( oya.isdone() )
			{
				_dp("\n 親がいるので飛び道具とかのヒット");
				
				if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player  } ) != 0 )
				{
					local player = BMvCore.GetPlayerCharaData();
					if( player.push() )
					{
						_dp("\n プレイヤーが自分自身発生させた行動中");
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						
						player.pop();
					}
				}
				else if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
				{
					if( oya.push() )
					{
						Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
						
						if( !oya.isPlayer() )
						{
							local sofubo = BMvCore.GetParentCharaData();
							if( sofubo.isdone() )
							{
								_dp("\n さらに親がいるので飛び道具とかのヒット");
								
								if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
								{
									if( sofubo.push() )
									{
										Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_SidouHitSkill ); // 始動であてた技フラグをたてる
										
										sofubo.pop();
									}
								}
							}
						}
						oya.pop();
					}
				}
			}
		}
	}
	else
	{
		if( 0 ) // 処理テスト
		{
			if( Battle_Std.EnemyDamageFlag_Check( def_DF_CSAntenGaesied ) )
			{
				Battle_Std.EnemyDamageFlag_Del( def_DF_CSAntenGaesied );
				
				local pos = BMvEff.GetAttackHitPos(); //敵のヒットエフェクト座標を取得
				local kari_posy = -200*128; //Y座標がうまくとれてなさそうな時に使うもの
				
				//投げの時は座標が足元になっているかもしれないので重なり判定の真ん中あたりに変える
				//取得できなかったら適当にそれっぽい座標に出す
				if( info.atk_throw !=0 )
				{
					local p = BMvCore.GetCaptureCharaData();
					if( p.push() )
					{
						local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=0  } );
						if( rc.sx != _Hantei_Error ) // 存在するか
						{
							pos.y = (rc.sy + rc.ey)/2; //真ん中にかえる
						}
						else
						{
							pos.y = kari_posy;
						}
						
						p.pop();
					}
					else
					{
						pos.y = kari_posy;
					}
				}
				
				local eff = BMvEff.CreateObject( { datatype=1, start_pat=41 } );
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
					BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
					
					eff.pop();
				}
				// _dp("\n これ？");
			}
		}
	}
	
	
	if( GRDBreak )
	{
		// GRDブレイク始動はフェイタル
		Battle_Std.ComboPoint_Multi( def_CPH_BreakHit ); // コンボポイントを乗算
		
		if( Nage )
		{
			if( Battle_Std.MoveCode.CheckFlag( def_MC_GRDBreak_FatalDmgHosei ) )
			{
				// 通常投げでブレイクしたらダメージ補正がゆるくなる
				BMvEff.ComboView_Set( { val=def_HOSEI_BreakFatalThrow, type=1 } ); // 乗算120%
				// _dp("\nダメージ補正回復");
			}
		}
		
		//Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク成功" });
		
		//ブレイクしたのでガラスを飛び散らせる
		local pos = BMvEff.GetAttackHitPos(); //敵のヒットエフェクト座標を取得
		local kari_posy = -200*128; //Y座標がうまくとれてなさそうな時に使うもの
		
		//投げの時は座標が足元になっているかもしれないので重なり判定の真ん中あたりに変える
		//取得できなかったら適当にそれっぽい座標に出す
		if( info.atk_throw !=0 )
		{
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p );
					local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=0  } );
					if( rc.sx != _Hantei_Error ) // 存在するか
					{
						pos.y = (rc.sy + rc.ey)/2; //真ん中にかえる
					}
					else
					{
						pos.y = kari_posy;
					}
				BMvCore.PopCharaData();		
			}
			else
			{
				pos.y = kari_posy;
			}					
		}
		
		//print("座標:x"+pos.x+" y:"+pos.y);
		//シールドエフェクトの残りかす
		local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=327, flags=0 } );
		if( e.IsDone )
		{
			BMvCore.PushCharaData( e );
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
			BMvCore.PopCharaData();		
		}

		//散らせる
		local pow = 1.5;
		for(local i=0; i<10; i++)
		{
			local e = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=326, flags=0 } );
			if( e.IsDone )
			{
				BMvCore.PushCharaData( e );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_MoveTimeStopAll } );
					BMvEff.SetExist( { level = _Exist_NoHantei } );
					
					local e_grp_FrameID = 10+BMvEff.Random_Limit(3)*10; // 10 20 30...
					local e_pos = BMvEff.Random_PointRad( { radx=128, rady=128 } );
					BMvTbl.SetPosition( { x=pos.x+e_pos.x, y=pos.y+e_pos.y } );
					//BMvTbl.SetMuki( _Direction_Reverse );
					
					local frame = 14+BMvEff.Random_Limit(10);
					local e_ang = 0.125+(BMvEff.Random_F()*0.7);
					local e_spd = (2000+BMvEff.Random_Limit(700))*pow;//-sa*6000;
					local v = BMvEff.GetVector_FromAngle( { angle = e_ang, speed = e_spd } );
					BMvTbl.SetAngle( {angle_float=e_ang} );
					BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/frame, addy=-v.y/frame, flags=_Vector_Div } );
					BMvTbl.JumpFrameID(e_grp_FrameID);
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
					//if( BMvEff.Random_Limit(2)==0 ) BMvTbl.SetMuki( _Direction_Reverse );
				BMvCore.PopCharaData();
			}
		}			

	}	
	
}

//攻撃に触れられたときの共通関数
Battle_Std.DamageImpact_StdFunc <- function(info)
{
	/*
	(1<<0) 1 立ちガード可能 
	(1<<1) 2 空中ガード可能　※しゃがみガード可能になってたけど逆だったｗ
	(1<<2) 4 しゃがみガード可能
	(1<<8) 256 立ちに空振り
	(1<<9) 512 空中に空振り
	(1<<10) 1024 しゃがみに空振り
	(1<<11) 2048 のけぞりに空振り
	(1<<12) 4096 ガードのけぞりに空振り

	*/
	
	//当たった攻撃のガード属性
	local StdGuard = ((info.atk_guard&(1<<0))!=0);
	local AirGuard = ((info.atk_guard&(1<<1))!=0);
	local CroGuard = ((info.atk_guard&(1<<2))!=0);

	local Zyodan = (StdGuard&&CroGuard);
	local Tyudan = (StdGuard&&!CroGuard);
	local Gedan = (!StdGuard&&CroGuard);
	local KugaFunou = (!AirGuard);
	local GroundGuardFunou = (!StdGuard && !CroGuard); // 地上ガード不能
	
	//やられ側状態
	local PosisCro = (info.d_state==2);
	local PosisAir = (info.d_state==1);
	local PosisStd = (!PosisCro&&!PosisAir);
	
	local StdGuardInput = (info.def_guard==1);//トレモだと機能しない
	local CroGuardInput = (info.def_guard==2);//トレモだと機能しない
	local AirGuardInput = (info.def_guard==3);//トレモだと機能しない
	local GroGuardInput = ( StdGuardInput || CroGuardInput );
	
	local GuardOK = ( StdGuard || AirGuard || CroGuard );
	
	local Nage = (info.atk_throw!=0); //投げ判定かどうか
	
	local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
	local Yarare = (((info.flags&_ImpactFlag_IsBound_Old)!=0)&&!Guard); // XXX:古い処理なので直すこと
	local Capture = (((info.flags&_ImpactFlag_IsCapture)!=0 ) && !Guard );

	local Syodan = (!Yarare); // 打撃＋投げ
	local Nage_Shodan = (!Capture &&Nage); // 投げのみ ※投げ初段で処理をすると、通常投げの投げ抜け待機とかも反応するよ

	local Zenbu_Shodan = (Syodan || Nage_Shodan); // 打撃でも投げでも
	
	local SyodanGuard = (!Guard);

	local GRDBreak = ( ( Syodan || Nage ) && info.grd_break!=0); //攻撃を受けるか食らうかしてブレークになった
	
	//_dp("\n info.flags:"+info.flags+" _ImpactFlag_IsCapture:"+_ImpactFlag_IsCapture+" _ImpactFlag_IsBound_Old:"+_ImpactFlag_IsBound_Old );
	// _dp("\n Syodan:"+Syodan+" Nage_Shodan:"+Nage_Shodan+" Zenbu_Shodan:"+Zenbu_Shodan+" Capture:"+Capture+" Nage:"+Nage );

	local pos;
	local vec;
	
	local movable = BCMDTbl.CheckCancel( _SkillType_None );

	local enemyAtk_is_FastRocketeer = false; //早い発生のジャンプ攻撃によるロケッティアであるかどうか

	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報

	if( enemy.IsDone )
	{
		if( BMvCore.PushCharaData( enemy ) )
		{
			local s = BMvTbl.GetMvStatus(); //MvCount取得用
			pos = BMvTbl.GetPosition(); // 位置取得
			vec = BMvTbl.GetVector(); //ベクトル取得
			local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
			//アサルトからは除外
			enemyAtk_is_FastRocketeer = ( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && s.MvCount<21 );
			//print("\n enemyAtk_is_rocketeer:"+enemyAtk_is_rocketeer);
		}
		BMvCore.PopCharaData();
	}
	else
	{
		pos = BMvTbl.CCharaPosition();
		vec = BMvTbl.CCharaVector();
	}
	
	//ガードができる状況か
	//行動可能orガード中？
	local GuardInputAble = (Guard || BCMDTbl.CheckCancel(_SkillType_None) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中or発生早いロケッティアなら(Ver.1.03予定だったもの)
	//local NoboriTyudan = ( Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && ( vec.y<0 || enemyAtk_is_FastRocketeer ) );
	
	//地上状態で　相手が初段での中段攻撃で空中にいて上昇中なら(Ver.1.01、1.02)
	local NoboriTyudan = ( Syodan&& BCMDTbl.CheckPosState( _PosState_Ground ) && Tyudan && pos.y<0 && vec.y<0 );

	//のぼり中段初段をしゃがみガードしていた（食らった）
	local NoboriTyudanHit = ( CroGuardInput && NoboriTyudan );
	
	//切り替え中段（Ｆ式）ガードモーション中しゃがみガード入力中に上り中段がきたら
	//local Fsiki = ( NoboriTyudan && Guard && BCMDTbl.CheckPosState(_PosState_Crouch) ); //
		
	//_dm("Flags:"+info.flags+" "+_ImpactFlag_IsBound+" "+_ImpactFlag_IsGuard+" Yarare:"+Yarare+" Guard:"+Guard );

	if( info.type&_HitType_Guard )
	{	
		local add_breaktime = def_CBT_Guard;
		
		if( Tyudan && PosisStd ) //中段をガードした
		{
			//_dm("中段ガードおめでとう");
			Battle_Std.TypeSE_Play({ type="中段ガード成功" });
			local grd_addval = 0;

			if( NoboriTyudan )
			{
				//相手に色々メリットを与えてもいい気がする
				//初段チェックはしない（切り替え中段だと初段にならないので）
				// Battle_Std.DrawDebugAttackInfo("! NoboriTyudan Guard");
				grd_addval = def_GRD_NiceGuard_NoboriTyudan;
				add_breaktime = def_CBT_NoboriTyudanGuard;				
			}
			else
			{
				// Battle_Std.DrawDebugAttackInfo("! Tyudan Guard");
				if( SyodanGuard )
				{
					grd_addval = def_GRD_NiceGuard_TyudanSyodan;
					add_breaktime = def_CBT_TyudanGuardSyodan;
				}
				else
				{
					grd_addval = def_GRD_NiceGuard_Tyudan;
					add_breaktime = def_CBT_TyudanGuard;
				}
			}
			
			//GRD増加処理
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });
			}
		}
		if( Gedan && PosisCro ) //下段をガードした
		{
			//_dm("下段ガードおめでとう");
			local grd_addval = 0;
			if( SyodanGuard ) //初段のとき
			{
				//print("\n初段")
				grd_addval = def_GRD_NiceGuard_GedanSyodan;
				add_breaktime = def_CBT_GedanGuardSyodan;
			}
			else
			{
				grd_addval = def_GRD_NiceGuard_Gedan;
				add_breaktime = def_CBT_GedanGuard;
			}
			
			if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
			{
				Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });			
			}
		}
		
		//キャンセル色々できる必殺技をガードしたらさらにボーナスがある
		local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上の親）
		// 1を使えるようにするためには、攻撃系のオブジェクトに関しては親の引き継ぎを一切しないようにする必要がある？
		//（1で取得後、isPlayerなら親、そうじゃなけりゃ親あらずになる…？）
		
		if( atk_enemy.push() )
		{
			local mva = BMvTbl.GetMvAction();
			local isSkill = (mva == def_MVA_Skill);// EX・SPはゲージ使ってるし除外 || mva == def_MVA_EXSkill || mva == def_MVA_SPSkill );
			local isCanselToAnyMove = 0;//なんかにキャンセルできる行動か（EXキャンセル除く）
			local isAlreadyChanged = 0; // 既に別の行動に移っているオブジェクトの攻撃
			
			local targetCoreIsPlayer = 0;
			if( atk_enemy.isPlayer() || BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
			{
				targetCoreIsPlayer = 1;
			}
			else
			{
				if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )//孫処理
				{
					local oya = BMvCore.GetParentCharaData();
					if( oya.push() )
					{
						if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )//孫
						{
							local oya2 = BMvCore.GetParentCharaData();
							if( oya2.push() )
							{
								if( oya2.isPlayer() ) targetCoreIsPlayer = 1;
								
								oya2.pop();
							}
						}
						oya.pop();
					}
				}
				if( !targetCoreIsPlayer )
				{
					//プレイヤーじゃなくてオブジェクト側につくのでちょっと処理が違う
					if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_AnyCancelGRD ) )
					{
						//まだGRD増加処理をやっていないっぽい
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AnyCancelGRD );//増加済みフラグをたてる
						
						isAlreadyChanged = 1; //既に違う行動っぽい
						isCanselToAnyMove = 100; // 適当に
					}
				}
			}
			
			// _dpn("要チェック:"+atk_enemy.isPlayer()+" targetCoreIsPlayer:"+targetCoreIsPlayer );
			if( targetCoreIsPlayer )
			{
				// 親が自分自身発生させた行動中。
				local player = BMvCore.GetPlayerCharaData();
				if( player.push() )
				{
					if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_AnyCancelGRD ) )
					{
						//まだGRD増加処理をやっていないっぽい
						Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AnyCancelGRD );//増加済みフラグをたてる
						
						if( Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoSkill|def_MC_EnableCansel_SkilltoAtk ) )
						{
							isCanselToAnyMove = 150;
						}
						else if( Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_EnableCansel_JumpMoveable ) )
						{
							isCanselToAnyMove = 150;
						}
						else if( Battle_Std.MoveCodeEx.CheckFlag( 6, def_MC6_EnableCansel_AddCommand ) )
						{
							isCanselToAnyMove = 100;
						}
						//Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
					}
					player.pop();
				}
			}
			
			atk_enemy.pop();
			
			if( isSkill && isCanselToAnyMove )
			{
				local grd_addval = 0;
				if( SyodanGuard ) //初段のとき
				{
					//print("\n初段")
					grd_addval = def_GRD_NiceGuard_AnyCancelSyodan * isCanselToAnyMove/100;
					add_breaktime = def_CBT_AnyCancelSyodan * isCanselToAnyMove/100;
				}
				else if ( isAlreadyChanged )
				{
					//行動が変わっている系のやつだと何度も処理をしてしまうので初段以外は処理をしない
					//ヒルダ214など
				}
				else
				{
					grd_addval = def_GRD_NiceGuard_AnyCancel * isCanselToAnyMove/100;
					add_breaktime = def_CBT_AnyCancel * isCanselToAnyMove/100;
				}
				
				// _dpn("isSkill:"+isSkill+" isCanselToAnyMove:"+isCanselToAnyMove );
				if( grd_addval )
				{
					_dpn("★★★  isCanselToAnyMove:"+isCanselToAnyMove+" isAlreadyChanged:"+isAlreadyChanged );
				}
				
				if( BMvEff.GRD_GetJudgeResult()<=0 ) //ヴォーパル状態ではボーナス無し
				{
					Battle_Std.GRD_AddValue({ val=grd_addval, pressure=0, boundplus=1 });			
				}
			}
		}
		
		if( BMvEff.GRD_GetBreak( 0 )!=0 ) //ブレイク時
		{
			BMvEff.GRD_CorrectBreakTime( 0, add_breaktime ); //割合減少
		}
		
		//Battle_Std.TypeSE_Play({ type="ガード" });		
	}
	else if( info.type&_HitType_Damage )
	{
		//つかまれ時は入ってこない　→　入ってくる！
		//投げ成立の時点でやられ状態になるのでSyodanにはならない
		//Nage_Shodanで検知できるが、通常投げの投げ抜け待機時も入るのであえて処理はしないでおく
		
		//ダメージを受けたらブレイク時間を割合で減算(廃止)
		
		if( Syodan ) //初段のみ判断
		{
			// _dp("\n 初段");
			Battle_Std.PlayerSE_StopLastPlaySound( 0 ); //直前に再生した音声を停止
			
			//やられ初段によるＧＲＤ減少
			Battle_Std.GRD_AddValue({ val=def_GRD_DamageSyodan, pressure=0, boundplus=1 });
			
			if( Tyudan && CroGuardInput && GuardInputAble ) //中段を食らった
			{
				//屈状態だったら警告(ガードを入れてるかの方がいいかも)
				//初段かどうか取得？しないとコンボ中がギャグ
				//_dm("それ屈ガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Tyudan");
				
				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
			else if( Gedan && StdGuardInput && GuardInputAble ) //下段を食らった
			{
				//立状態だったら警告
				//_dm("それ立ちガードできませんから");
				// Battle_Std.DrawDebugAttackInfo("! Gedan");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
			else if( KugaFunou && AirGuardInput && GuardInputAble ) //空ガ不能を食らった
			{
				//空中で空中ガード不能技を食らった
				//_dm("それ空中ガードできませんから");
				//Battle_Std.DrawDebugAttackInfo("! KugaFunou");

				Battle_Std.TypeSE_Play({ type="ガード失敗" });
				Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoiceOnce ); // 次のやられ音声を再生しない
			}
		}
		//高速中段用補正
		//・しゃがみガード入力中だった
		//・中段を食らった
		//・相手は空中状態だ
		//・相手に↑ベクトルがかかってる or ロケッティアフラグがある
		//×相手の座標が一定以下（これはいらない）
		//・初段だ
		
		// 殴ってきた相手の技を見て色々補正をかける
		// Syodanは投げの初段は入ってこないよ
		if( Syodan )
		{
			local isStand = BCMDTbl.CheckPosState( _PosState_Stand );
			local isCrouch = BCMDTbl.CheckPosState( _PosState_Crouch );
			local isGuard = Battle_Std.CheckPlayerisGuard();

			local type_NoboriTyudan = (isCrouch); // しゃがみ
			local type_FsikiTyudan = (isStand && isGuard); // 立ちガード硬直中
			
			local atk_enemy = BMvCore.GetLastDamageCharaData( 0 ); // そのままを取得（1だと一番上のの親）
			if( atk_enemy.push() )
			{
				// 通常攻撃かどうか取得
				local normal_atk = Battle_Std.MoveCode.CheckFlag( def_MC_Atk );
				local exdmg_hosei =  Battle_Std.MoveCode.CheckFlag( def_MC_ExDamageHosei );
				local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
				local enable_airatkst = Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ); // def_PP_AirAtkStatusが有効なMvかチェック
				local fromAssault = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_FromAssault );
				
				//カウンターヒット時は無補正
				//exdmg_hoseiの処理が変わるので共通でOK
				if( exdmg_hosei )
				{
					// 特殊な補正がかかるMvによる攻撃でした
					_dp("\n 多段中段補正適用:"+def_HOSEI_ExDamageHosei);
					BMvEff.StdCall( { type=6, no=112, param=[ def_HOSEI_ExDamageHosei,0,0,0,0, 0,0,0,0,0, 0,0 ]} );
				}
				else if( normal_atk && enable_airatkst && (airatk_st&def_PP_AAS_inAssault) ) // airatk_stはアサルトから出したジャンプ攻撃で。フラグはジャンプ攻撃（！）の着地で消える。
				{
					_dp("\n アサルト補正適用");
					if( GRDBreak ) // ブレイクさせた攻撃
					{
						// 無補正
					}
					else if( info.counterhit ) // カウンターヒットした攻撃
					{
						// 無補正
					}
					else // それ以外
					{
						// _dp("\n アサルト補正適用");
						Battle_Std.ComboPoint_Multi( def_CPH_AssaultHit ); // コンボポイントを乗算
						BMvEff.ComboView_Set( { val=def_HOSEI_AssaultHit, type=1 } ); // 補正を乗算
					}
				}
				
				//発生24F未満のぼり中段やF式に対してのダメージ補正
				/*
				if( Tyudan && atk_enemy.isPlayer() )
				{
					local fastNoboriJumpAtk = 0;
					local noboriAtkF = 0;//デバッグ用
					
					//前の行動がジャンプからなら処理をする
					//アサルトとか二段ジャンプは見ないので、基本的に設置＞のぼりJA対策ではある
					if( normal_atk && Battle_Std.IsMatchChangeMvNameArray( ["Mv_Jump_F", "Mv_Jump_N", "Mv_Jump_B"] ) )
					{
						_dpn("のぼり中段:"+type_NoboriTyudan+", Ｆ式:"+type_FsikiTyudan );
						
						if( type_NoboriTyudan || type_FsikiTyudan )
						{
							local mvs = BMvTbl.GetMvStatus();
							local activeF = mvs.MvCount;//格ゲーの発生F的には+1Fする
							local jumpF = BMvTbl.GetPP(def_PP_JumpFrame);//上記MVからならこの値がセットされている
							
							local limitF = 24;
							noboriAtkF = activeF+jumpF;
							
							if( noboriAtkF < limitF )
							{
								fastNoboriJumpAtk = 1;
							}	
						}
					}
					
					//のぼり中段ならダメージ補正をきつく
					if( fastNoboriJumpAtk )
					{
						_dpn("のぼり中段補正！ 離陸後発生:"+noboriAtkF+"F" );
						BMvEff.ComboView_Set( { val=80, type=1 } );
					}
				}
				*/
		
				atk_enemy.pop();
			}
		}
		
		if( Zenbu_Shodan )
		{
			// こっちはNage_Shodanも含めて補正をかけるが、ボーナスとか入れちゃダメなので注意
			local atk_enemy = BMvCore.GetLastDamageCharaData( 1 ); // そのままを取得（1だと一番上のの親）
			if( atk_enemy.push() )
			{
				
				// 距離補正テスト
				// ある程度距離が遠い状態ではコンボレートに乗算補正がかかる
				if( 1 )
				{
					if( GRDBreak )
					{
					}
					else if( info.counterhit ) // カウンターヒットした攻撃
					{
					}
					else if( movable == 0 ) // 行動不能をつっついた攻撃
					{
						// 通常技の隙や必殺技の隙だけどカウンターではない時
						// バクステの硬直とか
						// アサルトの移動中とか
						// バティスタ関係
					}
					else
					{
						local kyori = Battle_Std.GetEnemyDistance() / 128;
						
						local xmin = 350;
						local xmax = 600; // 800
						local hmin = 100;
						local hmax = 92; // 85
						
						// _dp("\n 距離チェック:"+kyori )
						if( kyori >= xmin )
						{
							local sa = kyori - xmin; // 
							local val = hmin - ( sa * (hmin - hmax) / (xmax - xmin) );
							if( val < hmax ) val = hmax;
							
							// _dp("\n\n ★距離補正:"+val+"% ★\n" );
							// BMvEff.ComboView_Set( { val=val, type=1 } ); // 乗算で補正がかかる
							BMvTbl.SetComboRateValue( val ); // コンボレートに補正をかける
						}
					}
				}			
			
				atk_enemy.pop();
			}
			
			if( GuardInputAble && GuardOK )
			{
				if( !PosisAir )
				{
					if( Tyudan )
					{
						local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
						if(eff.push())
						{
							BMvTbl.SetLP(0,0);
							
							eff.pop();
						}
					}
					else
					if( Gedan )
					{
						local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
						if(eff.push())
						{
							BMvTbl.SetLP(0,1);
							
							eff.pop();
						}
					}
					else 
					{
						local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
						if(eff.push())
						{
							BMvTbl.SetLP(0,2);
							
							eff.pop();
						}
					}
				}
				else
				{
					if( !KugaFunou )
					{
						local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CheckGuardDelay" } );
						if(eff.push())
						{
							BMvTbl.SetLP(0,3);
							
							eff.pop();
						}
					}
				}
			}
		}
		
		//Battle_Std.TypeSE_Play({ type="やられ中" });		
	}
	
	if( GRDBreak ) //１Ｆ内同時ヒットすると何度も入ってくる
	{
		Battle_Std.TypeSE_Play({ type="ＧＲＤブレイク" });
		
		//メッセージの表示
		//BMvEff.AttackInfoString_Set({ word=def_AISW_GRDBreak,} );
		
		//GRDブレイクしたら投げ抜けはできない
		Battle_Std.SetTechMissStatus(); //投げ抜け失敗状態にする
		// Battle_Std.DrawDebugAttackInfo("! GRDBreak NageNuke Miss");
		// _dm("\n Syodan:"+Syodan+" Nage:"+Nage);
		
		// 食らった行動で分岐
		local enemy_LastDmg = BMvCore.GetLastDamageCharaData( 0 );
		if( enemy_LastDmg.push() )
		{
			local lowbreak = Battle_Std.MoveCode.CheckFlag( def_MC_GRDLowBreak );
			enemy_LastDmg.pop();

			local breaktime = def_GRDBF_NormalAtkDmg; // ブレイク時間 デフォは60*10フレーム
			// 攻撃の種類をチェック
			if( Nage )
			{
				// 投げ
				breaktime = def_GRDBF_ThrowAtkDmg; // 15秒
			}
			else if( lowbreak )
			{
				// ブレイク時間の短いMv
				breaktime = def_GRDBF_LowAtkDmg; // 7秒
			}
			// _dp("\n breaktime:"+breaktime);
			BMvEff.GRD_SetBreak( 0, breaktime, breaktime ); // 0:自分 1:相手, ブレイク時間, 再ブレイク時間
			BMvTbl.Achievement_Unlock(7); // 【トロフィー】パリーン！
		}
	}
	
	//カウンター発生
	if( info.counterhit!=0 )
	{
		//print("\n投げ？:"+Nage)
		Battle_Std.SetCharaFlash_Counter(); //カウンターによる発光
		if( Battle_Std.GetPSFlag( def_PP_PS_isThrowMv ) )
		{
			//投げモーション中のカウンターでは投げ抜け可能のままにする
			// _dm("投げモーション中のカウンターでした");
			
		}
		else if( Nage )
		{
			//それ以外ならカウンターしたら投げ抜け不可にする
			Battle_Std.SetTechMissStatus(); //投げ抜け失敗状態にする
			// Battle_Std.DrawDebugAttackInfo("! Counter NageNuke Miss");				
		}
	}
	
	//空中からのやられでは振り向く・捕まれ中だったら空中でも振り向かない
	//local bs = BtlMvStd.GetBoundStatus();
	//local isFirstBoundTbl = (bs.isBound && bs.VecCount==0); //ベクトルテーブルの最初かどうか

	//if( isFirstBoundTbl && !bs.isCapture ) //ベクトルテーブルの最初かつつかまれ中以外なら
	//{
	//	Battle_Std.SetMuki_ReverseEnemy(); //殴られた相手と反対の向きを向く
	//}
	//BoundInitに一任
	
	//print( format( "\nDamageImpact[  type=%d  d_state=%d  atk_guard=%d  ]", info.type, info.d_state, info.atk_guard ) );
	//print("\n中段："+Tyudan+" 下段："+Gedan+" 上段："+Zyodan+" 立："+StdGuard+"　屈："+CroGuard+" 空："+AirGuard+"  "+mask)
}

//殴られた相手と反対の向きを向く
//ベクトルと絵の向きは相手の向き依存であるはず
//XXX:バグなんだけど直せない。サポートキャラに殴られたとき、サポートの透明親はサポートと向きが異なる場合がある
Battle_Std.SetMuki_ReverseEnemy <- function( playertarget=0 /* 殴られた相手の一番親を取得するか */ )
{
	local lastDmObj = BMvCore.GetLastDamageCharaData(0); // 最後にダメージを与えたオブジェクト
	local noFurimuki = 0; // 振り向かないチェック
	if( lastDmObj.push() )
	{
		noFurimuki = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_DamageNoFurimuki );
		lastDmObj.pop();
	}
	if( noFurimuki==1 ) return 0; // 振り向かない時は終わり
	
	//相手の向きを取得
	//※飛び道具に対してやられた時とかもあるのでこうする
	//val	0 そのままの相手を取得 1 殴られた相手の一番親を取得
	local enemy = BMvCore.GetLastDamageCharaData( playertarget ); //自分が最後に「殴られた相手」情報

	//local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //
			local enemy_is_migimuki = (BMvTbl.GetMuki()==1);
		BMvCore.PopCharaData(); //	

		if( enemy_is_migimuki )
		{
			//print("\n相手が→なので←を向く");
			BMvTbl.SetMuki( _Direction_Left );//相手が→なので←を向く
		}
		else
		{
			//print("\n反対");
			BMvTbl.SetMuki( _Direction_Right );
		}
	}
}

//入ってるやられベクトルの向きにあわせて向きを変更する
//※壁バウンドは壁からのやられ扱いなのでこれを入れると逆になる
//多分それ以外は大丈夫だがやや怖め
Battle_Std.SetMuki_BoundVectorMuki <- function()
{
	local bs = BtlMvStd.GetBoundStatus();
	if( bs.isBound )
	{
		if( bs.VecMuki==_Direction_Left  )
		{
			//print("\n _Direction_Left ");
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			//print("\n _Direction_Right ");		
			BMvTbl.SetMuki( _Direction_Left );
		}
	}
}

//受身のキャラクターフラッシュ
//地上受身・空中受身・壁受身とか
Battle_Std.SetCharaFlash_Ukemi <- function()
{
	BMvEff.SetCharaFlash( { color = 0x00AA00, type = 0, time = 10 } ); //受身で光る
}

//コンバート中
Battle_Std.SetCharaFlash_ConvertCharge <- function()
{
	BMvEff.SetCharaFlash( { color = 0x000022, type = 1, time = 4 } ); 
}

//カウンターヒットのキャラクターフラッシュ
Battle_Std.SetCharaFlash_Counter <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 15 } ); //カウンターでちょっと赤く光る
}

//投げ抜け不能つかまれのキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechMiss <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 30 } ); //抜けれないので赤く光るとか
}

//投げ抜け発生時のキャラクターフラッシュ
Battle_Std.SetCharaFlash_TechSuccessInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 20 } ); //抜け側が光る
}

//失敗ガードでバリア入力中だった
Battle_Std.SetCharaFlash_FaultGuardSPInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 20 } ); //ブレイクするので光る
}

//シールドアタック
Battle_Std.SetCharaFlash_ShieldAtkInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFDDDD, type = 0, time = 10 } );
}

//ガードシールド入力
Battle_Std.SetCharaFlash_GuardSPCommand <- function()
{
	BMvEff.SetCharaFlash( { color = 0xAAAAFF, type = 0, time = 10 } ); //ガードシールド入力で光る
}

//ガードキャンセル発動
Battle_Std.SetCharaFlash_GuardCansel <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 10 } ); //ＧＣ入力で光る
}


//ジャッジ勝利orドロー（GRDが光るとき）
Battle_Std.SetCharaFlash_GRDJudgeFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}

//リベレート発動時
Battle_Std.SetCharaFlash_LiberateInit <- function()
{
	BMvEff.SetCharaFlash( { color = 0xFFFFFF, type = 0, time = 30 } );
}

//ポテンシャル発動時
Battle_Std.SetCharaFlash_PotentialFlash <- function()
{
	BMvEff.SetCharaFlash( { color = 0xEEDDFF, type = 0, time = 20 } ); //
}


//残像
//ダッシュ攻撃
Battle_Std.PcAfterImage_DashAtkInit <- function()
{
	BMvEff.PcAfterImage_Set( {  type=0, range=12, delay=4, color=0x8FAAAAFF, blendmode=0 } );
}

//EX必殺技
Battle_Std.PcAfterImage_EXSkillInit <- function()
{
}

//オーラ
//リベレート中
Battle_Std.PcAuraEffect_LiberateInit <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isLiberate);
	BMvEff.PcAuraEffect_Set( { type=1, time=0, power=1.4, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=90 } );	
}

//リベレート中
Battle_Std.PcAuraEffect_OverLiberateInit <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isOverLiberate);
	BMvEff.PcAuraEffect_Set( { type=1, time=0, power=1.4, color=0xAFDD0000, colorB=0x3FDD0000, color_chara=0x001F0505, blendmode=0, delay=90 } );	
}


//ワースカットイン中
Battle_Std.PcAuraEffect_CutinInit <- function()
{
	if( Def_Rule_SPCutinAura ) Battle_Std.SetAuraType(def_PP_AT_isCutin);
	Battle_Std.PcAuraEffect_CommonAuraSet( { type=0, time=60, power=1.0, color=0x55FF00AA, colorB=0x00FF0000, blendmode=0 } );
}

//コンバート中
Battle_Std.PcAuraEffect_ConvertCharge <- function()
{
}


//GRDジャッジで最初に勝利した瞬間、またははりなおしのタイミングで呼ばれる
//連続勝利した時は入ってこない
Battle_Std.GRDJudgeWinEffect_Init <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isGRDJ_Win);

	if( !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )
	{
	
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			if( BMvCore.PushCharaData( p ) )
			{
				//オーラをつける
				BMvEff.PcAuraEffect_Set( { type=0, time=0, power=1.0, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=60, blendmode=0 } );	
			}
			BMvCore.PopCharaData();
		}
	}
}

//GRDジャッジで最初にドローした瞬間、またははりなおしのタイミングで呼ばれる
//連続ドローした時は入ってこない
Battle_Std.GRDJudgeDrawEffect_Init <- function()
{
	Battle_Std.SetAuraType(def_PP_AT_isGRDJ_Draw);

	if( !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( p.IsDone )
		{
			if( BMvCore.PushCharaData( p ) )
			{
				//オーラをつける
				BMvEff.PcAuraEffect_Set( { type=0, time=0, power=1.0, color=0xAA00AAFF, colorB=0x0000AAFF, color_chara=0x00001A2A, delay=60, blendmode=0 } );
			}
			BMvCore.PopCharaData();
		}
	}	
}




//一時的に出すオーラ呼び出しのかませ関数
Battle_Std.PcAuraEffect_CommonAuraSet <- function(flag)
{
	Battle_Std.SetAuraType(def_PP_AT_isEtc);

	BMvEff.PcAuraEffect_Set( flag );
	local eff = BMvEff.CreateObject( { mvname="Mv_Obj_CharaAura", } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flag.time);
		
		eff.pop();
	}
}

//他のオーラ持続フラグを消す
//消されるとオーラ管理さんがでばってきてオーラを再度はってくれる
Battle_Std.PcAuraEffect_CommonAuraEnd <- function()
{
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}

//なんか全部消す
Battle_Std.PcAuraEffect_AllAuraEnd <- function()
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|def_PP_PS_AuraKanriEnd) );
	
	//print("ぜんぶけす");
	Battle_Std.PcAuraEffect_Clear();
	Battle_Std.ClearAuraFlag();
}


//オーラ管理からてきとうなフレーム毎に呼ばれる
Battle_Std.PcAuraEffect_AuraCheck <- function()
{
	//return 0;
	
	//print(".");
	/*
	local str = ""; //デバッグ用フラグ確認
	
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) )? "○" : "×";
	str += ( Battle_Std.GetPSFlag(def_PP_PS_isLiberate) )? "○" : "×";
	_dem("フラグ:"+str);
	*/
	
	Battle_Std.PcAuraEffect_GRDAuraCheck();
	Battle_Std.PcAuraEffect_LiberateAuraCheck();
}


Battle_Std.PcAuraEffect_GRDAuraCheck <- function()
{
	//ステータスを見てオーラを出すか判断
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local judgeresult = BMvEff.GRD_GetJudgeResult();
		BMvCore.PopCharaData();
		
	//	_dem("\nジャッジ:"+judgeresult);
		if( judgeresult==255 && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利でかつフラグが無い
		{	
			Battle_Std.GRDJudgeWinEffect_Init(); //演出開始してくれ
			Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_Win); //もう出したからオーラはり続けないフラグ
		}
		if( judgeresult>0 && judgeresult<255 && !Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) ) //引き分けかつフラグが無い
		{
			Battle_Std.GRDJudgeDrawEffect_Init();
			Battle_Std.SetPSFlag(def_PP_PS_isGRDJ_Draw);
		}
		
		if( judgeresult!=255 && Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Win) ) //勝利じゃないのに勝利フラグが
		{
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
		if( judgeresult<=0 && judgeresult<255 && Battle_Std.GetPSFlag(def_PP_PS_isGRDJ_Draw) ) //ドローじゃないのに引き分けフラグが
		{
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
	}
}

Battle_Std.PcAuraEffect_LiberateAuraCheck <- function()
{
	//ステータスを見てオーラを出すか判断
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local ls = BMvEff.Liberate_Get();
		BMvCore.PopCharaData();	
		
		if( ls==_SpGaugeMode_OverLiberate  && !Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) ) //勝利でかつフラグが無い
		{
			//("おばりべ");
			Battle_Std.PcAuraEffect_OverLiberateInit();
			Battle_Std.SetPSFlag(def_PP_PS_isOverLiberate);
		}
		if( ls==_SpGaugeMode_Liberate && !Battle_Std.GetPSFlag(def_PP_PS_isLiberate) ) //引き分けかつフラグが無い
		{
			//print("りべ");
			Battle_Std.PcAuraEffect_LiberateInit();
			Battle_Std.SetPSFlag(def_PP_PS_isLiberate);
		}

		if( ls==_SpGaugeMode_Normal  && Battle_Std.GetPSFlag(def_PP_PS_isOverLiberate) ) //勝利じゃないのに勝利フラグが
		{
			//print("おばりべおわり");
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
		if( ls==_SpGaugeMode_Normal  && Battle_Std.GetPSFlag(def_PP_PS_isLiberate) ) //ドローじゃないのに引き分けフラグが
		{
			//print("りべおわり");
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			Battle_Std.ClearAuraFlag();	
		}
	}
}

Battle_Std.GetPSFlag <- function(flag)
{
	local ret = ((BMvTbl.GetPP(def_PP_PlayerStatus)&flag)!=0);
	return ret;	
}

Battle_Std.SetPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)|flag) );
}

//リベレートなしオーラフラグたてる（フラグを消す）
Battle_Std.DelPSFlag <- function(flag)
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~flag) );	
}

Battle_Std.GetAuraType <- function()
{
	local ret = BMvTbl.GetPP(def_PP_AuraType);
	return ret;	
}

Battle_Std.SetAuraType <- function(type)
{
	BMvTbl.SetPP(def_PP_AuraType,type);
}


//オーラを消すときのかませ関数
//かならずここを通すこと
Battle_Std.PcAuraEffect_Clear <- function()
{
	BMvEff.PcAuraEffect_Clear();
	Battle_Std.SetAuraType(def_PP_AT_isNone);
}

//持続系オーラフラグを全部おる（フラグを消す）
Battle_Std.ClearAuraFlag <- function()
{
	//print("フラグ折");
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isGRDJ_Win) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isGRDJ_Draw) );	
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isLiberate) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isOverLiberate) );	
}

//リベレートなしオーラフラグたてる（フラグを消す）
Battle_Std.SetLiberateResetAuraFlag <- function()
{
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isLiberate) );
	BMvTbl.SetPP(def_PP_PlayerStatus,( BMvTbl.GetPP(def_PP_PlayerStatus)&~def_PP_PS_isOverLiberate) );	
}

//超技開始処理
//インフィニットワースイグジストヒット時
Battle_Std.InitIWExistSkill <- function()
{
	BMvEff.AddSkillCount( _SkillCount_SpIFWX ); // 履歴カウンタを加算

	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけ消す
		BMvEff.Cockpit_SetView( { mode=0 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	}
	
	BMvTbl.SetGrdLimit( 1 ); // 行動中自分と相手のＧＲＤの増減を止める
	
	//ＢＧＭを処刑ＢＧＭに変更
	//BMvEff.BGM_Set( { num=def_BGM_IWExist } );
	
	//BMvEff.FadeProc_Set({type=0, time=[0,3,10] color=0x000000}); //黒くしてから開始
	BMvEff.FadeProc_Set({type=0, time=[0,5,10] color=0xFFFFFF}); //白くしてから開始
	
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		if( BMvCore.PushCharaData( p ) )
		{
			BMvEff.SetPlayerTimer( {
				muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dage=def_FL_SPCutinStopTime,
				muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dageX=def_FL_SPCutinStopTime } );
			BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止

			//カットインが入るIW技の場合ゲージ増加制限をかける
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
			// BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
			
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
			
			Battle_Std.RecoverDoubleExHohoHosei(); // EX>EXの保証補正低下を少し戻す
		}
		BMvCore.PopCharaData(); //	
	}

//	Battle_Std.SetSkillStopTime(def_FL_SPCutinStopTime); //時間停止

	BMvEff.ThrowChara_SetJoint( 0 );
	
	local pos;
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData(); //	
	}
	
	local escpos;
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			escpos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );
			BMvTbl.SetMuki( _Direction_Auto ); //相手方向を向く
			Battle_Std.InitVector(); //ベクトル初期化			
		BMvCore.PopCharaData();
	}
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			//画面中央にかならず飛んでくる
			local opos = BMvTbl.GetPosition(0);
			
			BMvEff.ResetCamera(); //カメラ初期化
			BMvEff.ResetViewCamera();
			
			BMvTbl.SetPosition( { x=-pos.x, y=0, flags= _Position_ChangeMuki } );
			
			local npos = BMvTbl.GetPosition(0);
			
			BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費			
			//BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="",erasetype=1 }); //カットイングラフィックとか呼び
			//Mv_IWXCutin
			BMvEff.CreateObject( { mvname="Mv_IWXCutin" } ); //カットインＭｖ呼び出し

			BMvEff.CutInProc_Set({ time=[3,2000,10], cutin_mv="", erasetype=1 }); //カットイングラフィックとか呼び
			
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト

			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData(); //	
	}
	
	BMvEff.SetObjectRender( { type=1 } ); //設置物がワープしてしまうので演出中は消す
	
	

	//相手
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			local epos = BMvTbl.GetPosition(0);
			BMvTbl.SetPosition( { x=-escpos.x, y=0, flags= _Position_ChangeMuki } );
			
			Battle_Std.SoundStatus_AddFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しない
			
			Battle_Std.SetPSFlag(def_PP_PS_NoAura); //オーラは張らない			
			Battle_Std.PcAuraEffect_Clear(); //オーラを消す
			//BMvEff.PcAuraEffect_Clear(); //オーラを消す
		BMvCore.PopCharaData();
	}
	
	BMvEff.ThrowChara_SetJoint( 1 );
	
}

//超技終了処理
//基本的にLastUpdateで呼ばれる
Battle_Std.FinalizeIWExistSkill <- function()
{
	// これは念のため表示を上書きする
	BMvEff.Cockpit_SetView( { mode=1 } ); //ゲージ類の表示設定　mode 0:非表示 1:表示
	
	if( BMvTbl.GetPP( def_PP_IWEXS_ChgVO_Hit ) )
	{
		// 即死するＩＷＸの時だけコンボ表示を消す
		BMvEff.ComboView_Clear(); // コンボを切る（コンボ終了状態にする）
	}	

	BMvEff.CutInProc_Erase(); //カットインを消去する
	BMvEff.SetObjectRender( { type=0 } ); //演出中消していたものを復活

	Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
	Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活

	//他に何かある？	
	
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e ); //	
			Battle_Std.SoundStatus_DelFlag( def_PP_SS_NoBoundVoice ); // やられ音声を再生しないを消す

			Battle_Std.DelPSFlag(def_PP_PS_NoAura); //オーラは張らない
			Battle_Std.PcAuraEffect_CommonAuraEnd(); //オーラ復活
		BMvCore.PopCharaData();
	}
}

Battle_Std.IWExistSkill_FinishEffect <- function()
{
	//KOと同じようなゆれとかを呼ぶ
	BMvEff.Slowmotion_Set( { time=120, power=6666 } );
	BMvEff.SetCamera_Quake( { type=2, time=40, } );
}


//超技開始処理
Battle_Std.InitWorthSkill <- function( _spcutinmv = "Mv_CutinGrp" )
{
	BMvEff.AddSkillCount( _SkillCount_SpIFW ); // 履歴カウンタを加算

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();
	
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.SetPlayerTimer( {
				muteki_nage=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dage=def_FL_SPCutinStopTime,
				muteki_nageX=def_FL_SPCutinStopTime+def_FL_WorthSkill_NageMutekiFrame,
				muteki_dageX=def_FL_SPCutinStopTime } );

			BMvEff.SetStopTime( { time=def_FL_SPCutinStopTime } ); //時間停止
			
			BMvEff.CutInProc_Set({ time=[10,999,10], cutin_mv=_spcutinmv,erasetype=1 }); //カットイングラフィックとか呼び

		
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, mvname="", datatype=1, start_pat=43, flags=_Position_ToolShift } );
			BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } ); //カメラ集中テスト


		}
	

		//カットインが入るIW技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_IWSkill } ); //ゲージ増加制限
		// BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_IWSkill } ); //一定時間ゲージ増加に制限をかける
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		Battle_Std.RecoverDoubleExHohoHosei(); // EX>EXの保証補正低下を少し戻す
		
		player.pop();
	}
}

//超技終了処理
//正しく超技が終了した時
Battle_Std.FinalizeWorthSkill <- function()
{
	BMvEff.CutInProc_Erase(); //カットインを消去する
	//他に何かある？	
}

//
// 暗転の見た目だけ処理
Battle_Std.SetEXCutinCameraFocus <- function( stopframe )
{
	local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stopframe-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		// ※カットイン中にカットインでより拡大される
	}
}

Battle_Std.SetEXCutinGrp <- function()
{
	local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	
	//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
	if( rc0.sx != _Hantei_Error ) // 存在するか
	{	
		BMvEff.CutInProc_Set({ time=[3,39,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		
		local eff = BMvEff.CreateObject( { x=rc0.sx, y=rc0.sy, datatype=1, start_pat=270, flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
			
			eff.pop();
		}
	}		
}

Battle_Std.CallAntenStopObject <- function()
{
	//暗転される生成されて、自分が暗転後動けるようになると消えるオブジェクト
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_AntenStopObject" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( {y=1024, flags=_Position_CaptureShift } );
		
			eff.pop();
		}
		enemy.pop();
	}
}

//
Battle_Std.InitEXSkill <- function(type=0,stopframe=def_FL_EXCutinStopTime)
{
	BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算
	
	//Battle_Std.InitWorthSkill();
	//return 0;
	//特殊判定１だったら通常暗転
	//特殊判定２だったら時間停止中に進む暗転
	//特殊判定が無かったら暗転しない（あとで暗転処理呼ぶこと）
	
	//_dm("Battle_Std.InitWorthSkill()");

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local rc1 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 1 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		local rc0 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );	
		
		if( rc1.sx != _Hantei_Error ) // 存在するか
		{	
			type = 1;
		}
		else if( rc0.sx != _Hantei_Error ) // 存在するか
		{
			type = 0;
		}
		else
		{
			type = -1;
		}
		
		if( type != -1 )
		{
			Battle_Std.SetEXCutinCameraFocus( stopframe );
		}

		// MEMO：この処理は↑に入れてもいいんじゃない？
		//カットインが入るEX技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
		// BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
		
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		
		// コンボ中にEX技を組み込んだかどうか取得（初段は無視）
		local comboUsedExSkill = Battle_Std.EnemyDamageFlag_Check( def_DF_UseExSkill );
		_dp("\n 敵のEX使われ:"+comboUsedExSkill );
		if( comboUsedExSkill )
		{
			Battle_Std.SetSpHosyoHosei( { type="EX" } );
		}
		Battle_Std.EnemyDamageFlag_Add( def_DF_UseExSkill ); // コンボ中EX技を使ったのを相手に記憶		
		
		player.pop();
	}

	switch( type )
	{
	case 0: //通常暗転
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();
		// 特に無敵は与えない
		if( Def_Sys_EXCutinNageMuteki )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=Def_Sys_EXCutinNageMuteki, muteki_nageX=Def_Sys_EXCutinNageMuteki } ); // 投げ無敵だけつける
		}
		//BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2, muteki_dageX=2, muteki_nageX=2 } ); //
		BMvEff.SetStopTime( { time=stopframe, stopme=2, bounderase=1 } ); //時間停止
		break;
	case 1: //時間停止中に進む暗転
		Battle_Std.SetSkillStopTime(stopframe,1); //時間停止,1F後に暗転中無敵を付与
		break;
	case -1: // 暗転しないで後から暗転するタイプ
		BMvEff.CreateObject( { mvname="Mv_DelayExCutinObj" } );
		break;
	}

	if( player.push() )
	{
		Battle_Std.SetEXCutinGrp();
		
		player.pop();
	}
}

// ABCDでイグジスト攻撃を出すときの暗転
Battle_Std.Init_ExistAtkSkill <- function(type=0,stopframe=def_FL_EXCutinStopTime)
{
	//BMvEff.AddSkillCount( _SkillCount_SpEx ); // 履歴カウンタを加算…しない　ただの必殺技なので
	
	//特殊判定１だったら通常暗転
	//特殊判定２だったら時間停止中に進む暗転
	
	//_dm("Battle_Std.InitWorthSkill()");

	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//集中先は気持ちプレイヤーに寄せるぐらいの位置にする
		local center_pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera } ); //画面中央の地面
		local posst = BMvEff.GetPointStatus( { position=center_pos } ); // 位置情報取得
		local pos = BMvTbl.GetPosition( 0 ); //呼び出し親の座標
		local target_pos = BMvTbl.CCharaPosition(); //位置情報型の生成
		target_pos.x = pos.x + (posst.pos_x*75/100); //整数化:0.75
		target_pos.y = pos.y + (posst.pos_y*75/100); //整数化:0.75
		
		BMvEff.SetCamera_Focus( { charapos=0, zoom=-0.1, time=[10,stopframe-10,15], type_in=3, type_out=1
		x=target_pos.x, y=target_pos.y } ); //カメラ集中
		// ※カットイン中にカットインでより拡大される

		//カットインが入るEX技の場合ゲージ増加制限をかける
		BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
		BMvEff.SpGauge_SetLimit( { time=def_FL_EXSLimit_EXSkill } ); //一定時間ゲージ増加に制限をかける
		
		player.pop();
	}

	//時間停止中に進む暗転
	Battle_Std.SetSkillStopTime(stopframe,0); //時間停止,1F後に暗転中無敵は付与しない

	if( player.push() )
	{
		BMvEff.SetSpGauge( { mode=_SpGauge_UseBuffer } ); //ＳＰゲージ予約分を消費
		BMvEff.CutInProc_Set({ time=[3,120,10], cutin_mv="Mv_EXCutinGrp",erasetype=2, bgtype=1 }); //カットイングラフィックとか呼び		
		//BMvEff.AttackInfoString_Set({ word=def_AISW_EXSkill,} );
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );		
		if( rc.sx != _Hantei_Error ) // 存在するか
		{	
			local eff = BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=271, flags=_Position_ToolShift } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				
				eff.pop();
			}
		}
		
		player.pop();
	}
	
}

//必殺技用の時間停止
//暗転中に進むタイプ
Battle_Std.SetSkillStopTime <- function(stopframe=def_FL_EXCutinStopTime, set_nextf_muteki=0 )
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		//相手に、暗転後動けるようになると消えるオブジェクトを呼ぶ
		Battle_Std.CallAntenStopObject();	
	
		local muteki_time = stopframe+Def_Sys_EXCutinNageMuteki; // 投げ無敵時間をプラス
		BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_nageX=muteki_time } ); //投げ無敵だけ設定
		//BMvEff.SetPlayerTimer( { muteki_nage=muteki_time, muteki_dage=muteki_time, muteki_time=stopframe, muteki_nageX=muteki_time } ); //暗転バグ回避
		BMvEff.SetStopTime( { time=stopframe, bounderase=1 } ); //時間停止
		
		// 暗転2F〜暗転終了までプレイヤーに打撃無敵を設定するオブジェクトを呼び出す
		if( set_nextf_muteki )
		{
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_SetNextMutekiObject" } );
			if( eff.push() )
			{
				//MEMO:どんなパターンや行動か不明なのでPatやMv変更での消滅はさせていない
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_MoveTimeStopAll } );
				BMvEff.SetExist( { level = _Exist_NoHantei } );
			
				BMvTbl.SetLP(0,stopframe);//暗転時間をオブジェクト側にわたす
				
				eff.pop();
			}
		}
		
		player.pop();
	}
}

// 切り札エフェクトを呼ぶ＋５フレーム後に切り札効果を発動＋消費する
Battle_Std.Init_Kirifuda <- function()
{
}

Battle_Std.Call_KirifudaEffect <- function()
{
}


// 特定フレームで切り札カウントを消費する…タイミング
Battle_Std.UseKirifuda_DelayUpdateTiming <- function()
{
}

local grp_ap = [
	120, //1
	100, //2
	80, //3
	60, //4
	40, //5
	50, //6
	40, //7
	30, //8
	20, //9
	20, //10
	20, //11
	20, //12	
];
	
//GRDの増加値を返す（GRDが多いほど増えにくい感じを出すため）
Battle_Std.GetGRD_AddValue <- function(addgrdval=0) : (grp_ap)
{
	local cost = BMvEff.GRD_CheckStock( { val=-1 } );
	if( cost>11 ) cost = 11; //最大

	local ret = grp_ap[cost]*addgrdval/100; //整数化
	return ret;
}

//GRD増加のかませ関数
//ブレイク中は増やさないとかそういうのを判断
Battle_Std.GRD_AddValue <- function(tbl)
{
	/*
	( return == 0 ) ブレイクしていない
	( return != 0 ) なんらかのブレイク中
	( return == 1 ) ブレイク中
	( return == 255 ) オーバーブレイク中
	*/
	if( !( "val" in tbl ) ) tbl.val <- 0;
	if( !( "target" in tbl ) ) tbl.target <- 0; //自分にする
	/*
	target	0 自分 1 敵
	*/

	local p = ( tbl.target==0 )?  BMvCore.GetPlayerCharaData() : BMvCore.GetNearEnemyCharaData();
	if( p.push() )
	{
		if( BMvEff.GRD_GetBreak(0) == 0 ) // ブレイクしてない
		{
			BMvEff.GRD_AddValue( tbl );
		}
		else // 何らかのブレイク中
		{
			if( tbl.val<0 ) BMvEff.GRD_AddValue( tbl ); //減るのは普通に減る		
		}
		p.pop();
	}
}


Battle_Std.SetSpGauge_BarrierFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

Battle_Std.SetSpGauge_ConvertChargeFU <- function(tbl)
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local r = BMvEff.GRD_GetBreak(0);
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		
		if( s.MvCount<def_FL_Shield_SPCostStartFrame ) return; //まだ減る時ではない
		
		if( !( "value" in tbl) ) tbl.value <- 0;
		
		switch( r )
		{
		case 0: //ブレイクしてない
			break;
		case 1: //ブレイク
			tbl.value = tbl.value * def_SP_Barrier_Frame_BreakVal/100;
			break;
		case 255: //オーバーブレイク
		default: //なんらかのブレイク中
			tbl.value = tbl.value * def_SP_Barrier_Frame_OverBreakVal/100;
			break;
		}
			BMvEff.SetSpGauge( {value=tbl.value,} );

		//BMvEff.SetSpGauge( {value=def_SP_BarrierA_Frame,} ); //バリアによるSPゲージ消費	
	}
}

// プレイヤーがやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
Battle_Std.CheckPlayerisDamage <- function( _TechisDamage = 1 )
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( player.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		player.pop();

		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている

		//のけぞりorつかまれ
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )  return true;
	}
	return false;	
}

//プレイヤーがガード状態かチェック
Battle_Std.CheckPlayerisGuard <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //
		
		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている		
		if( bs.isBound == 2 || (bs.isBound && bs.Name.find("ガード")!=null ) ) return true;
		//isBound == 2 で基本はOKだが、HitInterruptで投げ技をチェックする場合、HitInterruptの時点で掴んでいてisBound==1になっている
	}
	return false;	
}

Battle_Std.CheckEnemyisGuard <- function()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 操作親の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている		
		if( bs.isBound == 2 || (bs.isBound && bs.Name.find("ガード")!=null ) ) return true;
		//isBound == 2 で基本はOKだが、HitInterruptで投げ技をチェックする場合、HitInterruptの時点で掴んでいてisBound==1になっている
	}
	return false;	
}

//プレイヤーが受け身状態かチェック
Battle_Std.CheckPlayerisUkemi <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( p ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}

//相手が受け身状態かチェック
Battle_Std.CheckEnemyisUkemi <- function()
{
	local e = BMvCore.GetNearEnemyCharaData(); // 操作親の情報を得る
	if( e.IsDone )
	{
		local is_ukemi = false;
		if( BMvCore.PushCharaData( e ) )
		{
			is_ukemi = ( Battle_Std.MoveCode.CheckFlag( def_MC_Recovery ) == 1 );
		}
		BMvCore.PopCharaData();
		
		return is_ukemi;
	}
	return 0;
}


//相手がやられかチェック
// _TechisDamage = 1 : 投げ抜け成功時もやられ扱いにして、trueを返すようにする
Battle_Std.CheckEnemyisDamage <- function( _TechisDamage = 1 )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( !_TechisDamage && bs.GetBoundFlag() & (1<<8) ) return false; // 特殊やられ状態なので弾く
		if( bs.isBound == 1 || bs.isCapture != 0 )  return true;	
	}
	return false;
}

Battle_Std.CheckEnemyisDamage_ExceptDown <- function()
{
	return false;
}

//プレイヤーがやられorガード(Bound)かチェック
Battle_Std.CheckPlayerisBound <- function()
{
	local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

//相手がやられorガード(Bound)かチェック
Battle_Std.CheckEnemyisBound <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.IsDone )
	{
		BMvCore.PushCharaData( enemy ); //	
			local bs = BtlMvStd.GetBoundStatus();
		BMvCore.PopCharaData(); //

		if( bs.isDone !=0 ) return true;
	}
	return false;
}

Battle_Std.CheckEnemyisCapture <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		
		enemy.pop();
		
		if( bs.isCapture != 0 )  return true;	
	}
	return false;
}


Battle_Std.CheckPlayerisMovable <- function()
{
	local player = BMvCore.GetPlayerCharaData(); // 敵の情報を得る
	if( player.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		player.pop();
		
		if( movable ) return true;
	}
	return false;
}

//敵が行動可能かどうか（攻撃があるキャラから見ること）
Battle_Std.CheckEnemyisMovable <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		local movable = BCMDTbl.CheckCancel( _SkillType_None );
		
		enemy.pop();
		
		if( movable ) return true;
		
		local mvhs = BMvTbl.MvHitStatus();
		if( mvhs.isMoveable ) return true;
	}
	return false;
}

Battle_Std.CheckEnemyPosState <- function( _pos )
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵の情報を得る
	if( enemy.push() )
	{
		return BCMDTbl.CheckPosState( _pos );
	}
	return 0;
}




//複数の抜け先を一括指定
//デフォルトやること＋配列
Battle_Std.SwitchNextMoveTable <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
	BMvTbl.SetFinalizeCode(0); //終了コードの初期化
}

// ファイナライズコードを初期化しないバージョン
// それ以外はまったく同じ
Battle_Std.SwitchNextMoveTable_NoClearFinCode <- function( def, ... )
{
	//array[0].code = 123
	//array[0].mv = "MvTest"
	//	Battle_Std.SwitchNextMoveTable(
	//"Mv_Modori_Okiagari",[def_FC_RoundLose,"Mv_RoundLose"]

	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < vargc; i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		//_dm("てすと"+typeof vargv[i]) // vargv
		if( typeof vargv[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			BMvTbl.SetNextMoveTable(vargv[i]);
			usedef = false;
		}
		if( typeof vargv[i]=="array")
		{
			if( fc == vargv[i][0] )
			{
				//local end_zanzou = (vargv[i].len()<=2);
				//if( end_zanzou ) BMvEff.PcAfterImage_Clear(); //残像の消去
				if( typeof vargv[i] =="function" )
				{
					vargv[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(vargv[i][1]);
					usedef = false;
				}
			}
		}
	}
	if( usedef )
	{
		if( typeof def =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable(def); //デフォルト抜け先
		}
		if( typeof def =="function" ) 
		{
			def();
		}		
	}
}

//配列のみで渡すバージョン
//[ [defcode,defmv], [code,mv], [code,mv], ... ]
//[ [defmv], [code,mv], [code,mv], ... ]
Battle_Std.SwitchNextMoveTable_Array <- function( ar )
{
	local usedef = true; //デフォルト指定のdefを使うか
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	
	for(local i = 1; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		if( typeof ar[i]=="string")
		{			
			BMvTbl.SetNextMoveTable(ar[i]);
			usedef = false;
		}
		if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					BMvTbl.SetNextMoveTable(ar[i][1]);
					usedef = false;
				}
			}
		}
	}

	if( usedef )
	{
		if( typeof ar[0] =="string" ) 
		{
			//_dm("デフォルト抜け先"+def);
			BMvTbl.SetNextMoveTable( ar[0] ); //デフォルト抜け先
		}
		if( typeof ar[0]=="array")
		{
			BMvTbl.SetNextMoveTable(ar[0][1]);
		}
		if( typeof ar[0] =="function" ) 
		{
			ar[0]();
		}		
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
}

Battle_Std.GetNextMoveTable_Array <- function( ar )
{
	local ret_nextmv = "";
	
	local fc = BMvTbl.GetFinalizeCode(); //今のファイナライズコードを取得
	
	for(local i = 0; i < ar.len(); i++)
	{
		//array[i]の種類によって分岐
		//array　code,Mvの配列
		//string　デフォルトとび先Mv
		if( typeof ar[i]=="string")
		{			
			//_dm("指定抜け先"+vargv[i]);
			ret_nextmv = ar[i];
		}
		else if( typeof ar[i]=="array")
		{
			if( fc == ar[i][0] )
			{
				if( typeof ar[i] =="function" )
				{
					ar[i]();
				}
				else
				{
					//_dm("指定抜け先"+vargv[i][1]);				
					ret_nextmv = ar[i][1];
				}
			}
		}
	}

	BMvTbl.SetFinalizeCode(0); //使ったら初期化
	
	return ret_nextmv;
}

//攻撃判定が存在するかチェック
//BMvEff.IsAttackRect()を使おう
Battle_Std.CheckHanteiAttackExist <- function(code=0)
{
	local rc = BMvEff.IsAttackRect();
	if( rc ) return 1; // あったら1
	return 0; //無かった
}


//メルブラっぽいヒット分岐　投げがヒットしたら

//FrameUpdateでやるとGetCaptureCharaDataがつかんだ扱いにならないので
//UpdateかHitInterruptでやること
//Updateだとつかみ中もヒット扱いになるのでGetMvHitStatusでチェックしている
//code:投げ抜けできない投げ終了
//gouin_code:！投げで投げ抜けはできる
//combo_code:コンボ中なので投げ抜けできない投げ
//miss_code:投げ抜けできない投げ(これが!= -1だとcodeは投げ抜け可能な投げになり、履歴の投げられ回数が加算される)
//通常投げはここにくる前に強引かどうか分岐してるので注意
//掴みFinalizeをしたら1を返す　掴まなかったりエラー時は0を返す
//techmiss_code:投げ抜け失敗フレーム中投げ -1ならcodeを使う（ちょっと怪しい）→使ってないので未使用になった。代わりにmiss_codeを使う。

// 一般的なコマ投げ。普段は投げ抜け不能だが、ガード中などを掴むと金投げになり、投げ抜け可能になる。
// Battle_Std.SetThrowHitFinalize(256,512,256); // 投げ＆リジェクト(投げぬけ不可),　強引投げ, コンボ投げ

// 常に金投げのコマ投げ。普段は投げ抜け可能だが、相手が投げ抜け不能状態のときはそのまま掴む
// Battle_Std.SetThrowHitFinalize(512,700,256,256); // 投げ,　金投げ, コンボ投げ, リジェクト投げ＆投げが投げぬけ可に変化

// 普通のヒット分岐。ロック技やガード不能技など。
// Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ

Battle_Std.SetThrowHitFinalize <- function(code=0, gouin_code=-1, combo_code=-1, miss_code=-1, techmiss_code=-1 )
{
	//別に攻撃判定が出てなくてもいい気がするね。
	//大事なのはつかんでるかどうかのチェック
	//つかみ中にきたらそりゃ通るけど別にいいだろう
	
	//Finalizeするだけの関数なので何度呼ばれてもいいが、投げ抜け回数を記憶している処理だけは1回のみにする
	//MEMO:将来的には、この処理も一回だけ呼べばいい気はする。というか1回しか通らない思っていた
	local isDamageTiming = Battle_Std.CheckDamageTiming();//つかみの一回目のみ1
	
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.isdone() )
	{
		if( Def_Dbg_LocalDebugMode )
		{
			if( Battle_Std.CheckHanteiAttackExist() == 0 ) // 自分の攻撃判定がでているか
			{
				// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalize 攻撃判定なしで捕獲しました");
			}
		}
		
		enemy.push();
			local bs = BtlMvStd.GetBoundStatus();
			Battle_Std.PlayerSE_StopLastPlaySound( 1 ); //直前に再生した音声を停止
			local enemyIsMoveable = BCMDTbl.CheckCancel( _SkillType_None );//行動可能状態かどうか
			local enemyCharaNo = BMvTbl.GetMvStatus().CharaNo;
			local enemyIsAtkMv = Battle_Std.MoveCode.CheckFlag( def_MC_Atk|def_MC_Skill );
		enemy.pop();
		
		local flag = (1<<1); // | (1<<2)
		local isGouinNage = (((bs.isCapture&flag)!=0) && gouin_code!=-1); //ガードややられ中を掴んだときはこれ（通常投げでは入らない）
		local isComboNage = ( (bs.isBound) && ( bs.Name.find("ガード")==null ) && combo_code!=-1); //コンボ投げ
		// local isComboNage = ( (bs.isBound) && ( bs.isBound != 2 ) && combo_code!=-1); //コンボ投げ ※こうするとハメ…
		//print("\n isComboNage"+isComboNage+" bs.isBound"+bs.isBound );
		//ガード中掴んだときもisBound==1になっているので注意（つかまれ中だからだった気がする）
		// _dpn("bs.Name:"+bs.Name+" bs.isBound:"+bs.isBound );
	
		local hs = BMvTbl.GetMvHitStatus();
		if( hs.Type & _HitType_Damage)
		{
			//_dm("投げがヒット");
			if( isGouinNage )
			{
				// ガード中とか投げ無敵を掴んだ金投げ
				
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					if( miss_code == -1 )
					{
						BMvTbl.SetFinalize( code );
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に投げ抜け不能を掴んだ:"+code);
					}
					else
					{
						BMvTbl.SetFinalize( miss_code );					
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に投げ抜け不能を掴んだ(x):"+techmiss_code);
					}
					return 1; // 掴み成功
				}
				else
				{
					//敵が通常技や必殺技のモーション中で、かつ行動不能なら確定
					if( enemyIsAtkMv && enemyCharaNo==Def_ChrNo_Vat && Battle_Std.ThrowTech.CheckTechImpossible() )
					{
						//確定投げで、投げ抜け不能なやつで、技の隙にあてるとここ（ワレンのAコマ投げとか）
						// _dpn("通常技 or 必殺技1");
						if( miss_code == -1 )
						{
							BMvTbl.SetFinalize( code );
						}
						else
						{
							BMvTbl.SetFinalize( miss_code );
						}
						return 1;
					}
	
					if( isComboNage )
					{
						BMvTbl.SetFinalize( combo_code );						
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeでコンボ投げ:"+combo_code);
						return 1; // 掴み成功
					}
					else
					{
						BMvTbl.SetFinalize( gouin_code );
						// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで強引に掴んだ:"+gouin_code);
						
						//強引投げなので補正をかける
						//乗算85%ぐらい？
						//BMvEff.StdCall( { type=6, no=112, param=[ 85,1,0,0,0, 0,0,0,0,0, 0,0 ]} );
						
						//掴んだ相手側に投げられ回数を加算
						if( isDamageTiming )
						{
							if( enemy.push() )
							{
								BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
								
								enemy.pop();
							}
						}
						return 1; // 掴み成功
					}
				}
			}
			else if( miss_code!= -1 ) // 投げぬけができるコマ投げの時（-1だと投げぬけできないコマ投げ）
			{
				//いきなり掴んだとき
				//投げ抜け失敗フレーム中だったら失敗演出も入れて通常ファイナライズ
				if( Battle_Std.ThrowTech.CheckTechMissFrame() )
				{
					BMvTbl.SetFinalize( miss_code );	
					// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで投げ抜け不能を掴んだ(2):"+miss_code);
					return 1; // 掴み成功
				}
				else
				{
					//敵が通常技や必殺技のモーション中で、かつ行動不能なら確定
					if( enemyIsAtkMv && enemyCharaNo==Def_ChrNo_Vat && Battle_Std.ThrowTech.CheckTechImpossible() )
					{
						// _dpn("通常技 or 必殺技2");
						BMvTbl.SetFinalize( miss_code );
						return 1;
					}
					
					BMvTbl.SetFinalize( code );	
					// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで失敗じゃない時を掴んだ:"+code);

					//掴んだ相手側に投げられ回数を加算
					if( isDamageTiming )
					{
						local enemy = BMvCore.GetCaptureCharaData();
						if( enemy.push() )
						{
							BMvEff.AddSkillCount( _SkillCount_Throw ); // 履歴カウンタを加算
							
							enemy.pop();
						}
					}
					return 1; // 掴み成功
				}			
			}
			else //投げぬけができないコマ投げ
			{
				BMvTbl.SetFinalize( code );	
				// if( Def_Dbg_SkillThrowLog ) _dp("\nSetThrowHitFinalizeで掴んだ:"+code);
				return 1; // 掴み成功
			}
		}
		else
		{
			// if( Def_Dbg_SkillThrowLog ) _dp("\n【連絡】掴んではいるけどダメージ状態じゃなかった");
			return 0;
		}
	}
	else //つかんでいないとダメ
	{
		//打撃投げをガードされたりしてもここにくる
		//_dm("投げがヒット…したはずだが掴めなかった");
		//print("【連絡】つかみ失敗");
		return 0;
	}
	return 0;
}



//つかみ中の相手が地面に埋まってたら補正をかけるだけ（なんか別のと一緒にしよう）
Battle_Std.CaptureChara_Positioning <- function()
{
	//演出中地面に埋まってるようだったら微調整
	local cp = BMvCore.GetCaptureCharaData();
	//有効だったら＝つかまれ中だったら
	if( cp.IsDone )
	{
		BMvCore.PushCharaData( cp ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			if( pos.y>0 )
			{
				BMvTbl.SetPosition({ y=0, }); //座標を変更
			}
		BMvCore.PopCharaData(); //				
	}
}

//攻撃判定が触れていてかつダメージ状態かチェック
//これもう使うべきではない
Battle_Std.CheckHanteiDamage <- function()
{
	local s = BMvTbl.GetMvHitStatus();
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	if (s.Type & _HitType_Damage && enemy.IsDone )
	{
		return 1;
	}
	return 0;
}

//ヒットステータスが入ったPPを取得するだけ
Battle_Std.GetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local ret = BMvTbl.GetPP(slot);
	//_dm("GetPP_HitStatus:スロット:"+slot+" 値:"+ret);
	return ret;
}

//ヒットステータスをPPに入れるだけ
Battle_Std.SetPP_HitStatus <- function( slot = 0 )
{
	//ヒットしたら親の変数を操作する
	local hs = BMvTbl.GetMvHitStatus();
	
	BMvTbl.SetPP(slot, hs.Type);
}

//PPに入れたヒットステータスを初期化する（単にPPを0で上書きするだけ）
Battle_Std.SetPP_ClearHitStatus <- function( slot = -1 )
{
	//ヒットしたら親の変数を操作する
	BMvTbl.SetPP(slot, 0);
	//_dm("SetPP_ClearHitStatus:初期化");
}


//きりもみやられ共通回転処理
local func_kirimomi_kaiten = function( mvs )
{
	if( mvs.MvCount > 0 && mvs.FrameID==100 )
	{
		BMvTbl.Frame_Proc( (mvs.DataFrame+1), _ValSet );
		local s = BMvTbl.GetMvStatus();
		if( s.FrameID!=100 )
		{
			BMvTbl.JumpFrameID(100); //100のループの最初に戻る
			local s = BMvTbl.GetMvStatus();
			BMvTbl.Frame_Proc( (s.DataFrame+1), _ValSet ); //ズレるので１つ進める
		}
	}	
}

//やられのInitでやる処理
//ベクトル移行でなっちゃうからバウンドの時とかも入ってくるから注意
Battle_Std.BoundInit <- function() : (func_kirimomi_kaiten)
{
	local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
	
	if( player.isdone() )
	{
		local flag_isGroundFatal = false;
		local flag_isGroundBound = false;
		local flag_isKirimomi = false;
		local flag_isKirimomiSui = false;
		local mvs = BMvTbl.MvStatus();

		if( player.push() )
		{
			flag_isGroundFatal = (BMvTbl.CheckPattern([303,304,305,306,307,308])==1); //地上強やられからきた？
			flag_isGroundBound = (BMvTbl.CheckPattern([300,301,302,303,304,305,306,307,308])==1); //地上やられからきた？
			flag_isKirimomi = (BMvTbl.CheckPattern([333])==1); //きりもみからきた？
			flag_isKirimomiSui = (BMvTbl.CheckPattern([334])==1); //垂直きりもみからきた？
			mvs = BMvTbl.GetMvStatus();
			
			player.pop();
		}
		
		

		//local test = BMvTbl.CheckPattern(304);
		//_dm("test:304"+test);

		//_dm("flag:"+flag_isGroundFatal+" 地上やられから？:"+flag_isGround);
		//local s = BMvTbl.GetMvStatus(); // ステータス取得
		//_dm("パターン番号:"+s.DataPattern);

		
		BMvEff.CutInProc_Erase(); //カットインがあったら消去する
		
		local last_bs = BtlMvStd.GetBoundStatus(); //食らう直前のバウンド情報取得
		
		//食らう前の状態がつかみだったらベクトル初期化をしない
		//つかまれ中じゃなかったらベクトル初期化をする
		if( !last_bs.isCapture )
		{
			//つかみ中はやられても動かないので初期化もしない
			Battle_Std.InitVector(); // ベクトル初期化
		}
		
		//---------------------------------------------------------------------
		// ここからベクトル設定
		//---------------------------------------------------------------------
		BtlMvStd.SetBoundStatus(); //ベクトル情報を入れる
		
		local bs = BtlMvStd.GetBoundStatus();
		local bs_isbound = bs.isBound;
		local isFirstBoundTbl = (bs_isbound && bs.VecCount==0); //ベクトルテーブルの最初かどうか
		local bs_power = (bs_isbound)? bs.Power : 0;

		if( bs.isDone )
		{
			BMvTbl.SetPP(def_PP_LastWallCount, bs.WallCount);
		}

		// やられボイス再生処理
		if( isFirstBoundTbl ) //定義してるテーブルの最初のBoundでしか声を出さない
		{
			local sound_st = BMvTbl.GetPP(def_PP_SoundStatus);
			if( sound_st&def_PP_SS_NoBoundVoice )
			{
				//ボイス再生禁止フラグがたっています
				// dm("やられボイス禁止フラグあり");
			}
			else if( sound_st&def_PP_SS_NoBoundVoiceOnce )
			{
				BMvTbl.SetPP( def_PP_SoundStatus, sound_st&~def_PP_SS_NoBoundVoiceOnce ); // フラグ消去
				
				//_dp("\n def_PP_SS_NoBoundVoiceOnce:"+def_PP_SS_NoBoundVoiceOnce);
			}
			else
			{
				// _dm("pow:"+bs.Power+" def_BS_Pow_LV2"+def_BS_Pow_LV2);
				// bs_powerの定数、「def_BS_Pow_LV2 = 0」なのでフラグチェックでは使わないこと
				
				if( bs_power&def_BS_Pow_LV3 )
				{
					// 強
					Battle_Std.TypeSE_Play({ type="やられ強" });
				}
				else if( bs_power&def_BS_Pow_LV1 )
				{
					// 弱
					Battle_Std.TypeSE_Play({ type="やられ弱" });	
				}
				else if( bs_power&def_BS_Pow_LV0 )
				{
					// 声無し
				}
				else
				{
					// 中
					Battle_Std.TypeSE_Play({ type="やられ中" });	
				}
			}
		}

		//ベクトルテーブルの最初かつつかまれ中以外なら振り向き処理を行う
		if( isFirstBoundTbl && !bs.isCapture )
		{
			if( bs_power&def_BS_Pow_Furimuki )
			{
				Battle_Std.SetMuki_ReverseEnemy( 0 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
			else
			{
				Battle_Std.SetMuki_ReverseEnemy( 1 ); //相手と反対の向きを向く　0:殴られ相手 1:殴られ親
			}
		}
		//print("\n isFirstBoundTbl:"+isFirstBoundTbl);

		if( BMvTbl.CheckPosState( _PosState_Ground )) //地上やられの時
		{
			//_dm("地上やられ？");
			//if( flag_isGroundBound ) BMvTbl.SetMuki( _Direction_Auto ); //地上やられからきた地上やられなら振り向く
			if( flag_isGroundFatal )
			{
				if( BMvTbl.CheckPattern( 300 ) ) BMvTbl.SetPattern(303);
				else if( BMvTbl.CheckPattern( 301 ) ) BMvTbl.SetPattern(304);
				else if( BMvTbl.CheckPattern( 302 ) ) BMvTbl.SetPattern(305);
			}
		}
		
		//きりもみのループ中はヒットのたびに回転するみたいな
		if( flag_isKirimomi ) // きりもみ吹き飛び
		{
			if( BMvTbl.CheckPattern( 333 ) ) func_kirimomi_kaiten( mvs );
		}
		else if( flag_isKirimomiSui ) //垂直きりもみ
		{
			if( BMvTbl.CheckPattern( 334 ) ) func_kirimomi_kaiten( mvs );
		}
	}
}

Battle_Std.BoundUpdate <- function()
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Bound } );
	BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Keep } ); // 几帳面に記憶しておく
	
	//地上状態では符号が反転しないようにする
	if( BMvTbl.CheckPosState( _PosState_Ground  ) )
	{
		//今プラスのベクトルで、次のフレームがマイナスベクトルか？
		//print(format("\n x:%d addx:%d",vec.x, vec.addx));
		if( (( vec.x<0 ) && ( (vec.x + vec.addx)>=0 )) || (( vec.x>0 ) && ( (vec.x + vec.addx)<=0 )) )
		{
			BMvTbl.SetVector( { x=0, addx=0, flags=_Vector_Bound } );
		}
	}
}


//飛び道具同士の相殺を実現するためのもの色々

//飛び道具の初期設定
//弾制限があればつける
Battle_Std.InitFireBallStatus <- function( _flags = 0 )
{
	BMvTbl.SetLP(def_LP_MvType, def_MvType_Ball);	//俺が飛び道具だ
	BMvTbl.SetLP(def_LP_BallFlags, _flags ); // フラグ関係初期化（指定があったらそれになるけど）
	
	local ball = BMvTbl.GetLP(def_LP_BallSlot); //LPの値の飛び道具制限数を操作する
	if(ball != -1)
	{
		BMvTbl.TobiParam_Func( { slot=ball, val=1, type=_ValAdd } );
	}
	BMvEff.ClearAttackHitNum(); //いちおう	
	Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす(?)
	// ヒットを親に伝える
	if( Def_Rule_ToParentFireBallHitStatus ) BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
}

//飛び道具属性を解除して弾制限があればそれも消す
function Battle_Std::ClearFireBallStatus()
{
	BMvTbl.SetLP(def_LP_MvType, def_MvType_Normal); //飛び道具属性だったのを無属性にする
	local ball = BMvTbl.GetLP(def_LP_BallSlot); //LPの値の飛び道具制限数を操作する
	if(ball != -1)
	{
		BMvTbl.TobiParam_Func( { slot=ball, val=-1, type=_ValAdd } );		
	}
	Battle_Std.ClearBallFlags(def_BallFlags_Finalize); //次回ファイナライズフラグはなくす
}


//飛び道具ステータスを取得
Battle_Std.GetFireBallStatus <- function()
{
	local tbl = {};
	local mvtype = BMvTbl.GetLP(def_LP_MvType);
	tbl.isFireBall <- (mvtype == def_MvType_Ball); //自分が飛び道具かどうか
	tbl.HitCount <- BMvTbl.CalcHitValue(0); //残りのヒット回数を取得する
	tbl.isSousaiSubHited <- Battle_Std.GetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺したよフラグがたっているかどうか
	tbl.MvCode <- BMvTbl.GetMoveCode();
	return tbl;
}

Battle_Std.GetFireBallFlags <- function( flag )
{
	local ret = ((BMvTbl.GetLP(def_LP_BallFlags)&flag)!=0);
	return ret;
}

Battle_Std.CheckFireBallFlags <- function( flag )
{ 
	return ( BMvTbl.GetLP(def_LP_BallFlags)&flag )? 1 : 0;
}

Battle_Std.AddFireBallFlags <- function( flag )
{
	BMvTbl.SetLP(def_LP_BallFlags,( BMvTbl.GetLP(def_LP_BallFlags)|flag) );
}

Battle_Std.SetFireBallFlags <- function( flag )
{
	Battle_Std.AddFireBallFlags( flag );
}

Battle_Std.ClearBallFlags <- function( flag )
{
	BMvTbl.SetLP(def_LP_BallFlags,( BMvTbl.GetLP(def_LP_BallFlags)&~flag) );
}


// これで呼ぶと、相殺時などにLPが勝手に操作されたりするので注意
// 必ずMv_FireBall_*** なMvを呼び出すこと（tmpl自動生成とワンセット）
function Battle_Std::CreateFireBall( t )
{
	/*
	tableメモ
	x 発射Xツール座標
	y 発射Xツール座標
	mv だすMvの名前（指定が無いと親のMv+"_FireBall"）
	varslot Mvに伝える変数LPスロット
	varvalue スロットに入れる値
	angle 初期回転角（見た目・内部）
	pat 表示するパターン
	vec{ x, y, addx, addy} ベクトル
	ball eff6-100 101用
	
	initfunc : 最初にやっておきたい関数
	
	LP = { slot=0, val=0, }
	
	flags:FireBallStatusに最初に入れる値
	
	*/
	
	local px = ("x" in t)? t.x : 0;
	local py = ("y" in t)? t.y : 0;

	local mv = ("mv" in t)? t.mv : (BMvTbl.GetMvName() + "_FireBall");	
	
	local ang = ("angle" in t)? t.angle : 0;
	
	local oyamuki_isRight = ( BMvTbl.GetMuki() == 1 )? true : false ;
	
	local fbs_flags = ("flags" in t)? t.flags : 0; // FireBallStatusの初期フラグ設定

	local eff = BMvEff.CreateObject( { x=px, y=py, mvname=mv, flags=_Position_ToolShift } );
	if( eff.push() )
	{
		if ("LP" in t ) BMvTbl.SetLP(t.LP.slot, t.LP.val);
		if ("varslot" in t && "varvalue" in t) BMvTbl.SetLP(t.varslot, t.varvalue);

		BMvTbl.SetAngle( {angle=ang} );
		if ("pat" in t) BMvTbl.SetPattern(t.pat);
		if ("vec" in t) BMvTbl.SetVector(t.vec);
		("ball" in t)? BMvTbl.SetLP(def_LP_BallSlot, t.ball) : BMvTbl.SetLP(def_LP_BallSlot, -1);
		Battle_Std.InitFireBallStatus( fbs_flags ); //飛び道具扱いのMvへの初期設定
		( oyamuki_isRight )? BMvTbl.SetMuki( _Direction_Right ) : BMvTbl.SetMuki( _Direction_Left ) ; //意味ある？無い？
		if( "initfunc" in t ) t.initfunc();
		
		eff.pop();
	}
	
	return eff; //作成したオブジェクトを返す
}



//角度とスピードとフレームを指定してベクトルテーブルを返す
function Battle_Std::GetVector_FromAngle( t )
{
	//angle_vec = { angle=2500, power=8000, time=10, flags=_Vector_Div }
	/*
	t.angle : 角度0-10000
	t.speed : 速度
	t.endspeed : frame経過時のspeed（ 0なら収束するし、でかけりゃ加速する）
	t.frame : フレーム
	
	t.flags
	
	0.0〜2.0
	
	0〜200/100
	
	*/
	local ret = 0;
	local a = ( (("angle" in t)? t.angle : 0) /10000.0)*2.0;
	local endspeed = ("endspeed" in t)? t.endspeed : 0;
	
	local vec = BMvEff.GetVector_FromAngle( { angle = a, speed = t.speed } );
	if( "frame" in t )
	{
		local spd = (endspeed-t.speed)/t.frame;
		local add = BMvEff.GetVector_FromAngle( { angle = a, speed = spd } );
		ret = { x=vec.x, y=vec.y, addx=add.x, addy=add.y, flags=("flags" in t)? t.flags: 0 };	
	}
	else
	{
		ret = { x=vec.x, y=vec.y, flags=("flags" in t)? t.flags: 0 };		
	}
	return ret;	
}


// 相殺新仕様（相殺したい、されたいオブジェクトからは全部これが呼ばれる）
// 自分と相手同じ処理になっていないとダメ（１Ｐ、２Ｐどっちが先でもおかしくならないように）
// 相殺に対して何かする場合は、　def_MC_Sousai_EnemySubSuccess　をチェックする
// なのでこの関数は何も返さない（戻り値を見て処理する＝処理が対等でない）
// 時々相殺に失敗する（ベクトルが巨大なオブジェクトだったりするとそうなる）
// 攻撃判定同士でしか相殺できないが、試しに特殊判定３（飛び道具判定）とも相殺するようにした
Battle_Std.CheckSousai <- function()
{
	// 相手の何らかのオブジェクトの攻撃判定と触れているか
	local enemy = BMvEff.CheckHantei2( { src=[ [ _Hantei_Attack , 0, -1 ], [ _Hantei_Etc , 3, 1 ] ], dst=[ [ _Hantei_Attack , 0, -1 ], [ _Hantei_Etc , 3, 1 ] ], flags=_HC_EnemyPc|_HC_EnemyObj } );
	
	/*
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Attack , 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );

	if( !enemy.isdone() )
	{
		local ene_1 = BMvEff.CheckHantei( { src=[ _Hantei_Etc , 3, 1 ], dst=[ _Hantei_Attack , 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
		if( ene_1.isdone() )
		{
			_dp("\n 特殊3 と 攻撃");
			enemy = ene_1;
		}
		else
		{
			local ene_2 = BMvEff.CheckHantei( { src=[ _Hantei_Attack , 0, -1 ], dst=[ _Hantei_Etc , 3, 1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
			if( ene_2.isdone() )
			{
				_dp("\n 攻撃 と 特殊3");
				enemy = ene_2;
			}
			else
			{
				local ene_3 = BMvEff.CheckHantei( { src=[ _Hantei_Etc , 3, 1 ], dst=[ _Hantei_Etc , 3, 1 ], flags=_HC_EnemyPc|_HC_EnemyObj } );
				if( ene_3.isdone() )
				{
					_dp("\n 特殊3 と 特殊3");
					enemy = ene_3;
				}
			}
		}
	}
	*/
	
	if( enemy.push() )
	{
		local ets = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得

		enemy.pop();

		local pts = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得
		
		local play_se = 0; // 相殺でＳＥを再生するかどうか
		
		//_dp1p("\n "+e_sousai +", " +pts.HitCount+", " + e_sousai +", "+ ets.HitCount );
		// def_MC_Sousai　同士で触れていて、かつヒット数が残っていたら相殺する
		
		if ( ets.MvCode&def_MC_Sousai && pts.HitCount>0 && pts.MvCode&def_MC_Sousai && ets.HitCount>0) //相殺するオブジェクト同士で触れた
		{
			//自分側の処理
			if( (pts.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時にヒット数減算しない、ではない
			{
				play_se = 1;
				BMvTbl.CalcHitValue(-ets.HitCount); //相手の飛び道具ヒット数分、ヒット数を減らす
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
				
				if( pts.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
				{
					Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
					if( BMvTbl.CalcHitValue(0) <=0 )
					{
						Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
					}
				}

				// 相手側
				if( enemy.push() )
				{
					Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺で相手のヒット数減算に成功した
					
					enemy.pop();
				}
			}
			
			//相手側の処理
			if( (ets.MvCode&def_MC_Sousai_NoSubHitCount)==0 ) // 相殺時にヒット数減算しない、ではない
			{
				play_se = 1;
				if( enemy.push() )
				{
					BMvTbl.CalcHitValue(-pts.HitCount); //自分のヒット数分、ヒット数を減らす
					Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Sousai_MySubSuccess ); // 相殺で自分のヒット数減算に成功した
					
					if( ets.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
					{
						Battle_Std.SetFireBallFlags(def_BallFlags_SousaiSubHited); //相殺でヒット数が減ったことを記憶
						if( BMvTbl.CalcHitValue(0) <=0 )
						{
							Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
						}
					}
					enemy.pop();

					// 自分側
					{
						Battle_Std.MoveCode.AddFlag( def_MC_Sousai_EnemySubSuccess ); // 相殺成功フラグをたてる
					}
				}
			}
			
			// 二重に再生されるけど気にしない
			if( play_se )
			{
				BSound.SE_Play( { type=_SeType_Normal, num=195 } );
			}
		}
	}
}

//Mvでよく使う関数登録


//全てのベクトルを消す　保存ベクトルも消える　X MAXも初期化する 
function Battle_Std::InitVector()
{
	BMvTbl.SetVector( { x=0, y=0, addx=0, addy=0, flags=_Vector_Normal|_Vector_Div|_Vector_Bound|_Vector_Keep|_Vector_DivKeep } );	
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化
}

//慣性を残したベクトル初期化（地上の通常技や必殺技のでかかりとか）
//判定ツールのInitとほぼ同じ？
function Battle_Std::InitCharaVector()
{
	BMvTbl.SetVector_CCharaVector( BMvTbl.CCharaVector(), 0 );
	BMvTbl.SetVector_MaxX( 0 ); //XMAXを初期化 _Vector_Normalしか影響しないので消さないと不味そう
}


//自分 相手の配置なら０，違ったら１を返す（１P側で0、2P側で1）
function Battle_Std::GetPositionSide()
{
	local pos1 = BMvTbl.GetPosition(0);
	local pos2 = Battle_Std.GetEnemyPosition();
	return (pos2.x>pos1.x)? 0 : 1;
}

//相手操作親に座標を与える
//相手に対してSetPositionする
function Battle_Std::SetEnemyPosition(tbl)
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			BMvTbl.SetPosition( tbl ); //
		BMvCore.PopCharaData(); // 
		return 1;
	}
	else
	{
		return 0; //敵取得失敗
	}
}

//相手操作親の座標テーブルを返す
//相手に対してGetPositionする
function Battle_Std::GetEnemyPosition()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(); // 位置取得
		
		enemy.pop();
		return epos;
	}
	else
	{
		// _dm("【警告】GetEnemyPositionで相手座標取得失敗")
		local pos = BMvTbl.CCharaPosition();
		return pos; //敵取得失敗したけど仮座標を返す
	}
}

//相手の座標のツール座標を返す
//相手との距離を見るのには使っちゃダメ
//相手の位置にエフェクトを出したり…距離がマイナスだとダメみたい
//使える
//_Position_ToolShift	--- x,y座標をHAN6上の設定値にする、HAN6値 = 実座標/128 となる。
//_Position_ChangeMuki	--- 向きによるX座標の符号反転を行う
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift})
// Battle_Std.GetNearEnemyDistance({flags=_Position_ToolShift|_Position_ChangeMuki})
Battle_Std.GetNearEnemyDistance <- function(tbl={})
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local throw_param = {};
		if("capture_pos" in tbl)
		{
			switch( tbl.capture_pos )
			{
			case "頭":
				throw_param.hantei_rect <- [ _Hantei_Etc, 9 ];
				break;
			case "首":
				throw_param.hantei_rect <- [ _Hantei_Etc, 10 ];
				break;
			case "腹":
				throw_param.hantei_rect <- [ _Hantei_Etc, 11 ];
				break;
			case "足":
				throw_param.hantei_rect <- [ _Hantei_Etc, 12 ];
				break;
			}
		}


		//tbl.flags = {}
		local flag_Position_ToolShift = false;
		local flag_Position_ChangeMuki = false;
		if("flags" in tbl)
		{
			if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
			if( tbl.flags & _Position_ChangeMuki ) flag_Position_ChangeMuki=true;
		}
		
		//print("\n結果"+flag_Position_ToolShift+flag_Position_ChangeMuki);

		local ret_tbl = {};
		ret_tbl.IsDone <- false;
		
		local target_pos = BMvTbl.CCharaPosition(); // ターゲットにするもの


		local posst;		
		if( "hantei_rect" in throw_param )
		{
			//local pos = BMvTbl.CCharaPosition(); // 位置情報型の生成
			BMvCore.PushCharaData( enemy ); // 
				local rc = BMvEff.GetHanteiRect ( { check=throw_param.hantei_rect, flags=_HanteiFlag_NoMukiChange } );
			BMvCore.PopCharaData();
			if( rc.sx== _Hantei_Error)
			{
				// _dem("GetNearEnemyDistance:つかむ位置がみつからない");
			}
			else
			{
				// _dm(format("GetNearEnemyDistance掴み座標: x:%d y:%d",rc.sx, rc.sy) );
			}
			target_pos.x = rc.sx;  target_pos.y = rc.sy;
		}
		else
		{
			target_pos = Battle_Std.GetEnemyPosition();
		}
		
		//ターゲットまでの距離とかを
		posst = BMvEff.GetPointStatus( { position=target_pos } );
	
		ret_tbl.x <- flag_Position_ToolShift? (posst.distance_x/128).tointeger() : posst.distance_x;
		ret_tbl.y <- flag_Position_ToolShift? (posst.distance_y/128).tointeger() : posst.distance_y;
		ret_tbl.IsDone = true;

		//1P 2Pの位置関係の時、右向き
		//2P 1Pの位置関係のとき、左向き、ならプラスの値
		if( flag_Position_ChangeMuki )
		{
			local player_side = Battle_Std.GetPositionSide();
			if( player_side==0 ) //1P側
			{
				if(BMvTbl.GetMuki()==-1) ret_tbl.x *= -1;
			}
			else
			{
				if(BMvTbl.GetMuki()==1 ) ret_tbl.x *= -1;		
			}
		}
		//distanceなので、ターゲットより自分が下にいたらマイナスにする
		local pos1 = BMvTbl.GetPosition(0);
		if( target_pos.y<pos1.y ) ret_tbl.y *= -1;	
		
		return ret_tbl;
	}
	else
	{
		// _dm("【警告】GetNearEnemyDistanceで相手がいない");
		local pos = BMvTbl.CCharaPosition();
		return pos;
	}
}

//相手のツール座標を返す
//相手の位置にエフェクトを出したりする専用
Battle_Std.GetNearEnemyToolShiftPosition <- function(tbl={})
{
	local ret = clone tbl;
	if( "flags" in ret)
	{
		ret.flags = _Position_ToolShift|_Position_ChangeMuki;
	}
	else
	{
		ret.flags <- _Position_ToolShift|_Position_ChangeMuki;
	}
	local pos = Battle_Std.GetNearEnemyDistance(ret);
	return pos;
}

//相手との距離情報を返す .angle, .distance
Battle_Std.GetPointStatus_NearEnemy <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.IsDone ) // 有効かどうか一応チェック
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		// local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
		// print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
		return posst;
	}
	else
	{
		local posst = BMvEff.CPointStatus();
		return posst;
	}
}

//相手への角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetNearEnemyMigiAngle <- function()
{
	local ps = Battle_Std.GetPointStatus_NearEnemy();
	if( ps==-1 )
	{
		// _dem("【警告】GetNearEnemyToolShiftAngle 相手が見つからない")
		return 0; //みつから無かったけど適当な値を返す
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	//右向きならそのまま　左向きなら反転
	//相手の方を向いていればそのまま返す
	//反対を向いていたらなんかやって返す
	//local isAiteMuki = (BMvTbl.CheckFurimuki()==0);
	local isMigiMuki = (BMvTbl.GetMuki()==1);
	/*
	if( !isAiteMuki ) //相手と反対向き
	{
		print("\n相手と反対")
		ret_angle = 2.0-ret_angle;
	}
	*/
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		//print("\n左向きだわ")
		ret_angle = 2.0-ret_angle;
	}	
	return ret_angle;
}


//おやへの右向き角度を返す（右向きの0.0〜2.0で角度が入る）
Battle_Std.GetParentMigiAngle <- function()
{
	local oya = BMvCore.GetParentCharaData();
	local ps = BMvEff.GetPointStatus( { target=oya } ); // 位置情報取得
	if( ps==-1 )
	{
		// _dem("【警告】親がいねー")
		return 0; //みつから無かったよ
	}
	//0.0〜2.0
	local ret_angle = ps.angle;

	local isMigiMuki = (BMvTbl.GetMuki()==1);
	
	//このチェックだけでよさそうだ
	if( !isMigiMuki ) //左向き
	{
		ret_angle = 2.0-ret_angle;
	}		
	return ret_angle;	
}


// flag & (1<<0) : 対空技設定（相手が空中でやられじゃない時すり抜けないようにする）
// flag & (1<<1) : ↑の処理＋空中やられチェックを無効化
//地上同士の時すり抜けないような補正がかかるEff6-12
Battle_Std.AddToolShift_NoSurinuke <- function(plus_x=0, flag=0)
{	
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y != 0) 
	{
		//自分が空中なら気にせず
		BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
		return;
	}
	local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
	if( enemy.push() )
	{
		local epos = BMvTbl.GetPosition(0);
		
		enemy.pop();
		if( epos.y != 0) // 相手が空中の時
		{
			local checkNearTaiku = 0;
			
			// 対空チェックフラグがある時
			if( flag & (1<<0) || flag & (1<<1) )
			{
				local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
				
				local xLen = posst.distance_x/128;
				local yLen = posst.distance_y/128;
				// _dp("\n 相手とのY距離 : "+yLen );
				
				// 300ドット以内
				if( (!Battle_Std.CheckEnemyisBound() || flag & (1<<1) ) && yLen < 300 )
				{
					checkNearTaiku = 1;
					
					// _dp("\n ■移動予定:"+plus_x );
					
					xLen = xLen - 25;  // 重なり半分
					if( xLen < 0 ) xLen = 0;
					
					// _dp("\n 　重なり考慮の相手までの距離:"+xLen );
					if( xLen < plus_x )
					{
						plus_x = xLen; //
					}
					// _dp("\n 　-> "+plus_x );
					
				}
			}
			
			if( checkNearTaiku )
			{
				// 対空時で相手が近いので処理調整
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });
			}
			else
			{
				// 相手が空中ならキにせず
				BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
			}
			return;
		}
		// 自分と相手が地上にいる時補正をかける
		local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
		local len = (posst.distance_x/128);
		if( plus_x+50 >= len ) plus_x = len-50; // 大体重なり判定は-50<>+50なので軸を超え過ぎないように補正
	}
	BMvTbl.SetPosition({ x=plus_x, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki });		
}

//画面外チェック
function Battle_Std::CheckGamenGai()
{
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x > (pos.ex+def_POS_GamenGaiYuuyoX) || tp.x < (pos.sx-def_POS_GamenGaiYuuyoX) )
	{
		//_dm("CheckGamenGai:画面外");
		return 1;
	}
	return 0;
}

//画面外チェック(向いてる向きの方だけ)
function Battle_Std::CheckGamenGaiMuki()
{

	local dis = Battle_Std.GetGamenHajiDistance();
	//print("\n:"+dis);
	if( dis+def_POS_GamenGaiYuuyoX < 0 )
	{
		//_dm("CheckGamenGaiMuki:画面外");
		return 1;
	}

	return 0;
}

//画面端チェック　※古いので使うのやめよ
// Battle_Std.CheckFromtDispCornerDistance()　とか使って
function Battle_Std::CheckGamenHaji( offx )
{
	local x = offx * 128;
	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	if(tp.x+x > pos.ex || tp.x-x < pos.sx )
	{
		//_dm("CheckGamenHaji:画面外");
		return 1;
	}
	return 0;
}

//向いてる向きの画面端までの距離を返す
//フィールド内にいる限りプラスの値になるはず？
//古いので使わない
Battle_Std.GetGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local ret = ( BMvTbl.GetMuki() == 1 )? ( pos.ex - tp.x ) : -( pos.sx - tp.x); //右向きだったら
	//print("\n向き："+ BMvTbl.GetMuki() );
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の背面の画面端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenGamenHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	//_dm("test:"+tp.x);
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset } );
	local ret = ( BMvTbl.GetMuki() == 1 )? -( pos.sx ) : ( pos.ex ); //右向きだったら

	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}



//近いステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNearStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( tp.x > 0 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x);
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}


//向いてる向きのステージ端までの距離を返す
//古いので使わない
Battle_Std.GetStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - tp.x ) : ( def_POS_GamenHajiX + tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//背面のステージ端までの距離を返す
//古いので使わない
Battle_Std.GetHaimenStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //右向きだったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//相手キャラが居ない方のステージ端までの距離を返す
//必ずプラスの値になる
//古いので使わない
Battle_Std.GetNoEnemyMukiStageHajiDistance <- function(tbl={})
{
	local flag_Position_ToolShift = false;
	if("flags" in tbl)
	{
		if( tbl.flags & _Position_ToolShift ) flag_Position_ToolShift=true;
	}
	

	local player_is1Pside = (Battle_Std.GetPositionSide() == 0); //１P側で0、2P側で1

	local tp = BMvTbl.GetPosition( 0 ); //現在座標
	local ret = ( player_is1Pside )? ( def_POS_GamenHajiX + tp.x ) : ( def_POS_GamenHajiX - tp.x); //1P側だったら
	return (flag_Position_ToolShift)? (ret/128).tointeger() : (ret);
}

//操作親の方を向く
Battle_Std.SetMuki_PlayerPosition <- function()
{
	//親の座標-自分の座標が＋なら右向き−なら左向き
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local oya_pos = BMvTbl.GetPosition( 0 ); //親の現在座標
		BMvCore.PopCharaData(); //			
		local pos = BMvTbl.GetPosition( 0 ); //現在座標
		local muki_is_migi = ( (oya_pos.x - pos.x)>0 );
		if( muki_is_migi )
		{
			BMvTbl.SetMuki( _Direction_Right );
		}
		else
		{
			BMvTbl.SetMuki( _Direction_Left );			 
		}
	}
}

//指定座標の方を向く
Battle_Std.SetMuki_CCharaPosition <- function( tpos )
{
	local pos = BMvTbl.GetPosition( 0 ); //現在座標
	local muki = ( (tpos.x - pos.x)>0 )? _Direction_Right : _Direction_Left;
	BMvTbl.SetMuki( muki );
}

//親のMvStatusを取得
function Battle_Std::GetParentMvStatus()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のMvNameを取得
function Battle_Std::GetPlayerMvName()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local m = BMvTbl.GetMvName();
//		_dm("Mv取得:"+m);
	BMvCore.PopCharaData(); //
	return m;
}

//親のMvNameを取得
function Battle_Std::GetParentMvName()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local m = BMvTbl.GetMvName();
			//_dm("Mv取得:"+m);
		BMvCore.PopCharaData(); //
		return m;
	}
	else
	{
		// _dem("【警告】親からGetParentMvNameしたとか？");
		return "";
	}
}

//親のフレームIDを取得
function Battle_Std::GetParentFrameID()
{
	local p = BMvCore.GetParentCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】親からGetParentFrameIDしたとか？");
		return 0;
	}
}

//操作親のMvStatusを取得
function Battle_Std::GetPlayerMvStatus()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	BMvCore.PushCharaData( p ); //
		local s = BMvTbl.GetMvStatus(); // ステータス取得
	BMvCore.PopCharaData(); //
	return s;
}

//操作親のフレームIDを取得
function Battle_Std::GetPlayerFrameID()
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		BMvCore.PushCharaData( p ); //
			local s = BMvTbl.GetMvStatus(); // ステータス取得
		BMvCore.PopCharaData(); //
		return s.FrameID;
	}
	else
	{
		// _dem("【警告】GetPlayerFrameIDえらー");
		return 0;
	}
}

//操作親のフレームIDを変更
function Battle_Std::SetPlayerFrameID(frameid=0)
{
	local p = BMvCore.GetPlayerCharaData(); // 親の情報を得る
	if( p.IsDone )
	{
		// _dm("SetPlayerFrameID 操作親FrameIDを"+frameid+"に変更");
		BMvCore.PushCharaData( p ); //
			BMvTbl.JumpFrameID(frameid);
		BMvCore.PopCharaData(); //
	}
	else
	{
		// _dem("SetPlayerFrameIDえらー");
	}
}


//操作親の飛び道具制限を得る
function Battle_Std::CheckPlayerFireballLimit(num=0)
{
	return( BMvTbl.TobiParam_Func( { slot=num, type=_ValGet } ) );
}




//指定したスロットの飛び道具制限を上書きする
function Battle_Std::SetPlayerFireballCount(_slot=0, _num=0)
{
	BMvTbl.TobiParam_Func( { slot=_slot, val=_num, type=_ValSet } );
}


//現在のベクトルもしくは与えたベクトルからツール角度を返す
function Battle_Std::CCharaVector_GetToolAngle(vec=null)
{
	if( vec==null )
	{
		vec = BMvTbl.GetVector(0);	
	}
	local rad = atan2(vec.y, vec.x);
	local tool_angle = ((rad * 180 / PI)+90)/360*10000;
	return tool_angle.tointeger();
}


//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらフレームIDジャンプ
//Battle_Std.JumpFrameID_NotHoldButton(tbl)
//-1: 取得失敗 BMvTbl.JumpFrameIDの戻り値を返す(成功すると フレーム番号が返る（IDではない）、IDがないと -1)
// checkid を探す
// checkid まできたら def_MC2_CheckStartExtendAction フラグが立つ
// ボタンホールドしてなかったら jumpid に飛んで終わり
// ボタンホールドしてると飛ばないで耐える（耐えてる最中はhitCheckId==1）
// checkidを通過後、別のidなら（ !hitCheckId かつ def_MC2_CheckStartExtendAction ）、def_MC2_CheckEndExtendActionがたってないなら
// jumpidと比較して、違っていたらエクステンド、ということでフラグ立てる

function Battle_Std::JumpFrameID_NotHoldButton(tbl)// mask, checkid, jumpid )
{
	return Battle_Std.JumpFrameID_NoHoldButton_MaskCheck( tbl, 1 );
}

// どれかではなく全部押してないとだめバージョン
function Battle_Std::JumpFrameID_NotHoldAllButton(tbl)// mask, checkid, jumpid )
{
	return Battle_Std.JumpFrameID_NoHoldButton_MaskCheck( tbl, 100 );
}

// この関数は直接使わないこと
Battle_Std.JumpFrameID_NoHoldButton_MaskCheck <- function( tbl, buttonMaskCheck=1 )
{
	local flags = ("flags" in tbl)? tbl.flags : 0;
	local noCheckNgTiming = ( (flags&(1<<0)) != 0 )? 1 : 0;//1:NGチェックをしない　Def_JFIDNHB_NoCheckNgTiming
	local holdForever = ( (flags&Def_JFIDNHB_HoldForever) != 0 )? 1 : 0;
	
	// 先にホール状態を取得
	local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	if( player.push() )
	{
		local hold = ( BMvTbl.CheckButtonHold( tbl.mask ) >= buttonMaskCheck ); // 1:どれか押されている 100:全て押されている
		local isExtended = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction );
		
		if( !hold )
		{
			//離してしまったことを記憶しておく
			if( !isExtended )
			{
				//エクステンド確定後は設定しない
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_NotHoldForever );
			}
		}
		local onceReleased = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NotHoldForever ); // すでに一度離しているかどうか
		
		player.pop();
		
		local use_hold = hold;
		if( holdForever && onceReleased ) use_hold = 0;
		
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local ng_timing = (s.isFrameUpdate==0 && s.DataDelayVal==0)? 1 : 0;
		if( ng_timing && !noCheckNgTiming ) return -1; // このタイミングでSetPatternとかJumpFrameIDすると飛び先のFraが2回処理されてしまう
	
		local frameid = s.FrameID;
		local hitCheckId = 0;
		if( typeof tbl.checkid=="array" )
		{
			foreach(i,checkid in tbl.checkid)
			{
				if(frameid==checkid)
				{
					hitCheckId = 1;
					Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );
					
					//ホールドのチェックは操作親で見る
					if( !use_hold ) // ボタンホールドしてなかったら
					{
						if( typeof tbl.jumpid=="array" )
						{
							Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
							return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
						}
						else
						{
							Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
							return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
						}
					}
				}
			}
		}
		else //これはひどい
		{
			if(frameid==tbl.checkid)
			{
				hitCheckId = 1;
				Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );
				
				if( !use_hold ) // ボタンホールドしてなかったら
				{
					if( typeof tbl.jumpid=="array" )
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
						return( BMvTbl.JumpFrameID( tbl.jumpid[i] ) );				
					}
					else
					{
						Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
						return( BMvTbl.JumpFrameID( tbl.jumpid ) );	
					}
				}		
			}
		}
		
		// _dp("\n def_MC2_CheckEndExtendAction:"+Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) );
		if( !hitCheckId && Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction ) && !Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) )
		{
			// _dp("\n エクステンドチェックの後、どうなったかな？");
			
			local noExtendJumped = 0;
			if( typeof tbl.jumpid=="array" )
			{
				foreach( slot, val in tbl.jumpid )
				{
					if( val == frameid ) noExtendJumped = 1;
				}
			}
			else
			{
				if( tbl.jumpid == frameid ) noExtendJumped = 1;
			}
			
			
			if( noExtendJumped ) // エクステンドの飛び先には行ってない
			{
			
			}
			else // エクステンド
			{
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
				
				//XXX:仮
				// BMvTbl.SetTutoMvFlag(4); // インクリース
			}
			
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了
		}
		
		if( "endid" in tbl && frameid == tbl.endid && s.isFrameUpdate )
		{
			// _dp("\n エクステンドアクション！");
			// tDDC.Jem_AddCount( _JemCheckType_Ex + 1 ); // エクステンドアクション加算
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存

			// BMvTbl.SetTutoMvFlag(4); // インクリース
			
			if( "flags" in tbl )
			{
				if( def_JFN_SetExtendFlagPlayer&tbl.flags )
				{
					if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } ) != 0 )
					{
						if( player.push() )
						{
							Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
							
							// BMvTbl.SetTutoMvFlag(4); // インクリース
							
							player.pop();
						}
					}
				}
			}
		}
	}
	return -1;
}



//メルブラでよくやってたBE処理をまとめて
//ボタンホールドが無かったらパターンジャンプ（パターン最初がキャッシュに乗るのでデータ構造から変えておく）
Battle_Std.SetPattern_NotHoldButton <- function( tbl )// ButtonMask, CheckFrameID, SetPattern 
{
	local flags = ("flags" in tbl)? tbl.flags : 0;
	local noCheckNgTiming = ( (flags&(1<<0)) != 0 )? 1 : 0;//1:NGチェックをしない(座標バグが起こるので基本使わないこと)
	
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local ng_timing = (s.isFrameUpdate==0 && s.DataDelayVal==0)? 1 : 0;
	if( ng_timing && !noCheckNgTiming ) return -1; // このタイミングでSetPatternとかJumpFrameIDすると飛び先のFraが2回処理されてしまう
	
	if( s.FrameID == tbl.CheckFrameID )
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckStartExtendAction );
		
		//ホールドのチェックは操作親で見る
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.push() )
		{
			local ret = BMvTbl.CheckButtonHold( tbl.ButtonMask );
			
			p.pop();
			
			if( !ret ) // ボタンホールドしてなかったら
			{
				BMvTbl.SetPattern( tbl.SetPattern );
				return 1;
			}
		}
	}
	else
	{
		//_dp("\n s.DataPattern tbl.SetPattern:"+s.DataPattern+" "+tbl.SetPattern);
		local setPatNum = ( typeof tbl.SetPattern == "string" )? BMvEff.GetPatternNum( { datatype=0, pat=tbl.SetPattern } ) : tbl.SetPattern;
		if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckStartExtendAction ) && !Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CheckEndExtendAction ) )
		{
			if( s.DataPattern != setPatNum )
			{
				Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
			}
			
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_CheckEndExtendAction ); // チェック終了		
		}
		
		if( "EndFrameID" in tbl && s.FrameID == tbl.EndFrameID && s.isFrameUpdate )
		{
			// _dp("\n エクステンドアクションポテンシャル加算");
			// tDDC.Jem_AddCount( _JemCheckType_Ex + 1 ); // エクステンドアクション加算
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ExtendAction ); // エクステンドアクションのＭｖであることを保存
		}
	}
	
		
	return -1;
}

//カメラフォーカスを呼び出しに寄せる
function Battle_Std::SetCamera_Focus_PlayerPosition(tbl)
{
	local pos = BMvTbl.GetPosition( 0 );
	
	("x" in tbl)? tbl.x = pos.x : tbl.x <- pos.x;
	("y" in tbl)? tbl.y = pos.y : tbl.y <- pos.y;
	
	BMvEff.SetCamera_Focus( tbl ); //カメラ固定？
}

function Battle_Std::SetCamera_Focus_EnemyPosition(tbl)
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if(enemy.IsDone)
	{
		BMvCore.PushCharaData( enemy ); // 
			Battle_Std.SetCamera_Focus_PlayerPosition(tbl);
		BMvCore.PopCharaData(); // 
	}
	else
	{
		return 0; //敵取得失敗
	}
}

Battle_Std.GetHanteiRectArray <- function( pos )
{
	switch( pos )
	{
	case "頭":
		return [ _Hantei_Etc, 9 ];
		break;
	case "首":
		return [ _Hantei_Etc, 10 ];
		break;
	case "腹":
		return [ _Hantei_Etc, 11 ];
		break;
	case "足":
		return [ _Hantei_Etc, 12 ];
		break;
	}
}

//メルブラであった投げ開放まとめ
function Battle_Std::ThrowRelease(tbl)
{
	local id = ("id" in tbl)? tbl.id : 0;

	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local isFrameUpdate = ("nocheck_frameupdate" in tbl)? 1 : s.isFrameUpdate;

	local throw_param = {};
	local release_param = {};
	
	if("x" in tbl) throw_param.x <- tbl.x;
	if("y" in tbl) throw_param.y <- tbl.y;
	if("pat" in tbl) throw_param.pattern <- tbl.pat; //意味なさそう
	if("throw_frame" in tbl) throw_param.frame <- tbl.frame;
	if("throw_id" in tbl) throw_param.frameID <- tbl.id;
	if("pos" in tbl)
	{
		throw_param.hantei_rect <- Battle_Std.GetHanteiRectArray( tbl.pos );
	}
	else
	{
		if("rect" in tbl) throw_param.hantei_rect <- tbl.rect;	
	}

	if("type" in tbl) release_param.type <- tbl.type;
	if("airrecover" in tbl) release_param.airrecover <- tbl.airrecover;
	if("flags" in tbl) release_param.flags <- tbl.flags;
	
	if(( id!=0 && s.FrameID==id && isFrameUpdate ) || (id==0 && isFrameUpdate ) )
//	if(( id!=0 && s.FrameID==id && s.isFrameUpdate ) || (id==0 && s.isFrameUpdate ) )
	{
		BMvEff.ThrowParam( throw_param );
		BMvEff.ThrowRelease( release_param );
	}
}


//特殊判定の位置を合わせてつかむ
//フレームIDが14000〜14999までだと発生ｗ
function Battle_Std::ThrowParam_WithHanteiEtc(_pat=0,_frame=0)
{
	local s = BMvTbl.GetMvStatus(); // ステータス取得
	local pat = _pat;
	
	if( _pat==0 )
	{
		if( s.FrameID<14000 || s.FrameID>14999 || !(s.isFrameUpdate) ) return 0; //失敗
		pat = s.FrameID-14000; //相手のパターン番号
	}
	else
	{
	}


	//特殊判定１のsxとの角度をつかみ角度にするよ
	local rc1 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	local setangle =( rc1.sx != _Hantei_Error )? true : false;
	
	for(local i=9;i<13;i++) //特殊判定を順番に見てあったのでつかむ
	{
		local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error ) // 存在するか
		{
			BMvEff.ThrowParam( { pattern=pat, x=rc.sx, y=rc.sy, hantei_rect=[ _Hantei_Etc, i ], frame=_frame } );
			if( setangle )
			{
				//rc.sx,syと rc1.sx,syとの角度を
				local rad = atan2(rc.sy-rc1.sy, rc1.sx-rc.sx);
				local tool_angle = ((rad * 180 / PI)+90)/360*10000;

				//_dm(format("ThrowParam_WithHanteiEtc angle:%d x:%d y:%d , x:%d y:%d",tool_angle, rc.sx, rc.sy, rc1.sx, rc1.sy ));			

				local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
				if( enemy.IsDone )
				{
					BMvCore.PushCharaData( enemy ); // 
						BMvTbl.SetAngle({ angle=tool_angle });
					BMvCore.PopCharaData(); // 
				}
				//BMvEff.StdCall( { type=14, no=pat, param=[ rc.sx,rc.sy,0,0,0, 0,0,0,0,0, 0,0 ]} );
			}
			break; //最初にみつけたので終わる
		}
	}	
}

Battle_Std.DrawHitboxChecker <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_CheckHitbox_Debug" } );
	if(eff.isdone())
	{
		if(eff.push())
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll  } );
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
			eff.pop();
		}
	}
}

Battle_Std.DrawPointRepeat <- function()
{
	local s = BMvTbl.GetMvStatus();
	
	if(s.CallCount==0)
	{
		Battle_Std.DrawPoint({ mvname="Mv_Obj_CharaOrigin_AutoDel_Debug" });
	}
}

Battle_Std.DrawPoint <- function( tbl={} )
{
	local mvname = ("mvname" in tbl)? tbl.mvname : "Mv_Obj_CharaOrigin_Debug";
	local objflags = ("objflags" in tbl)? tbl.objflags : _ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_ParentMuki|_ObjFlags_MukiXPosMove | _ObjFlags_MoveTimeStopAll;
	local procflags = ("procflags" in tbl)? tbl.procflags : _ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete;
	
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_obj_center", mvname=mvname } );
	if(eff.isdone())
	{
		if(eff.push())
		{
			BMvEff.SetObjectFlags( { flags=objflags  } );
			BMvEff.ObjProcFlags_Set( { flags=procflags } );
			eff.pop();
		}
	}
	
	return eff;
}

Battle_Std.DrawRect <- function( tbl={} )
{
	local x = ("x" in tbl)? tbl.x : 100;
	local y = ("y" in tbl)? tbl.y : -100;
	
	local width = ("width" in tbl)? tbl.width : 100;
	local height = ("height" in tbl)? tbl.height : 100;
	
	local color = ("color" in tbl)? tbl.color : 0x000000;
	
	local mvname = ("mvname" in tbl)? tbl.mvname : "Mv_Obj_HitboxBox_Debug";
	local pat = ("pat" in tbl)? tbl.pat : "dbg_rect2";
	
	local eff = BMvEff.CreateObject( { datatype=1, start_pat=pat, x=x*128, y=y*128, mvname=mvname } );
	if(eff.push())
	{
		BMvEff.SetCharaColor( { color=color, time=9999, type=0 } );
		
		BMvTbl.SetScale( { x=width*10000, y=height*10000 } );
		
		eff.pop();
	}
	
	return eff;
}

Battle_Std.DrawHanteiRect <- function( rc, color )
{
	local eff = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=(rc.ex - rc.sx), height=(rc.ey - rc.sy), color=color });
	if(eff.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff.pop();
	}

	return eff;
}

Battle_Std.DrawHanteiRect_Outline <- function( rc, color )
{
	local eff = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=(rc.ex - rc.sx), height=2, color=color, pat="dbg_rect2opaque" });
	if(eff.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff.pop();
	}
	
	local eff1 = Battle_Std.DrawRect({ x=rc.sx, y=rc.sy, width=2, height=(rc.ey - rc.sy), color=color, pat="dbg_rect2opaque" });
	if(eff1.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff1.pop();
	}
	
	local eff2 = Battle_Std.DrawRect({ x=rc.ex+2, y=rc.ey, width=(rc.ex - rc.sx + 2)*-1, height=2, color=color, pat="dbg_rect2opaque" });
	if(eff2.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff2.pop();
	}
	
	local eff3 = Battle_Std.DrawRect({ x=rc.ex, y=rc.ey, width=2, height=(rc.ey - rc.sy)*-1, color=color, pat="dbg_rect2opaque" });
	if(eff3.push())
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround | _ObjFlags_ParentMove | _ObjFlags_MoveTimeStopAll } );
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv|_ObjProcFlag_EraseParentDelete } );
		
		eff3.pop();
	}

	return eff;
}

Battle_Std.DrawHitBoxes <- function()
{
	local s = BMvTbl.GetMvStatus();
	
	local mvcnt = s.MvCount;

	//if(s.CallCount==0)
	
		local frame = s.GetDataFrame();
		local pat = s.GetDataPattern();
		
		for( local i=0; i<8; i++ )
		{	
			local rc2 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Attack, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
			
			if( rc2.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc2, 0xFF4040 );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<8; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc, 0x4040FF );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<15; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect( rc, 0x40FF40 );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		local rccol = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		if( rccol.sx != _Hantei_Error )
		{
			local eff = Battle_Std.DrawHanteiRect( rccol, 0xFFFFFF );
			if(eff.push())
			{
				BMvTbl.SetLP(0,frame);
				BMvTbl.SetLP(1,pat);
				BMvTbl.SetLP(2,mvcnt);
				
				//BMvTbl.SetPrio( _CharaPrio_Near );
				
				eff.pop();
			}
		}
	
}

Battle_Std.DrawHitBoxes_Outlined <- function()
{
	local s = BMvTbl.GetMvStatus();
	
	local mvcnt = s.MvCount;

	//if(s.CallCount==0)
	
		local frame = s.GetDataFrame();
		local pat = s.GetDataPattern();
		
		for( local i=0; i<8; i++ )
		{	
			local rc2 = BMvEff.GetHanteiRect ( { check=[ _Hantei_Attack, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
			
			if( rc2.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc2, 0xFF4040 );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<8; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kurai, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc, 0x4040FF );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		for( local i=0; i<15; i++ )
		{
			local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, i ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			
			if( rc.sx != _Hantei_Error )
			{
				local eff = Battle_Std.DrawHanteiRect_Outline( rc, 0x40FF40 );
				if(eff.push())
				{
					BMvTbl.SetLP(0,frame);
					BMvTbl.SetLP(1,pat);
					BMvTbl.SetLP(2,mvcnt);
					
					//BMvTbl.SetPrio( _CharaPrio_Near );
					
					eff.pop();
				}
			}
		}
		
		local rccol = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool } );
		if( rccol.sx != _Hantei_Error )
		{
			local eff = Battle_Std.DrawHanteiRect_Outline( rccol, 0xFFFFFF );
			if(eff.push())
			{
				BMvTbl.SetLP(0,frame);
				BMvTbl.SetLP(1,pat);
				BMvTbl.SetLP(2,mvcnt);
				
				//BMvTbl.SetPrio( _CharaPrio_Near );
				
				eff.pop();
			}
		}
	
}

//操作親の矩形の座標を取得
Battle_Std.GetHanteiRect_Player <- function( tbl )
{
	local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	BMvCore.PushCharaData( p ); //
		local rc = BMvEff.GetHanteiRect( tbl );
	BMvCore.PopCharaData(); //	

	return rc;
}

//攻撃判定がヒットしてたら特殊判定１の座標に強制移動する半ロック
//重なり判定が重なるとワープし続けるので要修正→相手の座標を調節する処理を追加したので多分OK
//移動の強さを指定できるように
//地上やられでは反応しない
//ダウン追い討ちっぽかったら（pat分岐）飛ばないチェック追加
Battle_Std.SetPosition_DamageHanteiRect <- function( tbl={} )
{
	/* tblスロット
	power 0〜100　：　目標に対してどんだけ寄せるか
	CheckAttackRectFrame : 0,1 攻撃判定があるフレームしか見ない
	distance : 相手との距離がこれ以内だったら寄せる（0だと見ない）
	*/
	local power = ("power" in tbl)? tbl.power : 100;
	local flags = ("flags" in tbl)? tbl.flags : 0;

	//相手との距離チェック
	local pt = Battle_Std.GetPointStatus_NearEnemy();
	if( "distance" in tbl)
	{
		if( pt.distance > tbl.distance ) return 0;
	}
	
	//相手が地上の時は行わない
	//※地上やられで浮いちゃうからね
	local enemy = BMvCore.GetEnemyCharaData(); // 敵の情報を得る			
	
	if( enemy.push() )
	{
		local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1) //地上？
		local isDownOiuti = (BMvTbl.CheckPattern([350,290,348])==1); //ダウンしてる絵への追撃だ？　ダウン追い討ち
		local bound_st = BtlMvStd.GetBoundStatus();
		enemy.pop();

		// 地上 & 地上でも引き寄せじゃない　なら失敗
		if( isGround && !(flags&(1<<2)) ) return 0;
		if( Def_Rule_SkipRock_DownOiuti && isDownOiuti ) return 0; // ダウン追い討ちっぽい

		if( bound_st.isCapture && !(flags&(1<<5)) ) return 0; // 投げられ中は失敗
	}
	else
	{
		return 0;
	}
	
	//ヒットしてたら相手の座標をワープさせる半ロックに
	Battle_Std.MoveEnemyEtcRect( power, flags );
	return 1;
}

// 相手キャラを特殊判定0の座標まで動かす
// flags (1<<0) : X座標無効
// flags (1<<1) : Y座標無効
// flags (1<<2) : 相手が地上でも引き寄せ処理を行う
// flags (1<<3) : 相手が地上で(1<<2)のときに、X座標無効
// flags (1<<4) : 相手が地上で(1<<2)のときに、Y座標無効
// flags (1<<5) : つかみ中でも処理
Battle_Std.MoveEnemyEtcRect <- function( power, _flags=0 )
{
	// local rc = Battle_Std.GetHanteiRect_Player ( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=0 } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		local pos = BMvTbl.CCharaPosition(); //目標
		//向きに応じてsxを使うかexを使うか決める
		pos.y = rc.sy;
		pos.x = ( BMvTbl.GetMuki()==1 )? rc.sx : rc.ex; //右向きならsx、左向きならex

		//posが目的座標
		local tpos = BMvTbl.CCharaPosition(); // ここが最終移動先
		
		local p_kasa = BMvEff.GetHanteiRect( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		local p_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
		
		//enemyからposへの距離座標を出して、powerでかけたのを足した先が目的地になる
		local enemy = BMvCore.GetEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local e_pos_buf = BMvTbl.GetPositionBuffer(1); // 小さい方が左側（たいてい0:左側 1:右側）
			local epos = BMvTbl.GetPosition(); // 位置取得
			local isGround = ( BMvTbl.CheckPosState( _PosState_Ground ) == 1);
			
			enemy.pop();

			local pos2 = BMvTbl.CCharaVector(); // ベクトル情報型の生成
			pos2.x = epos.x;  pos2.y = epos.y; // 始点
			pos2.addx = pos.x;  pos2.addy = pos.y;  // 加算値だけども終点として扱う
			local posst = BMvEff.GetPointStatus( { points=pos2 } ); // 位置情報取得
			
			tpos.x = epos.x + (posst.pos_x*power/100);
			tpos.y = epos.y + (posst.pos_y*power/100);			

			//最後にエラー補正
			//画面外だったら補正
			if( tpos.x > def_POS_GamenHajiX ) tpos.x= def_POS_GamenHajiX;
			if( tpos.x < -def_POS_GamenHajiX ) tpos.x= -def_POS_GamenHajiX;
			
			// 移動先にpl_kasanariがあったら補正をかける
			
			if( enemy.push() )
			{
				local noX = (_flags&(1<<0));
				local noY = (_flags&(1<<1));
				local okGroundXY = (_flags&(1<<2)); // 地上でもこの処理に入ってくる
				local noGroundX = (_flags&(1<<3)); // (1<<2)と一緒に使う
				local noGroundY = (_flags&(1<<4)); // (1<<2)と一緒に使う
				
				local enable = { x=1, y=1 };
				if( noX ) enable.x = 0;//X無効あるならダメ
				if( noY ) enable.y = 0;//X無効あるならダメ
				if( isGround && !okGroundXY )
				{
					enable.x = 0;
					enable.y = 0;
				}
				if( isGround && okGroundXY && noGroundX ) enable.x = 0;
				if( isGround && okGroundXY && noGroundY ) enable.y = 0;
				
				if( enable.x ) // X座標有効
				{
					BMvTbl.SetPosition( { x=tpos.x } );
				}
				if( enable.y ) // Y座標有効
				{
					BMvTbl.SetPosition( { y=tpos.y } );
				}
				
				local e_kasa = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=0 } );
				if( p_kasa.sx != _Hantei_Error && e_kasa.sx != _Hantei_Error )
				{
					// 重なっているかチェック
					// if( p_kasa.sx > e_kasa.sx && )
					// bool bCross = !(xmn1 > xmx2 || xmn1 > ymx2 || xmx1 < xmn2 || ymx1 < ymn2);
					if( !(p_kasa.sx > e_kasa.ex || p_kasa.sy > e_kasa.ey || p_kasa.ex < e_kasa.sx || p_kasa.ey < e_kasa.sy) )
					{
						// _dp("\n 重なってる");
						local pos_side = ( p_pos_buf < e_pos_buf )? 0 : 1; // 0:自分|相手 1:相手|自分
						local c_pos = BMvTbl.GetPosition(); // 位置取得
						local same_pos = (p_kasa.sx == e_kasa.sx)? 1 : 0;//同じ座標のときだけ、pos_side(1F前の位置関係)を参照する
						// _dpn("座標:"+p_kasa.sx+","+e_kasa.sx);
						if( p_kasa.sx > e_kasa.sx || (same_pos && pos_side == 1) ) // E P
						{
							// _dp("\n EP:"+(e_kasa.ex - p_kasa.sx)/128 );
							c_pos.x -= e_kasa.ex - p_kasa.sx;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
						else // P E
						{
							// _dp("\n PE:"+(e_kasa.sx - p_kasa.ex)/128 );
							c_pos.x -= e_kasa.sx - p_kasa.ex;
							BMvTbl.SetPosition( { x=c_pos.x } ); // 調整
						}
					}
					
				}
				
				enemy.pop();
			}
			// Battle_Std.SetEnemyPosition( tpos );
			
			//_dem(format("x:%d y:%d x:%d y:%d",pos.x,pos.y,tpos.x,tpos.y));
			
			//重なり同士が重なっていたら補正？
			//操作親だけでいいのか？
		}
	}
}



//配列だったらランダム抽選　違ったらそのまま返す
Battle_Std.array_rand <- function( foo )
{
	//print("\nfoo:"+foo);
	switch( typeof foo )
	{
	case "array":
		//print("\n配列だわ");
		return foo[ BMvEff.Random_Limit(foo.len()) ];
		break;
	default:
		//print("\nそのままー");
		return foo;
		break;
	}
}


//ゲーム座標を呼び出しからのオフセット座標に変換
Battle_Std.GamePos2ShiftPos <- function( pos )
{
	local me = BMvTbl.GetPosition(0);
	local sa = BMvTbl.CCharaPosition();
	sa.x = pos.x - me.x;
	sa.y = pos.y - me.y;
	//左向きの時は目標Ｘを反転
	if( BMvTbl.GetMuki()!=1 )
	{
		sa.x *= -1; 
	}
	return sa;
}

local get = function(tbl, x)
{
	return (x in tbl)? tbl[x] : 0;
}

Battle_Std.DrawBladeEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), pat=tbl.pat, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}

// Param0 == 10 の時SEを再生するオブジェクトを呼び出す関数
Battle_Std.Call_FootStepSE <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_Null_PlayFootstepSE" } ); //足音再生監視オブジェクト
	if( eff.push() )
	{
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
		
		eff.pop();
	}
}

//画面全体エフェクト
Battle_Std.ScreenEffect <- function( tbl={} ) : (get)
{
	local pos = 
	{
		x=get(tbl,"x"),
		y=-360*128 + get(tbl,"y")
	}
	local ret = Battle_Std.CreateObjectEX( { datatype=("datatype" in tbl)? tbl.datatype : 0, pat=tbl.pat, mvname=("mvname" in tbl)? tbl.mvname : "", 
	objectflags=_ObjFlags_NoGround|_ObjFlags_NoCamera
	initfunc = function() : (pos)
	{
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
	}
	} );
	return ret;
}

Battle_Std.ScreenEffect_LimitMv <- function( tbl={} )
{
	local e = Battle_Std.ScreenEffect( tbl );
	BMvCore.PushCharaData( e );	
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
	BMvCore.PopCharaData();
	return e;
}

Battle_Std.DrawIncreaseEffect <- function( tbl={} ) : (get)
{
	Battle_Std.CreateObjectEX( { x=get(tbl,"x"), y=get(tbl,"y"), datatype=1, pat=26, flags=_Position_ToolShift,
	objectflags=_ObjFlags_ParentMove|_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround
	} );
}


//CreateObjectの拡張
Battle_Std.CreateObjectEX <- function( tbl )
{

//	datatype		0:自分 1:汎用
//	x			X座標
//	y			Y座標
//	setx			ゲームX座標(Xはオフセット座標になる)
//	sety			ゲームY座標(Yはオフセット座標になる)
//	mvname		行動文字列
//	pat			初期パターン文字列可、配列可（配列の場合ランダムになる）
//	FrameID		初期フレームID、配列可（配列の場合ランダムになる）
//	flags		同じ
//	objectflags	SetObjectFlagsするもの
// 	objprocflags	ObjProcFlags_Setするもの
//	initfunc		呼び出してすぐにやりたい関数
//	angle		見た目角度
//	LP			LPSetを行う

	//CreateObjectに渡すテーブル
	local _x = ("x" in tbl)? tbl.x : 0;
	local _y = ("y" in tbl)? tbl.y : 0;
	
	//とりあえず最初にCreateObjectするときのテーブル
	//そのあとPushCharaDataして色々やる
	local o = 
	{
		datatype = ("datatype" in tbl)? tbl.datatype : 0,
		x = _x,
		y = _y,
		mvname = ("mvname" in tbl)? tbl.mvname : "",
		flags = ("flags" in tbl)? tbl.flags : 0
	}
	
	local _flags = ( (o.flags&_Position_ToolShift)!=0 )? _Position_CaptureShift : 0;

	local pat = 0;
	if( "pat" in tbl )
	{
		pat = Battle_Std.array_rand( tbl.pat );
		o.start_pat <- pat; //初期patを指定する <- なのは、スロットが無いのと0指定では挙動が違うらしいので
		//print("\n★これやろ？"+pat);
	}
	local FrameID = ( "FrameID" in tbl )? Battle_Std.array_rand( tbl.FrameID ) : 0;

//	print("\n pat:"+pat+" ID:"+FrameID);

	local e = BMvEff.CreateObject( o );	
	if( e.push() )
	{
		if( "objectflags" in tbl ) BMvEff.SetObjectFlags({ flags=tbl.objectflags });
		if( "objprocflags" in tbl ) BMvEff.ObjProcFlags_Set( { flags=tbl.objprocflags } );
		//if( pat!=0 ) BMvTbl.SetPattern( pat );
		if( FrameID!=0 ) BMvTbl.JumpFrameID( FrameID );
		if( "angle" in tbl )
		{
			if( tbl.angle=="rand" )
			{
				BMvTbl.SetAngle( { angle=BMvEff.Random_Limit(10000) } );				
			}
			else
			{
				BMvTbl.SetAngle( { angle=tbl.angle } );
			}
		}
		if( "initfunc" in tbl ) tbl.initfunc();
		if( "LP" in tbl )
		{
			BMvTbl.SetLP(tbl.LP.slot, tbl.LP.val);
		}
		if( "setx" in tbl )
		{
			BMvTbl.SetPosition( { x=tbl.setx, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		if( "sety" in tbl )
		{
			//_dm("くる？ y:"+_y);
			BMvTbl.SetPosition( { y=tbl.sety, flags=_flags } );
			BMvTbl.SetPosition( { x=_x, y=_y, flags=_flags|_Position_Add|_Position_ChangeMuki } )
		}
		
		e.pop();
	}
	return e; //一応つくったオブジェクトをかえそう
}

//ホーミング一応動いてるけど…
Battle_Std.DivHomingTarget <- function( tbl )
{
	// tbl
	// core = ターゲット 
	// x,y = オフセット座標
	// frame
	
	//ターゲットめがけて動く
	if( tbl.core.IsDone ) // 有効かどうか一応チェック
	{
		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //操作親の座標を取得
			local oya_muki = BMvTbl.GetMuki(); //親の向き
		BMvCore.PopCharaData(); //	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128;
	
		pos.x += offx;
		pos.y += offy;
	
		local posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		local speed = (posst.distance/tbl.frame)*2;
		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );

		//_dm("Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		BMvTbl.SetVector( { x=v.x, y=v.y, addx=-v.x/tbl.frame, addy=-v.y/tbl.frame, flags=_Vector_DivKeep|_VecFlag_NoMuki } );				
		// ※ posst.angle は浮動少数点なので整数として使わないといけない場合はきっちり変換すること
	}

}

//ホーミング一応動いてるけど…
Battle_Std.HomingTarget <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// 
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local vec;
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
		BMvTbl.SetVector( { x=v.x, y=v.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );				
		vec = BMvTbl.GetVector(0);
		//_dm(format(" x:%d y:%d",vec.x, vec.y ));
	}
}

//ホーミング処理少し調整版
Battle_Std.HomingTarget2 <- function( tbl )
{
	// tbl
	// posst	BMvEff.CPointStatus() 目標座標（これかcoreの二択）
	// core = ターゲット 
	// x,y = オフセット座標
	// frame ※frameかspeedかどっちか
	// speed
	// addangle_max １Ｆで許せる方向転換角度（急転換しないように）
	
	local do_flag = false;
	local posst;
	
	if( "posst" in tbl ) //指定座標へ飛ぶ
	{
		posst = tbl.posst;
		do_flag = true;
	}
	else if( tbl.core.IsDone ) // 指定ターゲットに飛ぶ
	{
		local my_pos = BMvTbl.GetPosition(0);

		//親の情報を取得
		BMvCore.PushCharaData( tbl.core ); //
			local pos = BMvTbl.GetPosition(0); //座標を取得
			local oya_muki = BMvTbl.GetMuki(); //向き
		BMvCore.PopCharaData(); //	
		
		local oya_zyouge = (pos.y>my_pos.y)? -1 : 1;	

		local offx = tbl.x*128*oya_muki;			
		local offy = tbl.y*128; //*oya_zyouge;
	
		pos.x += offx;
		pos.y += offy;
	
		posst = BMvEff.GetPointStatus( { position=pos } ); // 位置情報取得
		
		do_flag = true;
	}
	
	if( do_flag )
	{
	
		//
		/*
		スピード	(100/20)*2

		距離		100
		frame	20
		
		*/
		
		local speed = tbl.speed;
		if( "frame" in tbl )
		{
			speed = posst.distance/tbl.frame
		}
		
		if( speed<tbl.minSpeed ) speed = tbl.minSpeed; //最低スピード保障

		local addvec = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = speed, } );
		

		

		//_dm("angle:"+posst.angle+" Spedd:"+speed+" dis:"+posst.distance+" x:"+v.x+" y:"+v.y );
		
		// posst.distance/tbl.speed/tbl.frame
		local nowvec = BMvTbl.GetVector(0);
		
		local setvec = BMvTbl.CCharaVector();
		setvec.x = nowvec.x + addvec.x*BMvTbl.GetMuki();
		setvec.y = nowvec.y + addvec.y;
		
	
		if( "addangle_max" in tbl )
		{
			local safe = tbl.addangle_max;
			
			local nowangle = BMvEff.GetAngle_FromVector( { x=nowvec.x, y=nowvec.y } );
			local setangle = BMvEff.GetAngle_FromVector( { x=setvec.x, y=setvec.y } );
			local sa = (setangle.angle - nowangle.angle);
			if( sa >=  1.0 ) sa = 2.0 - sa;
			if( sa <= -1.0 ) sa = 2.0 + sa;
				
			if( sa > safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle+safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else if( sa < -safe ) //|| sa < -0.05 )
			{
				local addvec = BMvEff.GetVector_FromAngle( { angle = nowangle.angle-safe, speed = speed } );
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
			else
			{
				BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
			}
		}
		else
		{
			BMvTbl.SetVector( { x=addvec.x, y=addvec.y, flags=_VecFlag_Add|_VecFlag_NoMuki } );
		}
	}
}

//今のベクトルから角度を設定する
Battle_Std.SetAngle_fromVector <- function()
{
	/*
	local vec = BMvTbl.GetVector(0);	
	
	local rad = atan2(vec.y, vec.x);
	local angle = ((rad * 180 / PI)+90)/360*2.0;
	
	//local angle = tool_angle/5000.0;
	
	BMvTbl.SetAngle( { angle_float=angle });
	*/
	
	local vec = BMvTbl.GetVector(0);	
	local cpst = BMvEff.GetAngle_FromVector( { x=vec.x, y=vec.y } );
	BMvTbl.SetAngle( { angle_float=cpst.angle } );

}

//パターン内のみ継続の演出系画面全体オブジェクト
Battle_Std.ScreenEffect_LimitPat <- function( tbl )
{
	local e = Battle_Std.ScreenEffect( tbl ); //画面におくエフェクト
	if( e.IsDone )
	{
		BMvCore.PushCharaData( e );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_PatChangeNoLanding } );
		BMvCore.PopCharaData();
	}
	return e;
}

Battle_Std.DrawEffect_LimitPat <- function( tbl )
{
	tbl.flags <- _Position_ToolShift;
	tbl.objectflags <- _ObjFlags_EraseParentPatChange|_ObjFlags_NoGround|_ObjFlags_PatChangeNoLanding;
	
	return Battle_Std.CreateObjectEX( tbl );
}

//何かでキャンセルしなかった場合追撃不能にする（LastUpdate用）
//キャンセルしない追撃なんて考えられない
//相手が先に動き出すようなものでは使ってはいけない（使うときは追撃不能命令を入れない）
//行動可能のフリーモーションだとダメそう→修正(大丈夫これ？)
Battle_Std.NoCansel_NoAttackHit <- function( tbl={} )
{
	local hosei_uwagaki = ("上書き補正" in tbl)? tbl["上書き補正"] : 80; //デフォルト上書き補正
	local hosei_zyozan = ("乗算補正" in tbl)? tbl["乗算補正"] : 90; //デフォルト乗算補正
	local no_atk_hit = ("noattackhit" in tbl)? tbl.noattackhit : 1; //追撃不能にするかどうか　デフォは1

	//NoAttackHit
	if( Battle_Std.CheckNoCansel() ) //キャンセルしないでFinalizeした
	{
		// フリーモーションを除外するため、行動可能からの抜けも含めた
		// _dm("NoCansel_NoAttackHit キャンセルしなかった");
		if( no_atk_hit==1 ) //追撃不可にする
		{
			Battle_Std.EnemyNoAttackHit(); // 相手を追撃不能にする
		}
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("NoCansel_NoAttackHit キャンセルした");
		//レインコンボもここなのがやや怖いので強制的に基底＋乗算補正をかける
		BMvEff.StdCall( { type=6, no=112, param=[ hosei_uwagaki,0,0,0,0, 0,0,0,0,0, 0,0 ]} ); //上書き８０
		BMvEff.StdCall( { type=6, no=112, param=[ hosei_zyozan,1,0,0,0, 0,0,0,0,0, 0,0 ]} ); //乗算９０
		
		// レインコンボのみの取得はできない（LastUpdateで被ダメかどうかを検知できない）
	}
}

//相打ち時は、!BMvTbl.FromFinalize()で行動不能なので0を返すため注意
Battle_Std.CheckNoCansel <- function()
{
	if( BMvTbl.FromFinalize() || !BMvTbl.FromFinalize() && BCMDTbl.CheckCancel(_SkillType_None) ) //キャンセルしないでFinalizeした
	{
		return 1;
	}
	return 0;
}

Battle_Std.EnemyNoAttackHit <- function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();

		// short BtlMvStd::MvBoundStatus::isBound
		// 0 --- のけぞり状態でない
		// 1 --- のけぞり状態
		// 2 --- のけぞり状態でガードしている

		//のけぞりorつかまれ
		if( bs.isBound == 1 || bs.isCapture != 0 )
		{
			BMvTbl.SetWallCount( 100 ); //追撃不能状態にする
			// _dm("追撃不能にされました");
		}
		//_dm("チェック");
		
		enemy.pop();
	}
}

//投げ系のＭｖを途中でキャンセルする時つかみを開放する
Battle_Std.ThrowMv_CanselRelease <- function( tbl={} )
{
	//NoAttackHit
	if( BMvTbl.FromFinalize() ) //キャンセルしなかった
	{
		//print("\nキャンセルしなかった");
		return 0; //キャンセルしなかったので開放しない
	}
	else //キャンセルした、やられで途中でとまったとか
	{
		// _dm("ThrowMv_CanselRelease キャンセルした");
		if( "nocheck_frameupdate" in tbl )
		{
		}
		else
		{
			tbl.nocheck_frameupdate <- 1; //フレームアップデートをチェックしない
		}
		Battle_Std.ThrowRelease( tbl );
		return 1; //キャンセルされたので開放した
	}
}

//ジャンプ攻撃Initでステータス設定
//ジャンプ攻撃（着地のMvが変化する攻撃）のMvからしかよんではいけない
Battle_Std.SetStatus_AirAtkStatus <- function()
{
	BMvTbl.SetPP(def_PP_AirAtkStatus,0); //ジャンプ攻撃ステータス初期化
	BMvTbl.SetPP(def_PP_AssultOverHeadFrame,100);//早い中段への補正を初期化
	
	Battle_Std.MoveCode.AddFlag( def_MC_EnableAirAtkStatus ); // AirAtkStatusが有効なMvとする
	
	//アサルトから飛んできたらフラグを立てる	
	local mvs = BMvTbl.GetMvStatus();
	local mvs_DataPattern = mvs.DataPattern;
	if( mvs_DataPattern==def_PAT_Mv_Assault || mvs_DataPattern==def_PAT_Mv_Assault_Dodge || Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_StdAssult ) || Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_AirAssult ) )
	{
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_inAssault ); // 各種アサルトからフラグを立てる
		
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_FromAssault ); // アサルトから
		
		local isAirAssult = Battle_Std.ChangeMoveCodeEx_CheckFlag( 7, def_MC7_AirAssult )? 1 : 0;
		
		//MEMO:LPの指定はもういらないと思うけど、念の為残している
		local type = BMvTbl.GetLP(1); //アサルトのmvからなら設定されているはず
		if( type==1 || isAirAssult ) //空中アサルトだったら
		{
			//空中ダッシュ的に使うのでキャンセル不可は設定しない
			Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_inAirAssault ); // 空中アサルトからフラグを立てる
		}
		else //空中アサルト以外のアサルトは、ジャンプ攻撃にキャンセル不可を設定するのだよ（チェインシフトだけは可能にしておく）
		{
			BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv }); //キャンセル不可
			
			if( !Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_StdAssultIgnoreNoMove ) )
			{
				BMvTbl.SetMoveableFlag( { move=0,time=254, flag=_ClearFlag_ChangeMv }); //着地のMvに行くまで行動不能にする
				Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_StdAssultLimitAirAtk );//行動不能なのをフラグたて
			}
			BMvTbl.SetAsFlag( { as_flags=_AsFlag_ChainShift, time=254, flag=_ClearFlag_ChangeMv } );
			// if( Def_Dbg_AirAtkFlag ) _dm("アサルトによるキャンセル不可");
		}
	}
	
	//のぼりで出したらロケッティアフラグを立てるのだよ
	//ジャンプから出したものじゃないとフラグは立たない（ＣＳ使ったりアサルトからだとフラグは立たない）
	local pos = BMvTbl.GetPosition(); // 位置取得
	local vec = BMvTbl.GetVector(); //ベクトル取得
	local from_jump = ( // ジャンプから出したか
	mvs_DataPattern==def_PAT_Jump_F ||
	mvs_DataPattern==def_PAT_Jump_N ||
	mvs_DataPattern==def_PAT_Jump_B ||
	mvs_DataPattern==def_PAT_MultiJump_F ||
	mvs_DataPattern==def_PAT_MultiJump_N ||
	mvs_DataPattern==def_PAT_MultiJump_B ||
	Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_Jump ) )? 1 : 0;
	
	// print("\n mvs.MvCount:"+mvs.MvCount );
	// _dp("\n from_jump : "+from_jump+" pos.y:"+pos.y/128 );
	
	// TODO:
	// 着地際に発生が遅い攻撃を出した（本来は空振りするようなフレーム）
	// なのに相手にヒットするような場合は、着地際ため攻撃での崩しのはずである
	// 「停滞する遅いジャンプ攻撃」を検知する
	// 空中行動で、何フレーム後に着地予定かを計算していけば
	// 流星パンチみたいなのも同様に検知はできるはず
	
	// 切り替え中段自体無くすことも可能？
	// 攻撃があたる直前にチェックしないとダメなのでもう１段階処理が必要かな
	
	// 前のMvを取得して行動チェック
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_AirAtkGuardHosei ) && mvs.MvCount<21 )
	{
		_dp("\n ジャンプ攻撃を上段に修正")
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
	}
	
	//print("\n vec.y"+vec.y+" pos.y:"+pos.y+" tooly:"+pos.y/128);
	if( from_jump==1 && vec.y < 0 && pos.y > -180*128 ) //のぼり中段の条件なのだよ
	{
		// if( Def_Dbg_AirAtkFlag ) _dm("ロケッティアフラグ");
		Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_Rocketeer ); // ロケッティアフラグ
	}
	
	// アサルト以外のロケッティアは屈ガード可能に
	local airatk_st = BMvTbl.GetPP(def_PP_AirAtkStatus);
	// ロケッティアフラグ　＆　アサルトからは除外　＆ＭｖＣｏｕｎｔが一定値以下
	// 地上からの攻撃じゃないとロケッティアフラグは無い方がいいんじゃないかなぁ
	if( ( ( airatk_st&def_PP_AAS_Rocketeer )!=0 ) && ( (airatk_st&def_PP_AAS_inAssault) ==0 ) && mvs.MvCount<21 )
	{
		//ロケッティアならしゃがみガード可能なのだよ
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
		// if( Def_Dbg_AirAtkFlag ) _dm("アサルト以外のロケッティアによる上段化(18F)");
	}
	else if( Battle_Std.IsMatchChangeMvNameArray( ["Mv_Jump_F", "Mv_Jump_N", "Mv_Jump_B"] ) )
	{
		//限定的に垂直ジャンプからの上段処理を入れる
		local jumpF = BMvTbl.GetPP(def_PP_JumpFrame);//上記MVからならこの値がセットされている
		
		local limitMinF = 18;
		local setF = limitMinF - jumpF;
		if( setF > 0 )
		{
			_dpn("早すぎしゃがみに空振り予約:"+setF+" _GuardFlag_ThroughCrouch:"+_GuardFlag_ThroughCrouch);
			Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_ZyodanAirAtk );
			// BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=setF, flag=_ClearFlag_ChangeMv } );
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughCrouch, time=setF, flag=_ClearFlag_ChangeMv } );
		}
	}
}

//行動コード関係
Battle_Std.MoveCode <- {};

//行動コードフラグを加える
Battle_Std.MoveCode.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MoveCode.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
//複数書くとどれか一つでも立ってれば成功
Battle_Std.MoveCode.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//拡張行動コード関係 ※フラグ間違えないようにMoveCode1とかにした
Battle_Std.MoveCodeEx <- {};

//拡張行動コードフラグを加える
Battle_Std.MoveCodeEx.AddFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )|flag );
}

//拡張行動コードフラグを消す
Battle_Std.MoveCodeEx.DelFlag <- function( pos, flag )
{
	BMvTbl.SetMoveCodeEx( pos, BMvTbl.GetMoveCodeEx( pos )&~flag );
}

//拡張行動コードフラグが立ってるかチェックする
Battle_Std.MoveCodeEx.CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//前の行動
//拡張行動コードフラグが立ってるかチェックする
Battle_Std.ChangeMoveCodeEx_CheckFlag <- function( pos, flag )
{
	return( ( (BMvTbl.ChangeMv_GetMoveCodeEx( pos )&flag)!=0 )? 1 : 0 );
}

//行動コード関係（プログラム差し替え用）
Battle_Std.MvAction <- {};

//行動コードフラグを加える
Battle_Std.MvAction.AddFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()|flag );
}

//行動コードフラグを消す
Battle_Std.MvAction.DelFlag <- function( flag )
{
	BMvTbl.SetMoveCode( BMvTbl.GetMoveCode()&~flag );
}

//行動コードフラグが立ってるかチェックする
Battle_Std.MvAction.CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetMoveCode()&flag)!=0 )? 1 : 0 );
}

//汎用全体ステータス関係（全体を初期化されることは無い）
Battle_Std.GS_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)|flag )
}

Battle_Std.GS_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_GlobalStatus, BMvTbl.GetPP(def_PP_GlobalStatus)&~flag )
}

Battle_Std.GS_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_GlobalStatus)&flag)!=0 )? 1 : 0 );
}

Battle_Std.EnemyGS_CheckFlag <- function( flag )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = Battle_Std.GS_CheckFlag(flag);
		enemy.pop();
	}
	return ret;
}

//BMvCore関係
Battle_Std.Core <- {};

Battle_Std.Core.Push <- function( core )
{
	//Pushしなかったら0を返す
	if( core.IsDone )
	{
		return BMvCore.PushCharaData( core );
	}
	return 0;
}

//coreにfuncをやって戻り値を返す
//戻り値はテーブルじゃないとダメ
Battle_Std.Core.FuncPush <- function( core, func )
{
	local ret = 
	{
		IsDone = 0,
	}
	if( core.IsDone )
	{
		if( BMvCore.PushCharaData( core ) )
		{
			ret = func();
			ret.IsDone <- 1;
		}
		BMvCore.PopCharaData();
	}
	return ret;
}

// 通常技や必殺技のInitで呼ばれる
// 影響範囲が大きいので扱いには注意する
Battle_Std.InitAtkSkillMv <- function()
{
	Battle_Std.SmartSteer.ClearCheck();
	Battle_Std.SetComboChainMvParam();
}

// スマートステア関係
Battle_Std.SmartSteer <- {};

// 通常技や必殺技のInitで呼ばれる
// スマートステア以外のコマンドを入れたらComboChainのPPを初期化する
Battle_Std.SmartSteer.ClearCheck <- function()
{
	local cmdNum = BMvTbl.GetCmdNumber();
	// _dp("\n cmdNum:"+cmdNum );
	if( cmdNum == 0 ) return 0; // 状態以降とか、コマンドを入れずに飛んできたらここ
	if( cmdNum >= def_CN_SmartSteer_00 && cmdNum <= (def_CN_SmartSteer_00+def_CNP_SmartSteerNumMAX) )
	{
		// _dp("\n スマートステア");
		// スマートステア
		return 0;
	}
	else
	{
		// _dp("\n コマンド入れたね");
		if(Def_Dbg_SmartSteerLog) _dp("\n スマートステア関係ないコマンドを出したらリセット");
		BMvTbl.SetPP(def_PP_StdComboChain,0);
		BMvTbl.SetPP(def_PP_CroComboChain,0);
		BMvTbl.SetPP(def_PP_AirComboChain,0);
		return 1; // クリアしました
	}
	return 0;
}

Battle_Std.SmartSteer.CheckBonus <- function( type=1/* 1:Std 2:Cro 3:Air */ )
{
	local combo_chain = 0;
	switch( type )
	{
	case 1:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain);
		break;
	case 2:
		combo_chain = BMvTbl.GetPP(def_PP_StdComboChain); // def_PP_CroComboChain
		break;
	case 3:
		combo_chain = BMvTbl.GetPP(def_PP_AirComboChain);
		break;
	}
	
	/*
	if( Def_Dbg_SmartSteerLog )
	{
		_dp1p("\n[CheckBonus]"+
		" PPtype:"+type+
		" Std:"+BMvTbl.GetPP(def_PP_StdComboChain)+
		" Cro:"+BMvTbl.GetPP(def_PP_StdComboChain)+ // def_PP_CroComboChain
		" Air:"+BMvTbl.GetPP(def_PP_AirComboChain)+
		" combo_chain:"+combo_chain
		);
	}
	*/
	
	local cmdParam = BMvTbl.GetCmdParam(0);
	if( cmdParam&Def_CMDP_ComboChain )
	{
		//アナウンス
		if( def_AISW_SmartSteer ) BMvEff.AttackInfoString_Set({ word=def_AISW_SmartSteer,} );

		//【トロフィー】実戦でスマートステアを使用した。
		BMvTbl.Achievement_Unlock(0);

		return 1;
	}
	return 0;
}

Battle_Std.SetComboChainMvParam <- function()
{
	local cmdParam = BMvTbl.GetCmdParam(0);
	if( cmdParam&Def_CMDP_StdComboChain )
	{
		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_CallComboChainMv );
	}
}

//Cmd関係
// 通常技を出すときにチェックする内容
Battle_Std.CancelCheck_NormalAtk <- function()
{
	if( Def_Dbg_AllMoveAddCommand ) return 1;
	if( Def_Rule_CmdCancelCheck )
	{
		// 行動不能の時（キャンセルの時）
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//必殺技の時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill ) )
			{
				// 必殺技から通常技へのキャンセルを許容する、じゃないとダメ
				if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoAtk ) )
				{
					return 0;
				}
			}
			// 通常技へのキャンセルを除外するフラグがあったらそもそも失敗
			if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_NoAtkCansel ) )
			{
				return 0;
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
		if( Battle_Std.MoveCode.CheckFlag( def_MC_JumpCanselOnly ) ) return 0;
	}
	return 1;
}

// 必殺技を出すときにチェックする内容
Battle_Std.CancelCheck_SpecialSkill <- function()
{
	if( Def_Dbg_AllMoveAddCommand ) return 1;
	if( Def_Rule_CmdCancelCheck )
	{
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//必殺技or通常投げの時は不可
			if( Battle_Std.MoveCode.CheckFlag( def_MC_Skill|def_MC_Throw ) )
			{
				if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoSkill ) )
				{
					return 0;
				}
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}

// ＥＸ必殺技を出すときにチェックする内容
Battle_Std.CancelCheck_EXSpecialSkill <- function()
{
	if( Def_Dbg_AllMoveAddCommand ) return 1;
	if( Def_Rule_CmdCancelCheck )
	{
		if( BCMDTbl.CheckCancel( _SkillType_None ) == 0 )
		{
			//ＥＸ必殺技・ＳＰ必殺技の時は不可
			local mvcode = BMvTbl.GetMoveCode();
			if( mvcode&def_MC_Skill && ( mvcode&def_MC_EXAction || mvcode&def_MC_SPAction ) )
			{
				if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableCansel_SkilltoSkill ) )
				{
					return 0;
				}
			}
		}
		if( Battle_Std.GS_CheckFlag( def_PP_GS_NoAct_Atk ) ) return 0;
	}
	return 1;
}



// この辺基本的にサポートキャンセルのチェックにしか使ってないっぽい
Battle_Std.MvRule_Skill_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
	if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_SetMutekiDamage ) )
	{
		local isDamage = (hs.Type & _HitType_Damage && hs.isCatchFlag == 0);
		if( isDamage )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=60, muteki_dage=60 } ); //ヒットしたら無敵で上書き
		}
	}
}

Battle_Std.MvRule_Skill_LastUpdate <- function()
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_SetMutekiDamage ) )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //無敵状態を解除
	}
}

Battle_Std.MvRule_Atk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.Type & _HitType_Damage )
	{
		//print("\nダメージした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Damage );
	}
	else if( hs.Type & _HitType_Guard )
	{
		//print("\nガードした！");
		Battle_Std.MoveCode.AddFlag( def_MC_HitStatus_Guard );				
	}
}

// ↑と合わせて呼ばれる
// ジャンプ攻撃
Battle_Std.MvRule_AirAtk_HitInterrupt <- function()
{
	local hs = BMvTbl.GetMvHitStatus();
	if( hs.isFirstUpdate )
	{
		if( Def_Rule_GameSystem == Def_RGS_CLI )
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}

local callmvname_ar = ["Mv_SupportCharaWait", "Mv_SupportCharaWait2"];

Battle_Std.CallSupport <- function() : (callmvname_ar)
{
}

Battle_Std.CallCancelSupport_Effect <- function()
{
}

Battle_Std.CallSupport_Effect <- function()
{
}

// キャンセルサポート呼べるかどうかざっくりチェック
Battle_Std.CheckSt_CancelSupportCall <- function()
{
}

// ゲージを使ってモーション無しで呼び出す
Battle_Std.CheckandCall_CancelSupport <- function( _spcost=10000 )
{
}

// 切り札効果中とかでモーション無しで呼び出す
Battle_Std.CheckandCall_NoMotionSupport <- function()
{
}

Battle_Std.CheckandCall_GuardCancelSupport <- function()
{
}


// 体力差を取得　0:取得失敗orドロー +:体力勝ち -:体力負け
Battle_Std.GetHPBalance <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	
	if( player.isdone() && enemy.isdone() )
	{
		local myhp = -1;
		local enhp = -1;
		if( player.push() )
		{
			myhp = BMvEff.SetHpGauge( { value=0 } );
			player.pop();
		}
		if( enemy.push() )
		{
			enhp = BMvEff.SetHpGauge( { value=0 } );
			enemy.pop();
		}
		if( myhp != -1 && enhp != -1 )
		{
			return (myhp - enhp);
		}
	}
	return 0;
}

// コンボポイントを乗算
Battle_Std.ComboPoint_Multi <- function( _par )
{
	local cp = BMvTbl.ComboPoint_Calc( { num=0 } );

	local calccp = cp * _par / 100;
	if( calccp < 0 ) calccp = 0; // 下限
	if( calccp > 100 ) calccp = 100; // 上限

	local addcp = calccp - cp;
	if( addcp < -100 || addcp > 100 ) return 0; // 失敗
	
	BMvTbl.ComboPoint_Calc( { num=addcp } );
	
	// _dp("\n CPM計算:"+cp+" -> "+calccp +" (x"+ _par+"%)" );
	return 1;
}
// 体力差を取得　0:取得失敗orドロー +:体力勝ち -:体力負け
Battle_Std.GetHPBalance <- function()
{
	local player = BMvCore.GetPlayerCharaData();
	local enemy = BMvCore.GetEnemyCharaData();
	
	if( player.isdone() && enemy.isdone() )
	{
		local myhp = -1;
		local enhp = -1;
		if( player.push() )
		{
			myhp = BMvEff.SetHpGauge( { value=0 } );
			player.pop();
		}
		if( enemy.push() )
		{
			enhp = BMvEff.SetHpGauge( { value=0 } );
			enemy.pop();
		}
		if( myhp != -1 && enhp != -1 )
		{
			return (myhp - enhp);
		}
	}
	return 0;
}

// コンボポイントを乗算
Battle_Std.ComboPoint_Multi <- function( _par )
{
	local cp = BMvTbl.ComboPoint_Calc( { num=0 } );

	local calccp = cp * _par / 100;
	if( calccp < 0 ) calccp = 0; // 下限
	if( calccp > 100 ) calccp = 100; // 上限

	local addcp = calccp - cp;
	if( addcp < -100 || addcp > 100 ) return 0; // 失敗
	
	BMvTbl.ComboPoint_Calc( { num=addcp } );
	
	// _dp("\n CPM計算:"+cp+" -> "+calccp +" (x"+ _par+"%)" );
	return 1;
}

Battle_Std.SoundStatus_CheckFlag <- function( _flag )
{
	return( BMvTbl.GetPP(def_PP_SoundStatus)&_flag ); // フラグチェック
}

Battle_Std.SoundStatus_AddFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)|_flag ); // フラグ追加
}

Battle_Std.SoundStatus_DelFlag <- function( _flag )
{
	BMvTbl.SetPP( def_PP_SoundStatus, BMvTbl.GetPP(def_PP_SoundStatus)&~_flag ); // フラグ消去
}


// 同時押しチェック
// 同時押しで強引に行動不能中も技を受け付けるフレームの猶予を消す
Battle_Std.ClearDoujiDelay <- function()
{
	BMvTbl.SetPP( def_PP_NoneDouji, 0 );
	BMvTbl.SetPP( def_PP_SpecialDouji, 0 );
	BMvTbl.SetPP( def_PP_ExSpecialDouji, 0 );
}

// IWE発動後一発殴るだけのオブジェクトを呼ぶ
// BoundCapture状態だと相手にベクトルが入らないため
Battle_Std.IWEXIST_CallOnePunch <- function()
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat=980 } );
}

// 自分のGRDを消費する
// 不足時はenemyadd分を相手に加算する
// costは個数、enemyaddは１個10000ポイントで単位が違うので注意
Battle_Std.UseGRDStock <- function( cost, enemyadd=0 )
{
	// _dp("\n GRD:"+cost+"消費 (相手増加:"+enemyadd+")" );
	if( BMvEff.GRD_CheckStock( { val=cost } ) ) //コストが足りている場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費
	}
	else //コストが足りない場合
	{
		BMvEff.GRD_UseStock( { val=cost } ); //消費して空にする
		
		//相手のGRDを増やす
		if( enemyadd )
		{
			local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
			if( enemy.push() )
			{
				Battle_Std.GRD_AddValue( { val=enemyadd, boundplus=1 } );
				
				enemy.pop();
			}
		}
	}
}

// Param1(_paramno)が8(_num)なら頭無敵(_flag)を設定する
// FrameUpdateで設定する
// Flag形式に変更
//  8:頭　_HitCheckFlag_Head　※弾のときもあるｗ
// 16:弾　_HitCheckFlag_FireBall
// 32:足　_HitCheckFlag_Legs
// 64:空突　Def_HitCheckFlag_AirDive
local debug_HitMutekiArray = array(1024," - ");
debug_HitMutekiArray[_HitCheckFlag_Head] = "空中攻撃";
debug_HitMutekiArray[_HitCheckFlag_Legs] = "下攻撃";
debug_HitMutekiArray[_HitCheckFlag_FireBall] = "飛び道具";
debug_HitMutekiArray[_HitCheckFlag_Legs|_HitCheckFlag_FireBall] = "飛び道具＆下攻撃";
debug_HitMutekiArray[_HitCheckFlag_Legs|_HitCheckFlag_Head] = "空中攻撃＆下攻撃";
debug_HitMutekiArray[_HitCheckFlag_Head|_HitCheckFlag_FireBall] = "空中攻撃＆飛び道具";

// フラグっぽいんだけど、Setなので上書きなので、複数登録はできない
Battle_Std.SetHitMuteki <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head ) : (debug_HitMutekiArray)
{
	local lightLegsMutekiYoteiMv = Battle_Std.MoveCodeEx.CheckFlag( 7, def_MC7_LightLegsMuteki ); // 小足属性へ空振り予定
	if( BMvTbl.GetFrameParam( _paramno ) & _num )
	{
		//システムで小足属性へ空振り予定が入っていたら、この命令で消してしまわないようにする
		if( lightLegsMutekiYoteiMv ) _flag = _flag|Def_HitCheckFlag_LightLegs;
		
		// _dp("\n[無敵中です]"+_flag);
		BMvTbl.SetHitCheckFlag( { type=0, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 無敵
		
		if( Def_Dbg_HitMutekiLog )
		{
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.CallCount == 0 )
			{
				// _dp("\n！"+debug_HitMutekiArray[_flag]+"無敵中！ F:"+(mvs.MvCount) );
			}
		}
		return 1;
	}
	else
	{
		// 小足無敵だけはフラグさえついていれば設定し続ける
		if( lightLegsMutekiYoteiMv )
		{
			BMvTbl.SetHitCheckFlag( { type=0, val=Def_HitCheckFlag_LightLegs , time=16, flag=_ClearFlag_ChangeFrame  } ); // 無敵
		}
	}
	return 0;
}

// 複数登録する用
// こんな風につかう
// Battle_Std.SetHitMutekiParam1( { [40]=_HitCheckFlag_Legs|_HitCheckFlag_Head, [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMutekiParam1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 );
	if( param_val in param )
	{
		Battle_Std.SetHitMuteki( 1, param_val, param[param_val] );
		return 1;
	}
	return 0;
}

//↑の使いにくいので便利に
// Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [32]=_HitCheckFlag_Legs } );
Battle_Std.SetHitMuteki2_Param1 <- function( param={} )
{
	local param_val = BMvTbl.GetFrameParam( 1 ); //ツールに指定してあるParamを取得
	local add_flag = 0;
	local add_param = 0;
	// _dp("\n param_val:"+param_val );
	foreach( slot, val in param )
	{
		if( param_val&slot )
		{
			// _dp("\n 一致:"+slot );
			add_flag = add_flag|val;
			add_param = add_param|slot;
		}
	}
	if( add_param )
	{
		//_dp("\n 結果["+add_param+"] "+add_flag );
		Battle_Std.SetHitMuteki( 1, add_param, add_flag );
		return 1;
	}
	return 0;
}

Battle_Std.SetHitCheckFlag <- function( _paramno = 1, _num = 8, _flag=_HitCheckFlag_Head ) : (debug_HitMutekiArray)
{
	if( BMvTbl.GetFrameParam( _paramno ) & _num )
	{
		// _dp("\n[無敵中です]"+_flag);
		BMvTbl.SetHitCheckFlag( { type=1, val=_flag , time=16, flag=_ClearFlag_ChangeFrame  } ); // 属性をつける

		if( Def_Dbg_HitMutekiLog )
		{
			_dp("\n["+debug_HitMutekiArray[_flag]+"]");
		}
	}
}

Battle_Std.SetThrowEnemyMuteki <- function( _mutekiframe = 0 )
{
	Battle_Std.SetCaptureCharaMuteki( _mutekiframe );
	Battle_Std.SetEnemyCharaMuteki( _mutekiframe );
}

// つかみ中の相手を無敵にする 1〜:無敵にする 0:無敵を解除する
Battle_Std.SetCaptureCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetCaptureCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

Battle_Std.SetEnemyCharaMuteki <- function( _mutekiframe = 0 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_dage=_mutekiframe } );
		
		enemy.pop();
	}
}

// FrameIDっぽいものを返す
// 普段は FrameID を返すが、
// isFrameUpdateの時は　10000　を加算して返す
Battle_Std.GetFrameIDStatus <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	local ret_frameid = mvs.FrameID;
	if( mvs.isFrameUpdate ) ret_frameid += 10000;
	return ret_frameid;
}

// FrameIDっぽいものを返す2
// isFrameUpdateならFrameIDが返るが、そうじゃない時はマイナスにして返す
// ちな着地の時2回入ってくるので直した 150305
// 影響箇所それなりにあるかも
Battle_Std.GetUpdateFrameID <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_frameid = mvs.FrameID;
	// print("\n isup:"+mvs.isFrameUpdate +" isL:"+mvs.isLanding );
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_frameid *= -1;
	return ret_frameid;
}

// Paramっぽいものを返す
// isFrameUpdateならParam1が返るが、そうじゃない時はマイナスにして返す
Battle_Std.GetUpdateParam0 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param0;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam1 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param1;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam2 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param2;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}

Battle_Std.GetUpdateParam3 <- function( _mvs = 0 )
{
	local mvs = (_mvs == 0) ? BMvTbl.GetMvStatus() : _mvs;
	local ret_val = mvs.Param3;
	if( mvs.isFrameUpdate == 0 || mvs.isLanding ) ret_val *= -1;
	return ret_val;
}


// 相殺関係の処理
Battle_Std.Sousai <- {};

Battle_Std.Sousai.Init <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Init_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Init_NoGedan <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_NoGedan( _etcHantei ); // 相殺をセット
}

// 飛び道具だけ相殺する
Battle_Std.Sousai.Init_BallTarget <- function( _etcHantei=0 )
{
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.Set <- function( _etcHantei=0 )
{
	// MEMO:_CatchSuccess_HitSub_None を使って、攻撃出現が1以上だと、1→1で減ってない→ヒットしてないで処理が入らない
	// 多段の１発目〜の処理が原因らしい
	// キャラの攻撃出現を0にしておけば大丈夫だけど、リープがダメ（元々これを直すために-1しないようにしたので、現状は×）
	// 攻撃判定が出ている時の相殺判定を消したので発生しなくなったので解決
	// 追撃判定には反応しないように修正
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_NoHitFlag <- function( _etcHantei=0 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_NoGedan <- function( _etcHantei=0 )
{
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkStandGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv } );
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.Set_BallTarget <- function( _etcHantei=0 )
{
	// BMvTbl.SetAtkCatchFlag( { hantei=0, catch_flags=_CatchFlag_AtkAllGuard, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<2)|(1<<3) } ); // 「飛び道具判定」か「相殺判定」が無いと無効
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=_CatchFlag_AtkAllGuard|_CatchFlag_Invalid_Through_ExceptBound, success_flags=_CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy, time=64, flag=_ClearFlag_ChangeMv, check_etc=(1<<3) } ); // 「飛び道具判定」が無いと無効
	
	BMvTbl.SetLP(9,0); // 0:相殺できる 1:相殺できない ※HitInterruptで1になる
}

Battle_Std.Sousai.FrameUpdate <- function( _etcHantei=0 )
{
	Set( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_NoHitFlag <- function( _etcHantei=0 )
{
	Set_NoHitFlag( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_NoGedan <- function( _etcHantei=0 )
{
	Set_NoGedan( _etcHantei ); // 相殺をセット
}

Battle_Std.Sousai.FrameUpdate_BallTarget <- function( _etcHantei=0 )
{
	Set_BallTarget( _etcHantei ); // 相殺をセット
}

// 戻り値を1からMvHitStatusに変更
local useHP = {};
useHP.list <- [500, 250, 125, 63, 31, 156, 78, 39, 20, 10];
useHP.max <- useHP.list.len();

Battle_Std.Sousai.HitInterrupt <- function( param={} ) : (useHP)
{
	local mvhs = BMvTbl.GetMvHitStatus();
	
	// 相殺判定処理
	if( (mvhs.isCatchFlag & (1<<0) ) && BMvTbl.GetLP(9)==0 )
	{
		BMvTbl.SetLP(9,1); // 相殺できない状態にする
		
		//判定チェック
		local enemy = BMvCore.GetLastHitCharaData( 0 ); // そのままの相手を取得
		if( enemy.isdone() )
		{
			if( "nosound" in param )
			{
			}		
			else
			{
				BSound.SE_Play( { type=_SeType_Normal, num=255 } );
			}
			
			// 自分に補正をかける準備をする？
			// １ヒット目から効果が出ていないと単発と多段でまた変わってくる
			local enemy_exmvcode = 0;
			
			if( enemy.push() )
			{
				enemy_exmvcode = BMvTbl.GetMoveCodeEx( 1 );
				
				// BMvTbl.SetMvHitStatus( enemy_st ); // ヒットストップとか設定
				if( "erase_allhit" in param )
				{
					BMvTbl.CalcHitValue(-10000);
				}
				// 時間停止後先行入力がきくように処理を追加
				// これがないと、時間停止が終わった瞬間にボタンを押さないと次の技が出せない
				// あってもややシビアなレベル
				BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
				
				enemy.pop();
			}
			
			// 相殺時の処理色々
			// ゲーム全体を時間停止する
			// ヒットストップ形式だと飛び道具とかのヒットストップの影響を受けない系がとれなくなっちゃう
			// hitstop_f - 攻撃のヒットストップF（＝先行でチェーンが繋がる猶予F）が仕込みができるフレームになるよ
			local hitstop_f = 24; // 両者が止まる時間停止（ヒットストップのようなもの）
			local pride_win = 0; // 得意属性に打ち勝ったかどうか

			// 指定があったら固定
			if( "hitstop" in param )
			{
				hitstop_f = param.hitstop;
			}
			else
			{
				// 得意属性のチェック
				local pride = ( "pride" in param )? param.pride : 0;
				if( pride )
				{
					if( enemy_exmvcode&pride )
					{
						// _dp("\n 得意属性なので打ち勝つ");
						pride_win = 1; // 得意属性に打ち勝った
						hitstop_f = 18; // ストップが短い
					}
				}

				// デフォルトで得意属性なもの
				if( enemy_exmvcode&def_MC1_AtkLow )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // 弱攻撃に対しては常にストップが短い
				}
				if( enemy_exmvcode&def_MC1_AtkImpact )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // インパクトも同じ
					
					// さらに自分に打撃無敵をつける？
					// XXX:これやるとMv抜けちゃったときヤバイけど見なかったことに
					BMvEff.SetPlayerTimer( { muteki_dage=12 } );
				}
				if( enemy_exmvcode&def_MC1_VeryWeakImpactAtk )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 8; // 超弱い
				}
				
				
				if( pride_win )
				{
					// 相手のヒットストップを増やす
					if( enemy.push() )
					{
						BMvTbl.SetHitStop( 8, _ValAdd ); // 相手のヒットストップだけ伸ばす
						
						enemy.pop();
					}
					
					//BMvEff.AttackInfoString_Set({ word="PRIDE WIN" } );
				}
			}
			
			// インパクトしたらキャンセルできないバージョン
			// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
			
			BMvEff.SetStopTime( { time=hitstop_f, stopme=2, bounderase=1 } );

			BMvEff.SetCamera_Quake( { time=hitstop_f, type=2, } );
			
			// 相殺での体力消費処理
			// 多段だと補正がかかって減り過ぎないようにする
			local sousai_count = BMvTbl.AddPP(def_PP_SousaiCount,1)-1; // 相殺した回数を加算（0から）
			if( sousai_count >= useHP.max ) sousai_count = useHP.max-1;
			local use_HP = useHP.list[sousai_count];
			
			// _dp("\n sousai_count:"+sousai_count+" use_HP:"+use_HP );
			if( pride_win )
			{
				// tDDC.HP_Add( { hp=-use_HP/2 } ); // 回復可能体力を消費
			}
			else
			{
				// tDDC.HP_Add( { hp=-use_HP } ); // 回復可能体力を消費
			}
			
			if( "noeffect" in param )
			{
			}
			else
			{
				local eff = BMvEff.CreateObject( { datatype=1, start_pat="Eff_Sousai", y=-200*128 } );
				if( eff.push() )
				{
					BMvTbl.SetPrio( _CharaPrio_Near );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					
					eff.pop();
				}
			}
			
			//「インパクトスキル同士が衝突した」のチェック
			// tDDC.AchievementSousai(); // 「Mv_Skill_Sousai〜」同士がぶつかっているかどうかを監視
			
			
			// 相殺成功状態を消す。これをしないと何度もヒットインタラプト入ってくる
			BMvTbl.ClearHitStatus(); //ヒット情報初期化（ヒット情報が消えるのでキャンセルとかに影響がある）
			// BMvTbl.ClearHitInterrupt(); // ヒットインタラプトに入るのだけ無くす(次の相殺や攻撃ヒットはちゃんと入る)
			
			return mvhs; // ヒットステータスを返す
		}
		return 0;
	}
	return 0; // これやばかったのでは…？
}

//互換性のために↑は残す
//新相殺処理
Battle_Std.Atemi <- {};

Battle_Std.Atemi.Init <- function( param={} )
{
	local _etcHantei = ("hantei" in param )? param.hantei : 0;
	local _sousaiFlags = ("flags" in param )? param.flags : 0;

	BMvTbl.SetPP(def_PP_SousaiEtcHantei,_etcHantei);
	BMvTbl.SetPP(def_PP_SousaiFlags,_sousaiFlags);
	
	BMvTbl.SetPP(def_PP_SousaiCount,0); // 相殺した回数を初期化
	
	Set(); // 相殺をセット
}

Battle_Std.Atemi.Set <- function()
{
	local _etcHantei = BMvTbl.GetPP(def_PP_SousaiEtcHantei);
	// MEMO:_CatchSuccess_HitSub_None を使って、攻撃出現が1以上だと、1→1で減ってない→ヒットしてないで処理が入らない
	// 多段の１発目〜の処理が原因らしい
	// キャラの攻撃出現を0にしておけば大丈夫だけど、リープがダメ（元々これを直すために-1しないようにしたので、現状は×）
	// 攻撃判定が出ている時の相殺判定を消したので発生しなくなったので解決
	// 追撃判定には反応しないように修正
	
	local flags = BMvTbl.GetPP(def_PP_SousaiFlags);
	
	local c_flags = _CatchFlag_AtkStandGuard|_CatchFlag_AtkAirGuard|_CatchFlag_AtkCrouchGuard|_CatchFlag_Invalid_Through_ExceptBound;
	local s_flags = _CatchSuccess_HitSub|_CatchSuccess_HitSub_Enemy|_CatchSuccess_FlagHit_Enemy;
	local c_etc = 0;
	
	if( flags&def_PP_SFS_NoHit )
	{
		s_flags = Battle_Std.Val_DelFlag( s_flags, _CatchSuccess_FlagHit_Enemy );
	}
	if( flags&def_PP_SFS_BallTarget )
	{
		c_etc = (1<<3);// 「飛び道具判定」が無いと無効
	}
	if( flags&def_PP_SFS_NoGedan )
	{
		// _dp("\n 下段とれなーい");
		c_flags = Battle_Std.Val_DelFlag( c_flags, _CatchFlag_AtkCrouchGuard );
	}
	
	BMvTbl.SetAtkCatchFlag( { hantei=_etcHantei, catch_flags=c_flags, success_flags=s_flags, check_etc=c_etc, time=64, flag=_ClearFlag_ChangeMv } );
	Battle_Std.PP_DelFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai); // HitInterruptで1になるのを初期化
}

Battle_Std.Atemi.FrameUpdate <- function()
{
	Set(); // 相殺をセット
}

// 戻り値を1からMvHitStatusに変更
local useHP = {};
useHP.list <- [500, 250, 125, 63, 31, 156, 78, 39, 20, 10];
useHP.max <- useHP.list.len();

//当身戻り値用クラス

class AtemiHitStatus{

	done_ = 0;
	mvhs_ = 0; //MvHitStatus

    constructor()
    {
		done_ = 0;
		mvhs_ = 0;
    }
	
	function IsOk( mvhs )
	{
		done_ = 1;
		mvhs_ = mvhs;
	}
	
	function IsTiming()
	{
		if( IsDone() )
		{
			return (mvhs_.isFirstUpdate)? 1 : 0;
		}
		return 0;
	}

	function IsDone()
	{
		return done_;
	}
};

Battle_Std.Atemi.HitInterrupt <- function( param={} ) : (useHP)
{
	local ahs = AtemiHitStatus();
	local mvhs = BMvTbl.GetMvHitStatus();
	
	// 相殺判定処理
	if( (mvhs.isCatchFlag & (1<<0) ) && Battle_Std.PP_CheckFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai)==0 )
	{
		Battle_Std.PP_AddFlag(def_PP_SousaiFlags,def_PP_SFS_NoSousai);// 相殺できない状態にする
		
		//判定チェック
		local enemy = BMvCore.GetLastHitCharaData( 0 ); // そのままの相手を取得
		if( enemy.isdone() )
		{
			ahs.IsOk( mvhs ); // 有効化
			
			if( "nosound" in param )
			{
			}		
			else
			{
				BSound.SE_Play( { type=_SeType_Normal, num=255 } );
			}
			
			// 自分に補正をかける準備をする？
			// １ヒット目から効果が出ていないと単発と多段でまた変わってくる
			local enemy_exmvcode = 0;
			
			if( enemy.push() )
			{
				enemy_exmvcode = BMvTbl.GetMoveCodeEx( 1 );
				
				// BMvTbl.SetMvHitStatus( enemy_st ); // ヒットストップとか設定
				if( "erase_allhit" in param )
				{
					BMvTbl.CalcHitValue(-10000);
				}
				// 時間停止後先行入力がきくように処理を追加
				// これがないと、時間停止が終わった瞬間にボタンを押さないと次の技が出せない
				// あってもややシビアなレベル
				BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
				
				enemy.pop();
			}
			
			// 相殺時の処理色々
			// ゲーム全体を時間停止する
			// ヒットストップ形式だと飛び道具とかのヒットストップの影響を受けない系がとれなくなっちゃう
			// hitstop_f - 攻撃のヒットストップF（＝先行でチェーンが繋がる猶予F）が仕込みができるフレームになるよ
			local hitstop_f = 24; // 両者が止まる時間停止（ヒットストップのようなもの）
			local pride_win = 0; // 得意属性に打ち勝ったかどうか

			// 指定があったら固定
			if( "hitstop" in param )
			{
				hitstop_f = param.hitstop;
			}
			else
			{
				// 得意属性のチェック
				local pride = ( "pride" in param )? param.pride : 0;
				if( pride )
				{
					if( enemy_exmvcode&pride )
					{
						// _dp("\n 得意属性なので打ち勝つ");
						pride_win = 1; // 得意属性に打ち勝った
						hitstop_f = 18; // ストップが短い
					}
				}

				// デフォルトで得意属性なもの
				if( enemy_exmvcode&def_MC1_AtkLow )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // 弱攻撃に対しては常にストップが短い
				}
				if( enemy_exmvcode&def_MC1_AtkImpact )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 18; // インパクトも同じ
					
					// さらに自分に打撃無敵をつける？
					// XXX:これやるとMv抜けちゃったときヤバイけど見なかったことに
					BMvEff.SetPlayerTimer( { muteki_dage=12 } );
				}
				if( enemy_exmvcode&def_MC1_VeryWeakImpactAtk )
				{
					pride_win = 1; // 得意属性に打ち勝った
					hitstop_f = 8; // 超弱い
				}
				
				
				if( pride_win )
				{
					// 相手のヒットストップを増やす
					if( enemy.push() )
					{
						BMvTbl.SetHitStop( 8, _ValAdd ); // 相手のヒットストップだけ伸ばす
						
						enemy.pop();
					}
				}
			}
			
			// インパクトしたらキャンセルできないバージョン
			// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
			
			BMvEff.SetStopTime( { time=hitstop_f, stopme=2, bounderase=1 } );

			BMvEff.SetCamera_Quake( { time=hitstop_f, type=2, } );
			
			// 相殺での体力消費処理
			// 多段だと補正がかかって減り過ぎないようにする
			local sousai_count = BMvTbl.AddPP(def_PP_SousaiCount,1)-1; // 相殺した回数を加算（0から）
			if( sousai_count >= useHP.max ) sousai_count = useHP.max-1;
			local use_HP = useHP.list[sousai_count];
			
			// _dp("\n sousai_count:"+sousai_count+" use_HP:"+use_HP );
			if( pride_win )
			{
				// tDDC.HP_Add( { hp=-use_HP/2 } ); // 回復可能体力を消費
			}
			else
			{
				// tDDC.HP_Add( { hp=-use_HP } ); // 回復可能体力を消費
			}
			
			if( "noeffect" in param )
			{
			}
			else
			{
				local eff = BMvEff.CreateObject( { datatype=1, start_pat="Eff_Sousai", y=-200*128 } );
				if( eff.push() )
				{
					BMvTbl.SetPrio( _CharaPrio_Near );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround } );
					
					eff.pop();
				}
			}
			
			//「インパクトスキル同士が衝突した」のチェック
			// tDDC.AchievementSousai(); // 「Mv_Skill_Sousai〜」同士がぶつかっているかどうかを監視
			
			
			// 相殺成功状態を消す。これをしないと何度もヒットインタラプト入ってくる
			BMvTbl.ClearHitStatus(); //ヒット情報初期化（ヒット情報が消えるのでキャンセルとかに影響がある）
			// BMvTbl.ClearHitInterrupt(); // ヒットインタラプトに入るのだけ無くす(次の相殺や攻撃ヒットはちゃんと入る)
			
			return ahs;
		}
	}
	return ahs;
}




// ■ジャンプステータスフラグ
// 前後Ｎジャンプから着地まで有効、着地で０になるフラグ
// 空中必殺技の回数制限にも使用する
// サンプル
// Battle_Std.JumpStatus.Set( def_PP_JS_SkillLimit0 );

Battle_Std.JumpStatus <- {};

Battle_Std.JumpStatus.Set <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

// 他と書式がちがうのでAddもいちおう追加
Battle_Std.JumpStatus.Add <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)|flag ) ); 
}

Battle_Std.JumpStatus.Del <- function( flag )
{
	BMvTbl.SetPP(def_PP_JumpStatus, ( BMvTbl.GetPP(def_PP_JumpStatus)&~flag ) ); 
}

Battle_Std.JumpStatus.Check <- function( flag )
{
	if( BMvTbl.GetPP(def_PP_JumpStatus)&flag ) return 1;
	return 0;
}

// オブジェクトの食らい判定に攻撃判定があたっているかの汎用チェック
Battle_Std.CheckObjectisYarare <- function()
{
	return Battle_Std.CheckObjectHanteiCross( _Hantei_Kurai );
}

// オブジェクトの判定に攻撃判定があたっているかの汎用チェック
Battle_Std.CheckObjectHanteiCross <- function( _hantei )
{
	local enemy = BMvEff.CheckHantei( { src=[ _hantei, 0, -1 ], dst=[ _Hantei_Attack, 0, -1 ], flags=_HC_EnemyPc|_HC_EnemyObj|_HC_WithoutNoHanteiFlagObj } );
	if( enemy.push() )
	{
		// 攻撃出現チェック
		local lefthitcount = BMvTbl.CalcHitValue(0);
		local emv_throw = Battle_Std.MvAction.CheckFlag( def_MC_ThrowRect );
	
		enemy.pop();
		
		local hit = 1; // ヒットしたか
		if( lefthitcount <= 0 )
		{
			return 0;// 残りヒット数が0の矩形は無視
		}
		if( emv_throw )
		{
			return 0;// 投げ属性の矩形は無視
		}
		return 1;
	}
	return 0;
}

Battle_Std.SetVector_ReduceYVecNoLanding <- function( _offydot=0 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	local pos = BMvTbl.GetPosition(0);
	local count = -((_offydot<<7) + pos.y ) / vec.y;
	
	BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=0, addy=0, flags=_Vector_Normal } );
	if( count > 0 )
	{
		BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
	}
}

// 指定フレームで着地するベクトルを与える
Battle_Std.SetVector_YVecFrameLanding <- function( _frame=22 )
{
	// 着地しない程度にベクトル収束
	local vec = BMvTbl.GetVector(0);
	local pos = BMvTbl.GetPosition(0);
	local yvec = -( pos.y ) / _frame;
	// _dp("\n count:"+count);
	
	BMvTbl.SetVector( { x=vec.x, addx=vec.addx, y=yvec, addy=0, flags=_Vector_Normal } );
	if( count > 0 )
	{
		// BMvTbl.SetVector( { y=vec.y, addy=-vec.y/count, flags=_Vector_Div } );
	}
}

// LP8を使ってヒット確認を実現する
Battle_Std.HitKakuninLP8 <- {};

Battle_Std.HitKakuninLP8.MvInit <- function()
{
	BMvTbl.SetLP(8,0); // ヒット確認に使ったフレーム記憶(追加入れると+10000される) 1〜999:確認フレーム
}

Battle_Std.HitKakuninLP8.MvHit <- function()
{
	if( BMvTbl.GetLP(8) < 10000 )
	{
		// 追加コマンドを入れていないとき
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.CallCount == 1 )
		{
			BMvTbl.AddLP(8,1);
		}
	}
}

// コマンドタイミングのInit処理
Battle_Std.HitKakuninLP8.AddCmdInit <- function()
{
	// コマンド成立後
	if( BMvTbl.GetLP(8) < 10000 )
	{
		BMvTbl.AddLP(8,10000); // LP8を使う
	}
}

Battle_Std.HitKakuninLP8.AddMvInit <- function()
{
	BMvTbl.SetPosition( { y=0 } ); // 一応念のためだよ
	// BMvTbl.SetVector( { x=500, addx=100, flags=_Vector_Normal } ); // スライド
	// BMvTbl.SetVector_MaxX( 1500 );
	BMvTbl.SetVector( { x=1000, addx=-150, flags=_Vector_Div } ); // スライド
	BMvTbl.SetPosition( { x=64, flags=_Position_Add|_Position_CaptureShift|_Position_ChangeMuki } )
	// BMvTbl.SetVector_MaxX( 1500 );
	
	// LP8 : 恐らくヒット確認に使ったフレームが入っている　1F〜
	local kakunin_f = BMvTbl.GetLP(8) - 10000; // １万引く
	local kakunin_lv = 0; // ヒット確認のうまさ
	if( kakunin_f <= 14 )
	{
		kakunin_lv = 2;
	}
	else if( kakunin_f <= 18 )
	{
		kakunin_lv = 1;
	}
	else
	{
		kakunin_lv = 0;
	}
	// _dp("\n 確認レベル:"+kakunin_lv+" ※フレーム:"+kakunin_f );
	
	BMvTbl.SetLP(8,kakunin_lv); // 確認レベルを記憶
	switch( kakunin_lv )
	{
	case 2: // レベル３
		// 何もしないので効果大
		// BMvEff.ComboView_Set( { val=100, type=1 } ); // 乗算補正 80
		break;
	case 1: // レベル２
		// 補正をきつくして減らないようにする
		BMvEff.ComboView_Set( { val=62, type=1 } ); // 乗算補正 50
		break;
	default: // レベル１
		// Mvをキャンセル不能にして追撃できない
		// BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_None, special=_CancelFlag_None, time=254, flag=_ClearFlag_ChangeMv } );
		// 補正をきつくして減らないようにする
		BMvEff.ComboView_Set( { val=50, type=1 } ); // 乗算補正 40
		break;
	}

	return kakunin_lv; // 一応確認レベルを返してあげよう
}

Battle_Std.HitKakuninLP8.AddMvHit <- function( param={} )
{
	if( !( "offx" in param ) ) param.offx <- 0;
	if( !( "offy" in param ) ) param.offy <- 0;
	if( !( "FrameID" in param ) ) param.FrameID <- 0;

	local hs = BMvTbl.GetMvHitStatus();
	local mvs = BMvTbl.GetMvStatus();
	
	if( param.FrameID != 0 && mvs.FrameID != param.FrameID ) return 0; // 失敗
	
	if( hs.isFirstUpdate && hs.Type & _HitType_Damage && hs.isCatchFlag == 0 )
	{
		local kakunin_lv = BMvTbl.GetLP(8);
		switch( kakunin_lv )
		{
		case 2: // レベル３
			local frame = 35;
			BMvEff.Slowmotion_Set( { type=0, time=frame, power=10000, power_minus=5000/frame } );
			BMvEff.SetCamera_Quake( { type=2, time=frame } );
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_HitKakuninAddCamera", x=param.offx<<7, y=param.offy<<7 } );
			if( eff.push() )
			{
				BMvTbl.SetLP(0,kakunin_lv); // 確認レベル渡す
				BMvTbl.SetLP(1,frame); // 演出時間渡す
				eff.pop();
			}
			// ＳＥを再生する
			// BSound.SE_Play( { type=_SeType_Normal, num=221 } );
			break;
		case 1: // レベル２
			local frame = 20;
			BMvEff.Slowmotion_Set( { type=0, time=frame, power=10000, power_minus=5000/frame } );
			BMvEff.SetCamera_Quake( { type=2, time=frame } );
			local eff = BMvEff.CreateObject( { mvname="Mv_Null_HitKakuninAddCamera", x=param.offx<<7, y=param.offy<<7 } );
			if( eff.push() )
			{
				BMvTbl.SetLP(0,kakunin_lv); // 確認レベル渡す
				BMvTbl.SetLP(1,frame); // 演出時間渡す
				eff.pop();
			}
			break;
		default: // レベル１
			break;
		}
		return 1; // ヒットした瞬間1
	}
	if( hs.isFirstUpdate == 0 && hs.isCatchFlag == 0 && mvs.isUpdate )
	{
		if( hs.Type & _HitType_Damage/* && hs.PosState == _PosState_Ground*/ )
		{
			BMvTbl.SetFinalize( 256 ); // ヒットしたので抜ける
		}
		else if( hs.Type & _HitType_Hit/* && hs.PosState == _PosState_Ground*/ )
		{
			BMvTbl.SetFinalize( 512 ); // ヒットしたので抜ける
		}
		return 0; // 
	}
	return 0;
}

Battle_Std.HitKakuninLP8.JAddMvFU <- function()
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isLanding )
	{
		BMvTbl.SetFinalize(256);
	}
}

Battle_Std.HitKakuninLP8.JAddMvFin <- function()
{
	Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_Sousai4_Add"]); //デフォ,[code,mv]...
}

Battle_Std.HitKakuninLP8.AddMvFin <- function()
{
	//BMvTbl.SetNextMoveTable( "Mv_AerialJumpWait_F" );
	Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_AerialJump_F"],[512,"Mv_MissAerialJump_B"]); //デフォ,[code,mv]...
}

// 攻撃Mvに相手距離に応じて削りダメージを設定する
// 発動した瞬間の相手までの距離で見る
// ポテンシャルとかブラストとかも見るといいかな
Battle_Std.SetKezuriDamageMode <- function()
{
	local enemy = BMvCore.GetEnemyCharaData(); // 相手情報取得
	local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得

	local xlen = posst.distance_x;
	if( xlen >= (768<<7) )
	{
		// tDDC.HP_SourceDamMode( {  value=2, time=254, flag=_ClearFlag_ChangeMv } );
	}
	else if( xlen >= (512<<7) )
	{
		// tDDC.HP_SourceDamMode( {  value=4, time=254, flag=_ClearFlag_ChangeMv } );
	}
	else
	{
		// tDDC.HP_SourceDamMode( {  value=10, time=254, flag=_ClearFlag_ChangeMv } );
	}
}

Battle_Std.SetKirifudaHitEffect <- function( param={} )
{
}

// HitInterruptで使うもの
// 攻撃があたるタイミングで１を返す
Battle_Std.CheckDamageTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckDamageTiming() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.GetUpdateFrameID_DamageTiming <- function()
{
	if( Battle_Std.CheckDamageTiming() )
	{
		return Battle_Std.GetUpdateFrameID();
	}
	return 0;
}

// ↑のダウン追い討ちを除外したバージョン
Battle_Std.CheckDamageTiming_ExceptDown <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 && mvhs.IsDown() == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckDamageTiming_ExceptDownFrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckDamageTiming_ExceptDown() )
	{
		return 1;
	}
	return 0;
}

// ガードされた時
Battle_Std.CheckGuardTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Guard && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckGuardTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckGuardTiming() )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckHitTiming <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Hit && mvhs.isCatchFlag == 0 )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckHitTiming_FrameID <- function( _FrameID = 0 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.FrameID == _FrameID && Battle_Std.CheckHitTiming() )
	{
		return 1;
	}
	return 0;
}

//ヒット扱いになる当身をとられた時
//エンキドゥの214+AorBが該当。Cやアカツキは空振り扱いなので入ってこない
//ヒット扱い = _CatchSuccess_FlagHit_Enemy がついた当身のみ
Battle_Std.CheckCatchedTiming_FlagHit <- function()
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.isFirstUpdate && mvhs.Type&_HitType_Damage && mvhs.isCatchFlag )
	{
		return 1;
	}
	return 0;
}


//HitInterrupt用
Battle_Std.AddDamageFlagInterrupt <- function( flag )
{
	local mvhs = BMvTbl.GetMvHitStatus();
	if( mvhs.Type&_HitType_Damage && mvhs.isCatchFlag == 0 )
	{
		//0やisFirstUpdateだと初段ヒット時に入らないので二回やるためにCount<=1にしている
		if( mvhs.Count <= 1 )
		{
			Battle_Std.EnemyDamageFlag_Add( flag );
			return 1;
		}
	}
	return 0;
}

// 切り札空振り時の効果セット
Battle_Std.SetKirifudaKaraburiEffect <- function()
{
}

Battle_Std.AddBlast_SPSkill <- function()
{
}

// ボール化やられ関係
Battle_Std.BallBound <- {};

Battle_Std.BallBound.CallDummy <- function( param={} )
{
}

// 空中ダッシュの最低高さを保障するためにベクトルをセットする
// ※DivKeepなので、着地した後に浮く可能性があるので使用には気をつける
Battle_Std.SetDivKeepVector_AirDashMinHeight <- function( _minHeight = def_POS_AirDashHoseiMinHeight )
{
	// 高度が低い場合上ベクトルの補正をかける
	local pos = BMvTbl.GetPosition( 0 );
	if( pos.y >= -_minHeight )
	{
		local divf = 5;
		local hosei = (-_minHeight - pos.y)/divf; // 10Fでいくよ
		local hosei_add = -hosei/(divf*2);
		// _dp("\n hosei:"+hosei+" hosei_add:"+hosei_add );
		if( hosei < 0 && hosei_add <= 0 )
		{
			hosei_add = 1; // これを入れないと浮き続ける
		}
		// _dp("\n pos.y:"+(pos.y/128)+" _minHeight:"+(-_minHeight/128)+" 修正:"+(hosei/128)+"*"+divf )
		// _dp("\n hosei:"+hosei+" -hosei/(divf*2):"+ (-hosei/(divf*2)) );
		BMvTbl.SetVector( { y=hosei, addy=hosei_add, flags=_Vector_DivKeep } );
		return 1;
	}
	return 0;
}

// 数フレーム無敵にしてつかみを開放する
// 通常投げの演出用
Battle_Std.ThrowRelease_SetMuteki <- function( param={} )
{
	BMvEff.ThrowRelease( param );
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=2, muteki_dage=2 } );
		enemy.pop();
	}
}

// 投げ演出用の攻撃判定でるまで相手を無敵にする関数
// def_PP_GS_ThrowAtkAppearedを見る
Battle_Std.SetEnemyMuteki_Throw <- function()
{
	// ↑の後じゃないとダメ？
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc  } );
	// _dp("\n "+enemy.isdone() +" flag:"+ Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) );
	if( Battle_Std.GS_CheckFlag( def_PP_GS_ThrowAtkAppeared ) ) // 過去に攻撃判定が相手に重なったことがあるかどうか
	{
		// 攻撃判定が一度でも出た後なので、基本的に何もしないでいいはず
	}
	else
	{
		// まだ攻撃判定がでたことがないので、判定が出るまでは相手を無敵にします
		if( enemy.isdone() )
		{
			// 攻撃判定が重なっているので、相手の無敵を解除
			if( enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なっている" );
				BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } );
				
				enemy.pop();
				
				Battle_Std.GS_AddFlag( def_PP_GS_ThrowAtkAppeared );
			}
		}
		else
		{
			local n_enemy = BMvCore.GetEnemyCharaData();
			// 攻撃判定がまだ重なってないので、無敵にしておく
			if( n_enemy.push() )
			{
				// _dp(" -> 攻撃判定が重なってない" );
				BMvEff.SetPlayerTimer( { muteki_nage=6, muteki_dage=6 } );
				
				n_enemy.pop();
			}
		}
	}
}


// 無敵で投げ開放まとめ
Battle_Std.MutekiThrowRelease_Init <- function()
{
	Battle_Std.GS_DelFlag( def_PP_GS_ThrowAtkAppeared );
}

Battle_Std.MutekiThrowRelease <- function( param={} )
{
	local mvs = BMvTbl.GetMvStatus(); // ステータス取得
	if( mvs.isFrameUpdate )
	{
		if( mvs.FrameID == param.FrameID )
		{
			BMvEff.ThrowParam( { x=param.x, y=param.y } );
			Battle_Std.ThrowRelease_SetMuteki( { type=param.type, airrecover=0, flags=0 } );
		}
	}
	Battle_Std.SetEnemyMuteki_Throw(); // 攻撃判定が出るまで相手を無敵にする
}


// 相手との距離が一定以下にならないように近づく
Battle_Std.AddXPos_NearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
	}
	BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 相手との距離が一定以下にならないように相手を引き寄せる
Battle_Std.SnapNearEnemy <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local enemy = BMvCore.GetNearEnemyCharaData();
	if( enemy.isdone() )
	{
		local eposst = BMvEff.GetPointStatus( { target=enemy } );
		
		// 相手との距離から最低距離を引いて、あと何ドットまで近づいていいか出す
		local e_maxx = (eposst.distance_x - _minx);
		if( e_maxx < addx ) addx = e_maxx; // 補正をかける
		
		if( enemy.push() )
		{
			BMvTbl.SetPosition( { x=addx, flags=_Position_Add|_Position_ChangeMuki } );
			
			enemy.pop();
		}
	}
}

// ステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckFrontStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetFrontStageDistance(); // 壁までの距離
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後のステージ端との距離が一定以下にならないように近づく
Battle_Std.AddXPos_CheckBackStage <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離
	
	local kabe_kyori = Battle_Std.GetBackStageDistance(); // 壁までの距離
	// _dp("\n kabe_kyori:"+kabe_kyori );
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < -addx ) addx = -kabe_maxx; // 補正をかける
	// _dp("\n kabe_kyori:"+kabe_kyori+" kabe_maxx:"+kabe_maxx+" -> "+addx+" _offx:"+_offx );
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 前方の画面端との距離
Battle_Std.AddXPos_CheckFromtCorner <- function( _offx, _minx )
{
	_offx = _offx<<7;
	_minx = _minx<<7;
	
	local addx = _offx; // 最終的に加算するＸ距離

	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } ); // 画面内の端座標取得
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx; // 自分の向きに応じて画面端とする座標を変える
	
	if( kabe_kyori < 0 )
	{
		kabe_kyori *= -1; // 距離にしたいので正の値にする
	}
	
	local kabe_maxx = kabe_kyori - _minx;
	if( kabe_maxx < addx ) addx = kabe_maxx; // 補正をかける
	
	BMvTbl.SetPosition( { x= addx, flags=_Position_Add|_Position_ChangeMuki } );
}

// 背後の画面端から出現
Battle_Std.SetXPos_BackCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.sx : pos.ex;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 前方の画面端から出現
Battle_Std.SetXPos_FrontCorner <- function( _offx=0 )
{
	_offx = _offx<<7;
	
	local pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local muki = BMvTbl.GetMuki();
	local target_xpos = ( muki == 1 )? pos.ex : pos.sx;
	BMvTbl.SetPosition( { x=target_xpos+(muki*_offx) } );
}

// 相手までの距離
// 相手との距離を見て近かったら1を返す
// 自分の背後に相手がいる場合も1を返すので注意（歩きすぎとかはおこらないので安全）
Battle_Std.CheckEnemyDistance <- function( _xkyori )
{
	_xkyori = _xkyori<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori < _xkyori )
		{
			return 1;
		}
	}
	return 0;
}

// 範囲内なら
// ※Battle_Std.CheckEnemyDistanceと組み合わせて使うと、==_xminや==_xmaxの時取得できないので注意
// そういうときは「Battle_Std.GetEnemyDistanceStatus」使って
Battle_Std.CheckEnemyDistance2 <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
	}
	return 0;
}

// 相手との距離を見る
// -4:範囲より手前
//  1:範囲内
// -6:範囲より外
//  0:敵取得失敗
Battle_Std.GetEnemyDistanceStatus <- function( _xmin, _xmax )
{
	_xmin = _xmin<<7;
	_xmax = _xmax<<7;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		if( kyori > _xmin && kyori < _xmax )
		{
			return 1;
		}
		else if( kyori <= _xmin )
		{
			return -4;
		}
		else if( kyori >= _xmax )
		{
			return -6;
		}
	}
	return 0;
}


// 相手との距離を返す
// 自分の背中にいる場合はマイナスを返す
Battle_Std.GetEnemyDistance <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x*BMvTbl.GetMuki();
		
		return kyori;
	}
	return 0;
}

// 向いてる向きでの距離チェック系 似たような関数が別にあるけどこっちを使おう
// ステージ端までが近いかどうかチェック
Battle_Std.CheckFrontStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

Battle_Std.CheckBackStageDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackStageDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方のステージ端までの距離を返す
Battle_Std.GetFrontStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == 1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// 後方のステージ端までの距離を返す
Battle_Std.GetBackStageDistance <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	return( ( BMvTbl.GetMuki() == -1 )? ( def_POS_GamenHajiX - pos.x ) : ( def_POS_GamenHajiX + pos.x) );
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckFromtCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckFromtDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckFromtCornerDistance( _xkyori );
	}
}

// ラウンド終了時はチェックする壁を変える
Battle_Std.CheckBackCornerDistance_with_RoundEnd <- function( _xkyori=0 )
{
	// ラウンドが終了しているかどうか
	if( Battle_Std.RoundisEnd() )
	{
		// 見た目どおりの端の距離でチェック
		return Battle_Std.CheckBackDispCornerDistance( _xkyori );
	}
	else
	{
		// 拡縮とかの影響を受けない端の距離でチェック
		return Battle_Std.CheckBackCornerDistance( _xkyori );
	}
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckFromtCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetFrontCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 画面端までが近いかどうかチェック
Battle_Std.CheckBackCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	if( Battle_Std.GetBackCornerDistance() < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 前方の画面端までの距離を返す
Battle_Std.GetFrontCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
}

// 後方の画面端までの距離を返す
Battle_Std.GetBackCornerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
}

// 見た目の天井までの距離を返す
Battle_Std.GetCeilCprnerDistance <- function()
{
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera|_GetPos_Offset|_GetPos_NoMuki } );
	return -c_pos.sy;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckFromtDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == 1 )? c_pos.ex : c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 見た目通りの画面端までが近いかどうかチェック２（勝利とかでカメラが動いている影響を受ける）
Battle_Std.CheckBackDispCornerDistance <- function( _xkyori=0 )
{
	_xkyori = _xkyori<<7;
	
	local c_pos = BMvEff.GetCameraRect( { flags=_GetPos_DispCamera|_GetPos_Offset|_GetPos_NoMuki } );
	local kabe_kyori = ( BMvTbl.GetMuki() == -1 )? -c_pos.ex : -c_pos.sx;
	if( kabe_kyori < _xkyori )
	{
		return 1;
	}
	return 0;
}

// 判定が触れている敵を引き寄せる
// やられ中は効果なし？
Battle_Std.PullEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x; // 向きを計算しない
		local move_pow = -kyori/_frame;
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

Battle_Std.PushEnemy_HanteiCross <- function( _frame=100, _src = [ _Hantei_Etc, 0, 1 ], _dst=[ _Hantei_Kurai, 0, -1 ] )
{
	local hantei = BMvEff.GetHanteiRect( { check=_src, flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Offset } );
	local enemy = BMvEff.CheckHantei( { src=_src, dst=_dst, flags=_HC_EnemyPc } );
	if( enemy.isdone() && hantei.sx != _Hantei_Error )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x;//*BMvTbl.GetMuki();
		// 相手が前にいると＋、後ろにいるとマイナス
		// local kyori = posst.distance_x;
		
		local hantei_right = -hantei.sx; // 判定の右端までの距離
		local hantei_left = hantei.ex; // 判定の左端までの距離
		local muki = BMvTbl.GetMuki();
		if (muki==-1) // 左向き時は左右逆転
		{
			hantei_right = hantei.ex;
			hantei_left = -hantei.sx;
		}
		
		local move_pow = 0;//(hantei.ex - kyori)/_frame;
		if( kyori > 0 ) // 敵が左にいる
		{
			move_pow = (hantei_left - kyori)/_frame;
			if( move_pow<0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		else // 敵が右にいる
		{
			move_pow = -(hantei_right + kyori)/_frame;
			if( move_pow>0 ) move_pow=0; // 判定の外側にいる場合、引き寄せにならないように
		}
		
		// _dp("\n kyori:"+kyori/128+" move_pow:"+move_pow+" hantei.ex:"+hantei.ex+" x:"+posst.pos_x/128 );
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			
			if( bs.isDone == 0 )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
				// _Position_ChangeMuki はつけない
			}
			enemy.pop();
		}
	}
}

// 特殊判定０とやられ判定のチェック
Battle_Std.PullEnemy_Etc0xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 0, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定１とやられ判定のチェック
Battle_Std.PullEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

Battle_Std.PushEnemy_Etc1xKurai <- function( _frame )
{
	Battle_Std.PushEnemy_HanteiCross( _frame, [ _Hantei_Etc, 1, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// 特殊判定４とやられ判定のチェック
Battle_Std.PullEnemy_Etc4xKurai <- function( _frame )
{
	Battle_Std.PullEnemy_HanteiCross( _frame, [ _Hantei_Etc, 4, 1 ], [ _Hantei_Kurai, 0, -1 ] );
}

// ターゲットにマーキングするオブジェクトの座標セット
Battle_Std.SetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		BMvTbl.SetPosition( { x=pl_pos.x, y=set_posy } );
	}
}

Battle_Std.GetPos_MarkingTarget <- function( _core, _par=5, _dfoy=-150, _miny=0 )
{
	_miny = _miny<<7;
	if( _core.push() )
	{
		local pl_pos = BMvTbl.GetPosition(0);
		local pl_kasanari = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=0 } );
		
		_core.pop();
		local set_posy = pl_pos.y+(_dfoy<<7); // 基本値
		if( pl_kasanari.sx != _Hantei_Error )
		{
			set_posy = pl_kasanari.ey + ( (pl_kasanari.sy - pl_kasanari.ey) * _par / 10 );
		}
		if( _miny && set_posy > _miny ) set_posy = _miny; // 低くなりすぎないように最低値をつける
		
		local ret_pos = BMvTbl.CCharaPosition();
		ret_pos.x = pl_pos.x;
		ret_pos.y = set_posy;
		return ret_pos;
	}
	return 0;
}

Battle_Std.SetPos_MarkingPlayer <- function( _par=5, _dfoy=-150 )
{
	local enemy = BMvCore.GetPlayerCharaData();
	Battle_Std.SetPos_MarkingTarget( enemy, _par, _dfoy );
}

Battle_Std.SetPos_MarkingEnemy <- function( _par=5, _dfoy=-150 )
{
	local enemy = BMvCore.GetEnemyCharaData();
	Battle_Std.SetPos_MarkingTarget( enemy, _par, _dfoy );
}

// 特定のＭｖ中、演出長時間背景の色を変える系処理
// 変えている最中はフラグがたっている
// 自分以外の誰かにフラグがたっていたらフェードは消さない
// とりあえず黒のみ
// 暗転中時間が進むので長めに入れないとダメよ
Battle_Std.BackScreenBlack_Start <- function( _time=600 )
{
}

Battle_Std.BackScreenBlack_Check <- function()
{
}




Battle_Std.CheckDownOiuti <- function()
{
	return 0;
}

Battle_Std.ImpactSkill_Init <- function( _AddSkillCount = 1 )
{
	// インパクトスキルの初期設定
	Battle_Std.Sousai.Init();
	// Battle_Std.MoveCode.AddFlag( def_MC_EXHitCancelNG ); // HIT時EXキャンセルでフォロー不可に
	
	Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_AtkImpact ); // インパクトスキル
	
	// if( _AddSkillCount ) tDDC.SkillCountPlus(_SkillCount_ImpactSkill); // CLI用履歴カウンタを加算「インパクトスキル」
	
}

Battle_Std.ImpactSkill_FrameUpdate <- function()
{
	Battle_Std.Sousai.FrameUpdate(); // 相殺回数が残っていたら再度相殺可能状態にする
}

Battle_Std.ImpactSkill_HitInterrupt <- function( _pride = 0 )
{
	return Battle_Std.Sousai.HitInterrupt( { pride = _pride } );
}

Battle_Std.EnemyDamageFlag_Add <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValAdd );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Del <- function( _flag )
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		BMvTbl.DamageFlag_Func( _flag, _ValErase );
		
		enemy.pop();
	}
}

Battle_Std.EnemyDamageFlag_Check <- function( _flag )
{
	local ret = 0;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		ret = BMvTbl.DamageFlag_Func( _flag, _ValCheck ); // 0 or 1
		
		enemy.pop();
	}
	return ret;
}

// 今のMvとMvNameの配列が一致しているかチェック
// BCMDTbl.CheckMoveNameとの互換性をつけるため、文字列の時もチェックするように変更
Battle_Std.IsMatchMvNameArray <- function( _ar )
{
	return Battle_Std.IsMatchNameArray( BMvTbl.GetMvName(), _ar );
}

Battle_Std.IsMatchChangeMvNameArray <- function( _ar )
{
	return Battle_Std.IsMatchNameArray( BMvTbl.ChangeMv_GetMvName(), _ar );
}

Battle_Std.IsMatchNameArray <- function( _name, _ar )
{
	switch( typeof _ar )
	{
	case "array":
		foreach( x in _ar )
		{
			if( _name == x )
			{
				return 1;
			}
		}
		break;
	case "string":
		if( _name == _ar ) return 1;
		break;
	}
	return 0;
}

// 必殺技系ですぐ呼ばれるものに
Battle_Std.CallSkillSoonCache <- function( _frameid, _rest )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	local checkframe = BMvEff.GetFrameIDNum( _frameid );
	if( checkframe != -1 ) // FrameIDがあるかどうか
	{
		BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
	}
}

Battle_Std.CallSkillSoonCaches <- function( ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	
	for(local i = 0; i < vargc; i++)
	{
		local checkframe = BMvEff.GetFrameIDNum( vargv[i][0] );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=vargv[i][1] } );
		}
	}
}

// FrameID指定ではなく、単純に今のパターンの予約をする
// ダハーカとかで使ってる
Battle_Std.CallSoonCaches_noFrameID <- function( ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local _pat = mvs.DataPattern;
	
	for(local i = 0; i < vargc; i++)
	{
		// _dp("\n["+_pat+"_"+vargv[i][0]+"]"+vargv[i][1]);
		BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=vargv[i][0], rest=vargv[i][1] } );
	}
}

Battle_Std.CallSkillSoonCaches_AnoterPat <- function( _patstr, ... )
{
	local mvs = BMvTbl.GetMvStatus();
	local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=_patstr } );
	
	for(local i = 0; i < vargc; i++)
	{
		local checkframe = BMvEff.GetFrameIDNum( vargv[i][0] );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=vargv[i][1] } );
		}
	}
}

// Param2が指定した値の時に指定したFrameIDをキャッシュに乗せる
Battle_Std.CallSkillLandCache_Param2 <- function( _param2, _frameid, _rest=4)
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.isFrameUpdate && mvs.isLanding == 0 && mvs.Param2 == _param2 )
	{
		local _pat = mvs.DataPattern;
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}


// 追加技の派生予約
Battle_Std.CallAddSkillCache <- function( _patstr, _rest )
{
	local target_pat = BMvEff.GetPatternNum( { datatype=0, pat=_patstr } );
	// _dp("\n[BCCache]:"+target_pat+"_0 ... "+_rest+"F後");
	BMvCore.CallEntryBCCachePreTransfer( { pat=target_pat, frame=0, rest=_rest } ); // 追加派生予約
}

// ループアニメの抜け先をキャッシュに載せる(パターン番号+FrameID指定)
Battle_Std.CallLoopEndCache_FrameID <- function( _pat, _frameid, _frame=10, _rest=2 )
{
	local mvs = BMvTbl.GetMvStatus();
	if( mvs.MvCount % _frame == 0 && mvs.isLanding == 0 && _pat == mvs.DataPattern )
	{
		local checkframe = BMvEff.GetFrameIDNum( _frameid );
		if( checkframe != -1 ) // FrameIDがあるかどうか
		{
			// _dp("\n["+_pat+"-"+checkframe+"]を予約");
			BMvCore.CallEntryBCCachePreTransfer( { pat=_pat, frame=checkframe, rest=_rest } );
		}
	}
}

// 数フレーム後に空中必殺技制限をかける関数
Battle_Std.AddAirSkillCount <- function( _slot = 0, _val = 1, _mvs = 0 )
{
	local mvs = ( _mvs == 0 )? BMvTbl.GetMvStatus() : _mvs;
	// 出て少したったら空中必殺技回数制限をかける
	if( mvs.MvCount == 4 && mvs.CallCount == 0 )
	{
		// 空中必殺技の制限をかけました
		BMvTbl.AddAirCount( _slot, _val );
		return 1;
	}
	return 0;
}


Battle_Std.CheckDoujiButton <- function( _info, _samebtn_ok = 0 )
{
	local last_button = _info.GetLastButton(0);
	local button_mask = BCMDTbl.GetSuccessButton(); // _info.GetLastButton(0);
	
	// print("\n 前々回:"+_info.GetLastButton(1)+" 前回:"+last_button+" 今:"+button_mask );

	if( (button_mask - last_button) != (last_button^button_mask) ) return 0; // A+B のあと A+B+Cはいいけど A+Bのあと B+Cはダメ(全部含まれてるか)
	
	if( _samebtn_ok == 0 && last_button == button_mask ) return 0; // A+Bの後A+Bの技を出そうとしたりしたらだめ
	if( !(last_button&button_mask) ) return 0; // Aの後Aを含まない（B+Cとか）の技を出そうとしたりしたらダメ
	
	return 1;
}

// VORPAL攻撃の強化関数
Battle_Std.SetVorpalPattern <- function( _pat = 0 )
{
	if( BMvEff.GRD_GetJudgeResult() > 0 )
	{
		if( _pat ) BMvTbl.SetPattern( _pat );
		// Battle_Std.SetVorpalAtkEffect(); // VPAtk発動エフェクト仮
		return 1;
	}
	return 0;
}

Battle_Std.SetVorpalAtkEffect <- function()
{
	// BMvEff.CreateObject( { datatype=1, start_pat=88 } ); // テスト
	// Battle_Std.SetCharaFlash_GRDJudgeFlash();
}


// 相手のGRDを減らす処理はコンボ中1回のみにする
// 10000 で1ブロック
// 2回目以降は補正がかかるとかでもいいかも？
// 減らす量と吸収する量を指定する
// useflag:0〜2 ※他のやつがかかっていると増加量に補正がかかる
// ※仕様:打撃で始動に使った場合、使った技にカウントされない
local use_grd_minus_flag = [def_DF_GRD_Minused_TypeA, def_DF_GRD_Minused_TypeB, def_DF_GRD_Minused_TypeC];

Battle_Std.EnemyGRD_Minus <- function( _val, _drainval=0, _useflag = 0 ) : (use_grd_minus_flag)
{
	local grd_type_cnt = 0; // 何種類の技で吸収したか
	_dp("\n GRD変動処理開始:"+_val+" 吸収:"+_drainval );
	_dp("\n ["+_useflag+"] チェックフラグ:"+use_grd_minus_flag[_useflag] );
	foreach( val in use_grd_minus_flag )
	{
		local is_minused = Battle_Std.EnemyDamageFlag_Check( val );
		_dp("\n val:"+val+" is_minused:"+is_minused );
		if( is_minused )
		{
			if( val == use_grd_minus_flag[_useflag] )
			{
				grd_type_cnt ++;
				_dp(" -> スキップ");
				return 0; // コンボ中は1回のみ
			}
			else
			{
				grd_type_cnt ++;
				_dp(" -> 他で吸ってる:"+grd_type_cnt);
			}
		}
	
	}
	
	_dp("\n 付与したフラグ:"+use_grd_minus_flag[_useflag] );
	Battle_Std.EnemyDamageFlag_Add( use_grd_minus_flag[_useflag] ); // 「GRDを減らされた」を相手に記憶
	
	local useval = _val; // 実際にGRD操作する値
	
	switch( grd_type_cnt )
	{
	case 3:
		useval = useval * 0;
		break;
	case 2:
		useval = useval * 80 / 100;
		break;
	case 1:
		useval = useval * 40 / 100;
		break;
	default:
		break;
	}
	
	_dp("\n useval:"+useval+" grd_type_cnt:"+grd_type_cnt );
	
	// 減らす
	Battle_Std.GRD_AddValue({ val=-_val, boundplus=1, target=1 }); 
	if( _drainval )
	{
		Battle_Std.GRD_AddValue({ val=_drainval, boundplus=1, target=0 }); 
	}
	_dp(" -> 完了");
}

// 吸収を一応別処理にしてみた
// Battle_Std.EnemyGRD_Drain( 5000 ); // 相手のGRDを吸収する
Battle_Std.EnemyGRD_Drain <- function( _val, _useflag = 0 )
{
	Battle_Std.EnemyGRD_Minus( _val, _val, _useflag );
}

Battle_Std.LP_Rebagatya_Init <- function( _LP0=0, _LP1=1, _LP2=2 )
{
	BMvTbl.SetLP(_LP0,0); // 連打カウンタ
	BMvTbl.SetLP(_LP1,0); // 前回のボタン
	BMvTbl.SetLP(_LP2,0); // 前回のレバー
}

Battle_Std.LP_Rebagatya_Update <- function( _LP0=0, _LP1=1, _LP2=2 )
{
	// レバー回しながらボタンですごい増えるようにするので別チェック
	local button = BMvTbl.CheckCommandString( [ "A", "B", "C" ] );
	if( button && button != BMvTbl.GetLP(_LP1) )
	{
		// _dp("\n ボタン押した");
		BMvTbl.AddLP(_LP0,1); // 連打回数を加算
	}
	BMvTbl.SetLP(_LP1,button);
	
	// ZERO3っぽく斜めも受け付ける
	local stick = BMvTbl.CheckCommandString( [ "4", "6", "2", "8", "1", "3", "9", "7" ] );
	if( stick && stick != BMvTbl.GetLP(_LP2) )
	{
		// _dp("\n レバーまわした");
		BMvTbl.AddLP(_LP0,1); // 連打回数を加算
	}
	BMvTbl.SetLP(_LP2,stick);
	
	// print("\n 連打カウンタ:"+BMvTbl.GetLP(0) );
}

Battle_Std.DrawDebugRect <- function( param={} )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect", x=("x" in param)? param.x : 0, y=("y" in param)? param.y : 0 } );
	if( eff.push() )
	{
		if( "setx" in param) BMvTbl.SetPosition( { x=param.setx } );
		if( "sety" in param) BMvTbl.SetPosition( { y=param.sety } );
		eff.pop();
	}
}

Battle_Std.DrawDebugRectPos <- function( pos )
{
	local eff = BMvEff.CreateObject( { datatype=1, start_pat="dbg_rect" } );
	if( eff.push() )
	{
		BMvTbl.SetPosition( { x=pos.x, y=pos.y } );
		eff.pop();
	}
}

// サポートキャラの汎用ステータス（全体を初期化されることは無い）
Battle_Std.SupSt_AddFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)|flag )
}

Battle_Std.SupSt_DelFlag <- function( flag )
{
	BMvTbl.SetPP( def_PP_SupStatus, BMvTbl.GetPP(def_PP_SupStatus)&~flag )
}

Battle_Std.SupSt_CheckFlag <- function( flag )
{
	return( ( (BMvTbl.GetPP(def_PP_SupStatus)&flag)!=0 )? 1 : 0 );
}

Battle_Std.SetPP_JumpStartHeight <- function()
{
	local pos = BMvTbl.GetPosition( 0 );
	BMvTbl.SetPP( def_PP_JumpStartHeight, pos.y ); // ジャンプをしたときの高さを入れる
	
	// _dp("\n ジャンプ時の高さ:"+pos.y );
}

// 見た目のサポートとサポートの親の向きを合わせて振り向かせる
Battle_Std.SupportSetMuki <- function( _flag = _Direction_Auto )
{
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
		
		player.pop();
	}
	BMvTbl.SetMuki( _flag ); // 相手の方を振り向く
}



Battle_Std.LP_Rebagatya_Check <- function( param={} )
{
	local lp0 = param.CheckLP;
	local cnt = BMvTbl.GetLP(lp0);
	
	for( local i=0; i<param.List.len(); i++ )
	{
		if( cnt >= param.List[i] )
		{
			BMvTbl.AddLP(lp0,-param.List[i]);
			local ret = param.List.len() - i;
			_dp("\n レバガチャLV:"+ret+"/"+param.List.len() );
			return ret;
		}
	}
	return 0;
}

Battle_Std.SetHosyoHosei <- function( _val=100 )
{
	local now_val = BMvTbl.GetHoseiMinValue();
	if( _val < now_val )
	{
		_dp("\n 保証補正:"+now_val+"% -> "+_val+"%");
		BMvTbl.SetHoseiMinValue( _val ); // 以降のコンボの保証ダメージを変更
	}
	else
	{
		_dp("\n 保証補正:"+now_val+"% のまま("+_val+"%)が大きい");
	}
}

// 最低保証補正を乗算
Battle_Std.SetHosyoHosei_Multi <- function( _par )
{
	local now_val = BMvTbl.GetHoseiMinValue();

	local calc_val = now_val * _par / 100;
	if( calc_val < 0 ) calc_val = 0; // 下限
	if( calc_val > 130 ) calc_val = 130; // 上限

	_dp("\n 保証補正("+_par+"%):"+now_val+"% -> "+calc_val+"%");
	BMvTbl.SetHoseiMinValue( calc_val ); // 以降のコンボの保証ダメージを変更
}


local hosyoParams = {
	EX =
	{
		flag = def_DF_SpHosyoHoseiSeted_DoubleEx,
		hosei=def_HosyoHosei_NoDyingComboUsedExSkill_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingComboUsedExSkill_Init
		dyinghosei=def_HosyoHosei_DyingComboUsedExSkill_Init
	},
	VO =
	{
		flag = def_DF_SpHosyoHoseiSeted_VOsukasi,
		hosei=def_HosyoHosei_NoDyingVO_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingVO_Init
		dyinghosei=def_HosyoHosei_DyingVO_Init
	},
	CVO =
	{
		flag = def_DF_SpHosyoHoseiSeted_CVO,
		hosei=def_HosyoHosei_NoDyingComboVO_Init,
		suddundyinghosei=def_HosyoHosei_SuddenDyingComboVO_Init
		dyinghosei=def_HosyoHosei_DyingComboVO_Init
	},
}
	
//EX2回、VOスカ、CVOでの保証補正処理
//基本的に今の値に対して乗算するが…
Battle_Std.SetSpHosyoHosei <- function( param = {} ) : ( hosyoParams )
{
	local hosyoParam = {
		flag = 0,
		hosei = 0,
	}
	
	local isDying = ( BMvTbl.GetMvStatus().flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
	local vpcombo = Battle_Std.EnemyDamageFlag_Check( def_DF_Vorpaled );
	
	local useparam = hosyoParams[ param.type ];
	hosyoParam.flag = useparam.flag;
	hosyoParam.hosei = ( isDying && vpcombo )? useparam.dyinghosei : ( isDying )? useparam.suddundyinghosei : useparam.hosei;
	
	_dp("\n ■SetSpHosyoHosei:"+param.type+" 補正:"+hosyoParam.hosei+"%" );

	// const def_DF_SpHosyoHoseiSeted_DoubleEx = 512; // EXの同技
	// const def_DF_SpHosyoHoseiSeted_VOsukasi = 1024; // VOスカ
	// const def_DF_SpHosyoHoseiSeted_CVO = 2048; // CVO発動
	// const def_DF_SpHosyoHoseiSeted = 3584; // EXの同技やVOスカ、CVO発動で保証補正をかけたかどうか
	
	// const def_HosyoHosei_DyingComboVO_Init = 90; // コンボヴェールオフ、瀕死時　※CVOは瀕死の時の補正がゆるめ(キャラ差が少ないので)
	// const def_HosyoHosei_SuddenDyingComboVO_Init = 70; // 瀕死CVO（コンボ中にVPになった場合）
	// const def_HosyoHosei_NoDyingComboVO_Init = 70; // コンボヴェールオフ、瀕死じゃない時の保証補正

	// const def_HosyoHosei_DyingVO_Init = 85; // ヴェールオフ、瀕死時
	// const def_HosyoHosei_SuddenDyingVO_Init = 70; // ヴェールオフ、瀕死時
	// const def_HosyoHosei_NoDyingVO_Init = 70; // ヴェールオフ、瀕死じゃない時の保証補正

	// const def_HosyoHosei_DyingComboUsedExSkill_Init = 85; // コンボ中にEX技を２回出そうとしたとき
	// const def_HosyoHosei_SuddenDyingComboUsedExSkill_Init = 70; // コンボ中にEX技を２回出そうとしたとき
	// const def_HosyoHosei_NoDyingComboUsedExSkill_Init = 70; // コンボ中にEX技を２回出そうとしたとき
	
	if( Battle_Std.EnemyDamageFlag_Check( hosyoParam.flag ) )
	{
		_dp("\n 既に同じ補正をかけています");
		return 0;
	}
	
	local minHosei = 100; // 今までかけてきた補正で一番キツい値を調べる
	foreach( slot, val in hosyoParams )
	{
		local usehosei = ( isDying && vpcombo )? val.dyinghosei : ( isDying )? val.suddundyinghosei : val.hosei;
		if( Battle_Std.EnemyDamageFlag_Check( val.flag ) )
		{
			_dp("\n "+slot+" : ◯ 補正:"+usehosei );
			if( minHosei > usehosei )
			{
				minHosei = usehosei;
			}
		}
		else
		{
			_dp("\n "+slot+" : × 補正:"+usehosei );
		}
	}
	_dp("\n 現在までのキツい補正:"+minHosei+" 今かけたい補正:"+hosyoParam.hosei );
	
	if( minHosei < 1 ) minHosei = 1; // 0div
	if( minHosei > hosyoParam.hosei )
	{
		// それよりも重いやつをかけたい場合は、その差分をかけるようにする
		// local setHosei = 100 - ( minHosei - hosyoParam.hosei );
		local setHosei = ( hosyoParam.hosei * 100 / minHosei );
		Battle_Std.SetHosyoHosei_Multi( setHosei );
	}

	// 補正をかけようとしたのを記憶
	Battle_Std.EnemyDamageFlag_Add( hosyoParam.flag );

	return 1; // 成功
}


Battle_Std.PP_CheckFlag <- function( _PPSlot, _flag )
{
	return( BMvTbl.GetPP(_PPSlot)&_flag ); // フラグチェック
}

Battle_Std.PP_AddFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)|_flag ); // フラグ追加
}

Battle_Std.PP_DelFlag <- function( _PPSlot, _flag )
{
	BMvTbl.SetPP( _PPSlot, BMvTbl.GetPP(_PPSlot)&~_flag ); // フラグ消去
}

// 
Battle_Std.Val_CheckFlag <- function( _val, _flag )
{
	return( _val&_flag ); // フラグチェック
}

Battle_Std.Val_AddFlag <- function( _val, _flag )
{
	return (_val|_flag); // フラグ追加
}

Battle_Std.Val_DelFlag <- function( _val, _flag )
{
	return (_val&~_flag ); // フラグ消去
}

Battle_Std.LP_AddFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)|_flag )
}

Battle_Std.LP_DelFlag <- function( _lp, _flag )
{
	BMvTbl.SetLP( _lp, BMvTbl.GetLP(_lp)&~_flag )
}

Battle_Std.LP_CheckFlag <- function( _lp, _flag )
{
	return( BMvTbl.GetLP(_lp)&_flag );
}

Battle_Std.SP_AddFlag <- function( _sp, _flag )
{
	//BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)|_flag )
}

Battle_Std.SP_DelFlag <- function( _sp, _flag )
{
	//BMvTbl.SetSP( _sp, BMvTbl.GetSP(_sp)&~_flag )
}

Battle_Std.SP_CheckFlag <- function( _sp, _flag )
{
	//return( BMvTbl.GetSP(_sp)&_flag );
}

Battle_Std.CreateIgnitionPAni <- function( _pat, _team, _prio, _delay, _type=-1 )
{
}

Battle_Std.CheckIgnition <- function( _type )
{
}

Battle_Std.CheckDoubleIgnition <- function( _type )
{
}

Battle_Std.CheckSubSupportType <- function( _type )
{
}

Battle_Std.SetObjectSousaiLv <- function()
{
}

Battle_Std.SupportAtk_Init <- function()
{
}

Battle_Std.SupportAtk_DamageFinalize <- function()
{
}

Battle_Std.SupportAtk_EscapeFinalize <- function()
{
}

// 追撃タイミングかどうかチェック
// 相原延寿、ハルユキで使用中
// つかみ中や投げ抜け関係には反応しない優秀な追撃チェック
Battle_Std.CheckTuigeki <- function()
{
	/*
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local mvname = BMvTbl.GetMvName();

		enemy.pop();
		
		if( bs.isBound == 1 && bs.isCapture == 0 && mvname!="Mv_Bound_0023" && mvname!="Mv_Bound_0024" )
		{
			return 1;
		}
	}
	return 0;
	*/
}

// 自分が空中状態の時のみチェック
// ジャンプ攻撃の攻撃判定が出たらそこで消滅（チェックはここまでにやっている）

// 条件：「相手が立ちガードで、さらに
// （　…ヒットストップの影響を受けている間（ベクトルのフレームが0だと真）」は不要っぽいので消す　）
// 自分がジャンプ攻撃を出すと、しゃがみガード可能なフラグが立つ
// 条件が満たされない場合、ジャンプ攻撃につけたしゃがみガード可能なフラグは消される（上段が中段になるわけでなく、判定データを参照するようになる）

Battle_Std.CheckAirAtkFsiki <- function()
{
	if( !Battle_Std.MoveCode.CheckFlag( def_MC_EnableAirAtkStatus ) ) return;
	
	// ヒットしたらもういいでしょ
	if( Battle_Std.MoveCode.CheckFlag( def_MC_HitStatus_Damage|def_MC_HitStatus_Guard ) ) return;
	
	if( !Battle_Std.ChangeMoveCodeEx_CheckFlag( 1, def_MC1_AirAtkKirikaeTyudanCheckStart ) )
	{
		// _dp("\n 前のMvのチェックでアウト");
		return;
	}
	
	// _dp("\n チェック中。。。");
	
	local isStandHitStopFrame = 0; // 立ち状態でヒットストップ中
	local isHitOnlyStand = 0; // 立ちのみにあたる（しゃがんでたら当たらないはずの攻撃）
	local isStandGuardFrame = 0;
	
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		local bs = BtlMvStd.GetBoundStatus();
		local isStand = BCMDTbl.CheckPosState( _PosState_Stand );
		local croRc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 15 ], flags=0 } );

		enemy.pop();
		
		if( bs.isBound == 2 ) // ガード状態
		{
			// 立ちのガード状態＆しゃがみ用の特殊判定が指定してある
			if( isStand && croRc.sx != _Hantei_Error  )
			{
				isStandGuardFrame = 1;
			}
			// if( bs.BoundTime == 0 && isStand )
			// {
				// isStandHitStopFrame = 1;
			// }
		}
	}
	
	local isAirSt = BCMDTbl.CheckPosState( _PosState_Air );
	local isAirAtk = Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_AtkJump ); // 自分がジャンプ攻撃を出していると1
	
	// しゃがみの判定の矩形に触れているかチェック
	// これに触れていなかったら、立ちにしか当たらない攻撃になるので、Ｆ式での崩しになる
	// しゃがみの判定の矩形に触れていなくて、立ちの判定に触れている、でチェック
	// _dp("\n BMvEff.IsAttackRect():"+BMvEff.IsAttackRect() );
	if( BMvEff.IsAttackRect()==2 ) // 攻撃が出現し、残りHIT数が０でない状態
	{
		local hitCrouch = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Etc , 15, 1 ], flags=_HC_EnemyPc } );
		// local hitStand = BMvEff.CheckHantei( { src=[ _Hantei_Attack, 0, -1 ], dst=[ _Hantei_Etc , 14, 1 ], flags=_HC_EnemyPc } );
		// hitStandに_Hantei_Etcを使っているのは、重なり判定による1Fの位置移動が、CheckHanteiでは検知できないため。他にもなんかありそうなので大きめにした。
		// _dp("\n hitCrouch:"+hitCrouch.isdone()+" hitStand:"+hitStand.isdone() );
		
		// if( !hitCrouch.isdone() && hitStand.isdone() ) // 触れていない
		if( !hitCrouch.isdone() ) // 触れていない
		{
			// _dp("\n isHitOnlyStand:"+isHitOnlyStand );
			isHitOnlyStand = 1;
		}
	}			
	if( isAirSt && isAirAtk )
	{
		if( isStandGuardFrame && isHitOnlyStand )
		{
			_dp("\n しゃがんでいると当たらなそうなので上段に変更");
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=18, flag=_ClearFlag_ChangeMv } );
			Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei );
		}
		else
		{
			if( !Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_RockerteerHosei ) && 
			Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHosei ) &&
			!Battle_Std.PP_CheckFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear )
			) // 上段化した 
			{
				_dp("\n 上段にしてたのを戻す:"+isStandGuardFrame+" ,"+isHitOnlyStand );
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch, time=0, flag=0 } );
				Battle_Std.PP_AddFlag( def_PP_AirAtkStatus, def_PP_AAS_KirikaeHoseiClear );
			}
		}
	}
}

Battle_Std.CallFreezObject <- function()
{
}

local debugwrite = { val=[{},{}] };

Battle_Std.DebWrite_ValTiming <- function( _param ) : (debugwrite)
{
	if( !Def_Dbg_LocalDebugMode ) return;
	
	local pside = BMvTbl.GetPlayerSide();
	
	if( _param == 0 )
	{
		debugwrite.val[0] = {}; // 初期化
		debugwrite.val[1] = {}; // 初期化
		return;
	}
	
	foreach( name, v in _param )
	{
		if( !( name in debugwrite.val[pside] ) )
		{
			// _dp("\n "+name+" がないので追加");
			debugwrite.val[pside][name] <- null;
		}
		
		if( debugwrite.val[pside][name] != v )
		{
			_dp("\n ["+name+"] "+debugwrite.val[pside][name] +" -> "+ v );
		}
		debugwrite.val[pside][name] = v;
	}
}

// ジャンプの高さを始まり〜終わりで0〜100にして表す関数
// 0だと最初、50だと頂点、100だと着地、みたいな感じ
// _Vector_Normalのみで動く単純なジャンプにしか使えない
Battle_Std.GetJumpVectorPar <- function( _start_y_vec )
{
	local vec = BMvTbl.GetVector( { flags=_Vector_Normal } );
	local par = 50 - (vec.y-vec.addy)*50/_start_y_vec;
	if( par <   0 )
	{
		par =   0; // 落ちすぎる、は検知しない
	}
	else if( par > 100 )
	{
		par = 100; // 飛びすぎる、は検知しない
	}
	// _dp("\n _start_y_vec:"+_start_y_vec+" vec.y:"+vec.y+" par:"+par );
	return par;
}

Battle_Std.AddMoveCode_CSAntenGaesiSkill <- function()
{
	// チェインシフト状態かどうか
	// 直前の行動がチェインシフトである
	// CSして追撃しようとするとダメ
	// _dp("\n BMvEff.GRD_GetConvertCount():"+BMvEff.GRD_GetConvertCount() );
	// _dp("\n Battle_Std.CheckEnemyisBound():"+Battle_Std.CheckEnemyisBound() );
	if( BMvEff.GRD_GetBreak( 0 ) == 100 && BMvEff.GRD_GetConvertCount() == 0 && !Battle_Std.CheckEnemyisBound() )
	{
		// 相手がやられ中以外で、CSゲージがあるとフラグが立ちます
		_dp("\n CSゲージがある最中の発動です");
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CSAntenGaesiSkill );
	}
}

// CSからの暗転返しで出したら追撃不能にする
Battle_Std.CSAntenGaesi_NoAttackHit <- function()
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CSAntenGaesiSkill ) )
	{
		local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();

			// short BtlMvStd::MvBoundStatus::isBound
			// 0 --- のけぞり状態でない
			// 1 --- のけぞり状態
			// 2 --- のけぞり状態でガードしている

			//のけぞりorつかまれ
			if( bs.isBound == 1 || bs.isCapture != 0 )
			{
				BMvTbl.SetWallCount( 100 ); //追撃不能状態にする
				_dp("\n CS暗転返し技なので追撃不能にします");
			}
			
			enemy.pop();
		}
	}
}

//CSしなかった場合ダメージ補正をかける
//また、暗転返しで出した場合
Battle_Std.CSAntenGaesi_DamageHosei <- function( _zyozanHosei=70, _uwagakiHosei=70 )
{
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_CSAntenGaesiSkill ) )
	{
		// _dp("\n ★CSの暗転返しから出したので補正をかけます");
		// BMvEff.ComboView_Set( { val=_uwagakiHosei, type=0 } ); // 上書き補正
		// BMvEff.ComboView_Set( { val=_zyozanHosei, type=1 } ); // 乗算補正
		
		Battle_Std.EnemyDamageFlag_Add( def_DF_CSAntenGaesied ); // 相手にCS暗転返しされたフラグをたてる
	}
	
	// 監視オブジェクト生成
	// CS無しで追撃した場合にダメージを低下させる
	if( Battle_Std.MoveCodeEx.CheckFlag( 1, def_MC1_SidouHitSkill ) )
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Null_CSHoseiChecker" } );
		if( eff.push() )
		{	
			// かける予定の補正値を入れる
			// 上書き補正だけでいいのでは説はある？
			
			BMvTbl.SetLP(0,_uwagakiHosei);
			BMvTbl.SetLP(1,_zyozanHosei);
			
			eff.pop();
		}
	}
}

Battle_Std.PassBeforeMoveCodeEx <- function( _pos, _flag )
{
	if( Battle_Std.ChangeMoveCodeEx_CheckFlag( _pos, _flag ) )
	{
		Battle_Std.MoveCodeEx.AddFlag( _pos, _flag );
	}
}

// １つ前の行動のMvActionを引き継ぐ
Battle_Std.CopyBeforeMoveAction <- function()
{
	BMvTbl.SetMvAction( BMvTbl.ChangeMv_GetMvAction() );
}

Battle_Std.SetKezurareDamage <- function( _dmg_val )
{
	if( BMvEff.GuardSP_Get() == 0 ) // シールドじゃなかったら
	{
		// 確定で凄く削る
		BMvEff.SetHpGauge( { value=-_dmg_val } ); // 削り
	}
}
Battle_Std.CheckMainisDamage <- function()
{
}

Battle_Std.CheckMainisBound <- function()
{
}

// ヒット分岐で引き継ぐものまとめ
// 必殺技のヒット分岐だと自動で実行されるが、通常技のやつは手動で追加が必要
Battle_Std.PassHitMoveCodes <- function()
{
	Battle_Std.PassBeforeMoveCodeEx( 2, def_MC2_CounterHit ); // カウンターヒット引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_SidouHitSkill ); // 始動技であることの引継ぎ
	Battle_Std.PassBeforeMoveCodeEx( 7, def_MC7_ThrowCounter ); // 投げで硬直を掴んだことの引継ぎ
}

// アサルト中ならフラグが立ってないとダメにする
Battle_Std.CheckEnableFlag_AssaultAirA <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 1 ) ) return 0;
	}
	return 1;
}

Battle_Std.CheckEnableFlag_AssaultAirB <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 2 ) ) return 0;
	}
	return 1;
}

Battle_Std.CheckEnableFlag_AssaultAirC <- function()
{
	if( Battle_Std.IsMatchMvNameArray( ["Mv_Assault_Std","Mv_Assault_Air"] ) )
	{
		if( !Battle_Std.LP_CheckFlag( 2, 4 ) ) return 0;
	}
	return 1;
}

Battle_Std.CheckParamFlags <- function( paramNum, checkFlag )
{
	local mvs = BMvTbl.GetMvStatus();
	local useParam = 0;
	switch( paramNum )
	{
	case 0:
		useParam = mvs.Param0;
		break;
	case 1:
		useParam = mvs.Param1;
		break;
	case 2:
		useParam = mvs.Param2;
		break;
	case 3:
		useParam = mvs.Param3;
		break;
	default:
		return 0;
		break;
	}
	if( useParam&checkFlag ) return 1;
	return 0;
}


//壁チェックを無くした超技のあとに使う（超技以外で使うと、ヴォーパルの湯気とか色々ダメだと思う）
//キャラが行ける限界内にカメラ座標を動かして、両者の座標も相対的に動かす
//キャラを動かすのでエフェクトとか飛び道具が出ているとダメなので注意
Battle_Std.SetBothCharaInStagePosition <- function()
{
	//向きで判断するんじゃなくて、左右どちらの端が近いかで判断する
	local pos = BMvTbl.GetPosition(0);
	local muki = ( pos.x > 0 )? 1 : -1;
	
	local crect = BMvEff.GetCameraRect( { flags=_GetPos_TrueCamera } );
	local stage_corner = ( muki == 1 )? def_POS_GamenHajiX : -def_POS_GamenHajiX;//A

	//def_POS_GamenHajiXはキャラが行ける限界値なので、カメラはもうちょい外にある（def_POS_GamenGaiYuuyoX）
	local camera_corner = ( muki == 1 )? crect.ex - def_POS_GamenGaiYuuyoX : crect.sx + def_POS_GamenGaiYuuyoX;//B
	local camera_zure = stage_corner - camera_corner;//これだけキャラが行ける限界座標をカメラが超えている
	
	if( camera_zure*muki < 0 )
	{
		local cpos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_NoMuki } );
		
		BMvEff.SetCamera_Focus( { x=cpos.x+camera_zure, y=cpos.y, time=[0,0,0] } );
		
		BMvTbl.SetPosition( { x=camera_zure, flags=_Position_Add } );
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetPosition( { x=camera_zure, flags=_Position_Add } );
			enemy.pop();
		}
		//次のフレームにカメラ位置をリセットする
		BMvEff.CreateObject( { datatype=1, mvname="Mv_Null_NextFrameResetViewCamera" } );
	}
}

//判定の左上座標を取得
Battle_Std.GetPoint <- function( param={} )
{
	local pot = { x=_Hantei_Error, y=_Hantei_Error };
	local rc = BMvEff.GetHanteiRect( { check=param.rect, flags=0 } );
	local muki = BMvTbl.GetMuki();
	
	if( rc.sx != _Hantei_Error )
	{
		pot.x = ( muki == 1 )? rc.sx : rc.ex;
		pot.y = rc.sy;
	}
	return pot;
}

Battle_Std.SetInActiveEffect <- function()
{
	if( !Battle_Std.GS_CheckFlag( def_PP_GS_KeepInActive ) )
	{
		Battle_Std.DrawInActiveEffect(); // 相手にもやもやを出す
		
		// GRD減少のデメリット
		// でばなをくじかれた…カウンター的なニュアンス
		// ダメージアップだと運ゲーの加速がすごいので、ダメージ以外＝GRD
		Battle_Std.GRD_AddValue({ val=def_GRD_InActive, pressure=0, boundplus=1 });
		
		//InActive検知のあと相手が行動可能になるまで継続するオブジェクトを生成
		//def_PP_GS_KeepInActive フラグ管理
		//これが生きている間に殴ると相手のゲージ増加量が減る
		BMvEff.CreateObject( { mvname="Mv_Null_KeepInActive" } );
	}
}

Battle_Std.DrawInActiveEffect <- function()
{
	// 行動不能でガードでもやられでも無敵でもない
	BMvEff.SetCharaFlash( { color = 0xFFA0A0, type = 0, time = 15 } ); //動けないので赤く光る
	BMvEff.SetCharaColor( { color = 0xFFA0A0, type = 0, time = 40 } ); //動けないので赤く光る
	
	local sety = -150; // 重なりがないときのデフォ位置
	local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
	if( rc.sx != _Hantei_Error ) // 存在するか
	{
		sety = (rc.ey - rc.sy)/4 + rc.sy; // 重なりの真ん中よりちょい上
		// _dp("\n sety:"+sety);
	}
	Battle_Std.CreateObjectEX( { x=0, y=sety, datatype=1, pat="sternness", flags=_Position_ToolShift,
	objectflags=_ObjFlags_MoveTimeStopAll } );
}

// ミカの214EXやリンネの63214EXなど
// 何もしないでもジャンプする技に対して、距離が遠いときに少しジャンプ力を増やしてセットする関数
// ジャンプ力が減ることはない
// seachDistance : チェックする距離
// vec.addy : 
// vec.x : 
// flags : (1<<0) : 高さは変えない
Battle_Std.SetVector_SeachJump <- function( param={} )
{
	local flags = ("flags" in param)? param.flags : 0;
	local min_frame = ("min_frame" in param)? param.min_frame : 8;
	local max_frame = ("max_frame" in param)? param.max_frame : 20;
	
	local edis = Battle_Std.GetEnemyDistance();
	if( edis > param.seachDistance ) edis = param.seachDistance;
	local vec = BMvTbl.GetVector();
	if( vec.addy == 0 ) vec.addy = param.vec.addy; // 適当div0
	if( vec.x == 0 ) vec.x = param.vec.x; // 適当div0
	
	local landFra = -vec.y * 2 / vec.addy;
	if( landFra <  min_frame ) landFra =  min_frame;
	if( landFra > max_frame ) landFra = max_frame;
	
	local xVec = edis / landFra;
	local yVec = vec.y;
	if( xVec > vec.x )
	{
		//
		local jumpPow = xVec * 100 / vec.x; // ジャンプ距離増加倍率
		// 倍率が多い時はすこしジャンプの高さもあげて、着地までの時間を遅くする？
		// その分遠くまで飛ぶんだけど、それを補正かけると、今度は境目が微妙では？大丈夫か？
		
		local par = 35; // これが0だと着地まで同じ、100だと倍率分遅くなる
		local jumpParCalc = ( 100 + ((jumpPow-100)*par/100) );
		if( jumpParCalc == 0 ) jumpParCalc = 1; // div0

		xVec = xVec * 100 / jumpParCalc;
		if( !(flags&(1<<0)) ) yVec = yVec * jumpParCalc / 100;
		
		BMvTbl.SetVector( { x=xVec, y=yVec, flags=_Vector_Normal } );
		// _dp("\n 着地まで:"+landFra+" Vec:"+xVec+","+yVec+" jumpPow:"+jumpPow );
	}
	// 近いからっていってジャンプが弱くなることはない
}

//キャッチ判定での当身成功時、とったものが飛び道具だったときの処理
//当身成功後のHitInterrupt内で呼び出す
//hit_status : 弾と親に伝えるヒットストップ（ BMvTbl.MvHitStatus() ）
Battle_Std.SetFireBallFlags_InAtemiHitInterrupt <- function( param={} )
{
	// 取られ側
	local ene = BMvCore.GetLastHitCharaData(0); // 当て身で入ってくるのは「LastHitChara」なので注意 0なのでそのまま相手
	if( ene.push() )
	{
		BMvTbl.CalcHitValue(-1); //残りヒット数を１減らす
		BMvTbl.SetMvHitStatus( param.hit_status ); // ヒットストップとか設定
		
		// 飛び道具の時の処理
		local ets = Battle_Std.GetFireBallStatus(); //飛び道具ステータス取得
		local e_mvcode = BMvTbl.GetMoveCode();
		
		//_dp("\n "+ets.isSousaiObj + ", "+ets.HitCount +", "+ets.isFireBall );
		if( e_mvcode&def_MC_Sousai && ets.HitCount <= 0 )
		{
			if( ets.isFireBall ) //飛び道具なら自動で消滅フラグまで立てる
			{
				Battle_Std.SetFireBallFlags(def_BallFlags_Finalize); //次回ファイナライズしてね
			}
		}
		// とったオブジェクトの親が操作親じゃない場合はそれにもヒットストップをかける
		local oya = BMvCore.GetParentCharaData();
		if( oya.isdone() && oya.isPlayer()==0 )
		{
			if( oya.push() )
			{
				BMvTbl.SetMvHitStatus( param.hit_status ); // ヒットストップとか設定
				oya.pop();
			}
		}
		ene.pop();
	}
}

Battle_Std.SetSpecialEXSLimit_Enemy <- function( exs_limit=70 )
{
	if( !Battle_Std.EnemyDamageFlag_Check( def_DF_SetedEXSLimit ) )
	{
		Battle_Std.EnemyDamageFlag_Add( def_DF_SetedEXSLimit );

		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			_dpn("ゲージ増加制限");
			BMvEff.AttackInfoString_Set({ word=def_AISW_CCSEXLimit,} ); // 相手に出す
			BMvEff.SpGauge_SetLimitBound( { val=exs_limit, time=420 } );
		
			enemy.pop();
			
			return 1;
		}
	}
	return 0;
}

//EX技で設置する技の間ゲージ増加制限をかける用の関数
Battle_Std.EXSLimit_EXSkillObject <- function()
{
	if( Def_Dbg_EXSLimit_EXSkillOki )
	{
		// _dpn("EX起き攻め制限中...");
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			BMvEff.SpGauge_SetLimitCombo( { val=25, time=def_FL_EXSLimit_EXSkill } ); //ゲージ増加制限
			
			player.pop();
		}
	}
}

//単純な取得ではなく、振り向きをチェックする
//振り向き予定なら反転する
//このコマンドのあと相手の方向に振り向く技だった場合、これを使ったほうがいい（例えば地上技など）
//TODO:コマンド入力時のレバーの向き、という処理で作ったほうがスマート
//コマンド成立時のキャラの向きとレバー方向を記憶しておき、チェック時と向きが異なっていたら反転するみたいなイメージ
Battle_Std.GetStickHold_FurimukiReverse <- function()
{
	local stick = BMvTbl.GetStickHold();
	local player = BMvCore.GetPlayerCharaData();
	if( player.push() )
	{
		local stick_rev_ar = [0,3,2,1,6,5,4,9,8,7];//左右反転用
		stick = BMvTbl.GetStickHold(); // 面倒なので２回取得する
		local furimuki = BMvTbl.CheckFurimuki();
		
		player.pop();
		
		if( furimuki )
		{
			if( stick <= stick_rev_ar.len()-1 )
			{
				stick = stick_rev_ar[stick];//反転
			}
		}
	}
	return stick;
}


//EXキャンセルを見る
//そのままだと空振りでも出せてしまうのがデフォなので
//フラグ次第ではヒット情報を見るようになる(ほぼCS用の処理。cmdとは別にやってるので注意)
Battle_Std.CheckExSpecialCancel <- function()
{
	if( !BCMDTbl.CheckCancel( _SkillType_ExSpecial ) ) return 0;
	if( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_NoWhiffEXCancel ) )
	{
		local hs = BMvTbl.GetMvHitStatus();
		if( !(hs.Type & _HitType_Hit) )
		{
			return 0;
		}
	}
	return 1;
}

//ロックなどでダメージ中無敵にする　※LastUpdateで解除するのを忘れないように
Battle_Std.SetDamageMutekiFrame <- function( _frame=60 )
{
	local hs = BMvTbl.GetMvHitStatus();
	local isDamage = (hs.Type & _HitType_Damage && hs.isCatchFlag == 0);
	
	if( isDamage )
	{
		BMvEff.SetPlayerTimer( { muteki_nage=_frame, muteki_dage=_frame } ); //ヒットしたら無敵で上書き
	}
}

Battle_Std.CheckLastDamageCharaIsPlayer <- function()
{
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		// 自分が最後に「殴られた相手」を取得
		local lastDamageChara = BMvCore.GetLastDamageCharaData( 0 );
		
		enemy.pop();
		
		if( lastDamageChara.isPlayer() )
		{
			return 1;
		}
	}
	return 0;
}

Battle_Std.EnemyDamageFlag_DelayAdd <- function( flags )
{
	_dpn("EnemyDamageFlag_DelayAdd");
	local eff = BMvEff.CreateObject( { mvname="Mv_Null_EnemyDamageFlag_DelayAdd" } );
	if( eff.push() )
	{
		BMvTbl.SetLP(0,flags);
		eff.pop();
	}
}

//EX技2回の保証補正をちょっと戻す
Battle_Std.RecoverDoubleExHohoHosei <- function()
{
	//EX>EX>IWなどが減らない問題対策
	//EX>IW のときの保証より減りすぎるのがキツい
	//EX>EXが検知できたとき、ある程度元に戻すような係数をかける
	local check_double_ex_hosei = Battle_Std.EnemyDamageFlag_Check( def_DF_SpHosyoHoseiSeted_DoubleEx );
	if( check_double_ex_hosei )
	{
		// local plHosyoHosei = BMvTbl.GetHoseiMinValue();
		// local isDying = ( BMvTbl.GetMvStatus().flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
		// local vpcombo = Battle_Std.EnemyDamageFlag_Check( def_DF_Vorpaled );
		// local val =  { dyinghosei=130, suddundyinghosei=130, hosei=130 };//ある程度戻す
		// local usehosei = ( isDying && vpcombo )? val.dyinghosei : ( isDying )? val.suddundyinghosei : val.hosei;
		//全部結局同じじゃん…
		
		Battle_Std.SetHosyoHosei_Multi( def_HosyoHosei_SpRecoverDoubleEx );
	}
}

print("\n btl_MvFunc.....OK");